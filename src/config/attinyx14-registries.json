{
  "regs": [
    {
      "name": "GPIOR",
      "datasheetPage": 20,
      "offsets": [
        {
          "offset": "0x00",
          "name": "GPIOR0",
          "fields": [
            {
              "name": "GPIOR",
              "size": 8,
              "title": "GPIO Register byte"
            }
          ],
          "title": "General Purpose I/O register n",
          "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the\nbitaccessible I/O memory space."
        },
        {
          "offset": "0x01",
          "name": "GPIOR1",
          "fields": [
            {
              "name": "GPIOR",
              "size": 8,
              "title": "GPIO Register byte"
            }
          ],
          "title": "General Purpose I/O register n",
          "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the\nbitaccessible I/O memory space."
        },
        {
          "offset": "0x02",
          "name": "GPIOR2",
          "fields": [
            {
              "name": "GPIOR",
              "size": 8,
              "title": "GPIO Register byte"
            }
          ],
          "title": "General Purpose I/O register n",
          "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the\nbitaccessible I/O memory space."
        },
        {
          "offset": "0x03",
          "name": "GPIOR3",
          "fields": [
            {
              "name": "GPIOR",
              "size": 8,
              "title": "GPIO Register byte"
            }
          ],
          "title": "General Purpose I/O register n",
          "description": "These are general purpose registers that can be used to store data, such as global variables and flags, in the\nbitaccessible I/O memory space."
        }
      ]
    },
    {
      "name": "SIGROW",
      "datasheetPage": 22,
      "offsets": [
        {
          "offset": "0x00",
          "name": "DEVICEID0",
          "fields": [
            {
              "name": "DEVICEID",
              "size": 8,
              "title": "Byte n of the Device ID"
            }
          ],
          "title": "Device ID n",
          "description": "Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\nof three bytes: SIGROW.DEVICEID[2:0]."
        },
        {
          "offset": "0x01",
          "name": "DEVICEID1",
          "fields": [
            {
              "name": "DEVICEID",
              "size": 8,
              "title": "Byte n of the Device ID"
            }
          ],
          "title": "Device ID n",
          "description": "Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\nof three bytes: SIGROW.DEVICEID[2:0]."
        },
        {
          "offset": "0x02",
          "name": "DEVICEID2",
          "fields": [
            {
              "name": "DEVICEID",
              "size": 8,
              "title": "Byte n of the Device ID"
            }
          ],
          "title": "Device ID n",
          "description": "Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\nof three bytes: SIGROW.DEVICEID[2:0]."
        },
        {
          "offset": "0x03",
          "name": "SERNUM0",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x04",
          "name": "SERNUM1",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x05",
          "name": "SERNUM2",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x06",
          "name": "SERNUM3",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x07",
          "name": "SERNUM4",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x08",
          "name": "SERNUM5",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x09",
          "name": "SERNUM6",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x0A",
          "name": "SERNUM7",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x0B",
          "name": "SERNUM8",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x0C",
          "name": "SERNUM9",
          "fields": [
            {
              "name": "SERNUM",
              "size": 8,
              "title": "Serial Number Byte n"
            }
          ],
          "title": "Serial Number Byte n",
          "description": "Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."
        },
        {
          "offset": "0x20",
          "name": "TEMPSENSE0",
          "fields": [
            {
              "name": "TEMPSENSE",
              "size": 8,
              "title": "Temperature Sensor Calibration Byte n",
              "description": "Refer to 30.3.2.6 Temperature Measurement for how to use the values; 6.9.2 Signature Row Description section for\nlocation of values."
            }
          ],
          "title": "Temperature Sensor Calibration n",
          "description": "These registers contain correction factors for temperature measurements by the ADC. SIGROW.TEMPSENSE0 is a\ncorrection factor for the gain/slope (unsigned), SIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."
        },
        {
          "offset": "0x21",
          "name": "TEMPSENSE1",
          "fields": [
            {
              "name": "TEMPSENSE",
              "size": 8,
              "title": "Temperature Sensor Calibration Byte n",
              "description": "Refer to 30.3.2.6 Temperature Measurement for how to use the values; 6.9.2 Signature Row Description section for\nlocation of values."
            }
          ],
          "title": "Temperature Sensor Calibration n",
          "description": "These registers contain correction factors for temperature measurements by the ADC. SIGROW.TEMPSENSE0 is a\ncorrection factor for the gain/slope (unsigned), SIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."
        },
        {
          "offset": "0x22",
          "name": "OSC16ERR3V",
          "fields": [
            {
              "name": "OSC16ERR3V",
              "size": 8,
              "title": "OSC16 error at 3V",
              "description": "This registers contain the signed oscillator frequency error value when running at internal 16MHz at 3V, as measured\nduring production."
            }
          ],
          "title": "OSC16 error at 3V",
          "description": null
        },
        {
          "offset": "0x23",
          "name": "OSC16ERR5V",
          "fields": [
            {
              "name": "OSC16ERR5V",
              "size": 8,
              "title": "OSC16 error at 5V",
              "description": "This registers contain the signed oscillator frequency error value when running at internal 16MHz at 5V, as measured\nduring production."
            }
          ],
          "title": "OSC16 error at 5V",
          "description": null
        },
        {
          "offset": "0x24",
          "name": "OSC20ERR3V",
          "fields": [
            {
              "name": "OSC20ERR3V",
              "size": 8,
              "title": "OSC20 error at 3V",
              "description": "This registers contain the signed oscillator frequency error value when running at internal 20MHz at 3V, as measured\nduring production."
            }
          ],
          "title": "OSC20 error at 3V",
          "description": null
        },
        {
          "offset": "0x25",
          "name": "OSC20ERR5V",
          "fields": [
            {
              "name": "OSC20ERR5V",
              "size": 8,
              "title": "OSC20 error at 5V",
              "description": "This registers contain the signed oscillator frequency error value when running at internal 20MHz at 5V, as measured\nduring production."
            }
          ],
          "title": "OSC20 error at 5V",
          "description": null
        }
      ]
    },
    {
      "name": "FUSE",
      "datasheetPage": 30,
      "offsets": [
        {
          "offset": "0x00",
          "name": "WDTCFG",
          "fields": [
            {
              "name": "WINDOW",
              "size": 4,
              "title": "Watchdog Window Timeout Period"
            },
            {
              "name": "PERIOD",
              "size": 4,
              "title": "Watchdog Timeout Period",
              "description": "This value is loaded into the PERIOD bit field of the Watchdog Control A register (WDT.CTRLA) during Reset."
            }
          ],
          "title": "Watchdog Configuration",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "BODCFG",
          "fields": [
            {
              "name": "LVL",
              "size": 3,
              "title": "BOD Level",
              "description": "This value is loaded into the LVL bit field of the BOD Control B register (BOD.CTRLB) during Reset.\nValue Name Description"
            },
            {
              "name": "SAMPFREQ",
              "title": "BOD Sample Frequency"
            },
            {
              "name": "ACTIVE",
              "size": 2,
              "title": "BOD Operation Mode in Active and Idle"
            },
            {
              "name": "SLEEP",
              "size": 2,
              "title": "BOD Operation Mode in Sleep",
              "description": "| This | value is loaded into the SLEEP bit field of the BOD Control A register (BOD.CTRLA) during Reset. |\n| Value | Description |\n| 0x0 | Disabled |\n| 0x1 | Enabled |\n| 0x2 | Sampled |\n| 0x3 | Reserved |"
            }
          ],
          "title": "BOD Configuration",
          "description": "The settings of the BOD will be reloaded from this Fuse after a Power-on Reset. For all other Resets, the BOD\nconfiguration remains unchanged."
        },
        {
          "offset": "0x02",
          "name": "OSCCFG",
          "fields": [
            {
              "name": "OSCLOCK",
              "title": "Oscillator Lock"
            },
            {
              "size": 5
            },
            {
              "name": "FREQSEL",
              "size": 2,
              "title": "Frequency Select",
              "description": "| These | bits selects the operation frequency of the 16/20MHz internal oscillator (OSC20M), and determine the |\n| respective | factory calibration values to be written to CAL20M in CLKCTRL.OSC20MCALIBA and TEMPCAL20M in |\n| CLKCTRL.OSC20MCALIBB. |  |\n| Value | Description |\n| 0x1 | Run at 16MHz with corresponding factory calibration |\n| 0x2 | Run at 20MHz with corresponding factory calibration |\n| Other | Reserved |"
            }
          ],
          "title": "Oscillator Configuration",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "TCD0CFG",
          "fields": [
            {
              "name": "CMPDEN"
            },
            {
              "name": "CMPCEN"
            },
            {
              "name": "CMPBEN"
            },
            {
              "name": "CMPAEN"
            },
            {
              "name": "CMPD"
            },
            {
              "name": "CMPC"
            },
            {
              "name": "CMPB"
            },
            {
              "name": "CMPA"
            }
          ],
          "title": "Timer Counter Type D Configuration",
          "description": "The bit values of this fuse register are written to the corresponding bits in the TCD.FAULTCTRL register of TCD0 at\nstart-up.\nThe CMPEN and CMP settings of the TCD will only be reloaded from the FUSE values after a Power-On Reset. For\nall other resets the corresponding TCD settings of the device will remain unchanged."
        },
        {
          "offset": "0x05",
          "name": "SYSCFG0",
          "fields": [
            {
              "name": "CRCSRC",
              "size": 2,
              "title": "CRC Source",
              "description": "See the CRC description for more information about the functionality.\nValue Name Description"
            },
            {
              "size": 2
            },
            {
              "name": "RSTPINCFG",
              "size": 2,
              "title": "Reset Pin Configuration"
            },
            {},
            {
              "name": "EESAVE",
              "title": "EEPROM Save During Chip Erase",
              "description": "| If | the device is locked, the EEPROM is always erased by a chip erase, regardless of this bit. |\n| Value | Description |\n| 0 | EEPROM erased during chip erase |\n| 1 | EEPROM not erased under chip erase |"
            }
          ],
          "title": "System Configuration 1",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "SYSCFG1",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "SUT",
              "size": 3,
              "title": "Start Up Time Setting",
              "description": "These bits selects the start-up time between power-on and code execution.\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | 0ms |\n| 0x1 | 1ms |\n| 0x2 | 2ms |\n| 0x3 | 4ms |\n| 0x4 | 8ms |\n| 0x5 | 16ms |\n| 0x6 | 32ms |\n| 0x7 | 64ms |"
            }
          ],
          "title": "System Configuration 1",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "APPEND",
          "fields": [
            {
              "name": "APPEND",
              "size": 8,
              "title": "Application Code Section End",
              "description": "These bits set the end of the application code section in blocks of 256 bytes. The end of the application code section\nshould be set as BOOT size + application code size. The remaining Flash will be application data. A value of 0x00\ndefines the Flash from BOOTEND*256 to end of Flash as application code. When both FUSE.APPEND and\nFUSE.BOOTEND are 0x00, the entire Flash is BOOT section."
            }
          ],
          "title": "Application Code End",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "BOOTEND",
          "fields": [
            {
              "name": "BOOTEND",
              "size": 8,
              "title": "Boot Section End",
              "description": "These bits set the end of the boot section in blocks of 256 bytes. A value of 0x00 defines the whole Flash as BOOT\nsection. When both FUSE.APPEND and FUSE.BOOTEND are 0x00, the entire Flash is BOOT section."
            }
          ],
          "title": "Boot End",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "LOCKBIT",
          "fields": [
            {
              "name": "LOCKBIT",
              "size": 8,
              "title": "Lock Bits",
              "description": "When the part is locked, UPDI cannot access the system bus, so it cannot read out anything but CS-space.\n\n| Value | Description |\n| ----- | ----------- |\n| 0xC5 | The device is open |\n| other | The device is locked |"
            }
          ],
          "title": "Lock Bits",
          "description": null
        }
      ]
    },
    {
      "name": "SYSCFG",
      "datasheetPage": 43,
      "offsets": [
        {
          "offset": "0x01",
          "name": "REVID",
          "fields": [
            {
              "name": "REVID",
              "size": 8,
              "title": "Revision ID",
              "description": "These bits contain the device revision. 0x00 = A, 0x01 = B, and so on."
            }
          ],
          "title": "Device Revision ID Register",
          "description": "This register is read only and give the device revision ID."
        }
      ]
    },
    {
      "name": "CPU",
      "datasheetPage": 52,
      "offsets": [
        {
          "offset": "0x04",
          "name": "CCP",
          "fields": [
            {
              "name": "CCP",
              "size": 8,
              "title": "Configuration Change Protection",
              "description": "Writing the correct signature to this bit field allows changing protected I/O registers or executing protected\ninstructions within the next four CPU instructions executed.\nAll interrupts are ignored during these cycles. After these cycles, interrupts will automatically be handled again by the\nCPU, and any pending interrupts will be executed according to their level and priority.\nWhen the protected I/O register signature is written, CCP[0] will read as '1' as long as the CCP feature is enabled.\nWhen the protected self-programming signature is written, CCP[1] will read as '1' as long as the CCP feature is\nenabled.\nCCP[7:2] will always read as zero.\nValue Name Description"
            }
          ],
          "title": "Configuration Change Protection",
          "description": null
        },
        {
          "offset": "0x0D",
          "name": "SP",
          "fields": [
            {
              "name": "SP",
              "size": 8,
              "title": "Stack Pointer low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            },
            {
              "name": "SP",
              "size": 8,
              "title": "Stack Pointer low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            }
          ],
          "title": "Stack Pointer",
          "description": "The CPU.SP holds the Stack Pointer (SP) that points to the top of the Stack. After Reset, the Stack Pointer points to\nthe highest internal SRAM address.\nOnly the number of bits required to address the available data memory including external memory (up to 64KB) is\nimplemented for each device. Unused bits will always read as zero.\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nTo prevent corruption when updating the Stack Pointer from software, a write to CPU.SPL will automatically disable\ninterrupts for the next four instructions or until the next I/O memory write.\nBit 15 14 13 12 11 10 9 8\nSP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset x x x x x x x x"
        },
        {
          "offset": "0x0F",
          "name": "SREG",
          "fields": [
            {
              "name": "I",
              "title": "Global Interrupt Enable"
            },
            {
              "name": "T",
              "title": "Bit Copy Storage"
            },
            {
              "name": "H",
              "title": "Half Carry Flag"
            },
            {
              "name": "S",
              "title": "Sign Bit, S = N \u2295 V"
            },
            {
              "name": "V",
              "title": "Two\u2019s Complement Overflow Flag"
            },
            {
              "name": "N",
              "title": "Negative Flag"
            },
            {
              "name": "Z",
              "title": "Zero Flag"
            },
            {
              "name": "C",
              "title": "Carry Flag",
              "description": "The carry flag (C) indicates a carry in an arithmetic or logic operation."
            }
          ],
          "title": "Status Register",
          "description": "The Status register contains information about the result of the most recently executed arithmetic or logic instruction.\nFor details about the bits in this register and how they are affected by the different instructions, see the Instruction Set\nSummary."
        }
      ]
    },
    {
      "name": "NVMCTRL",
      "datasheetPage": 63,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "CMD",
              "size": 3,
              "title": "Command",
              "description": "Write this bit field to issue a command. The Configuration Change Protection key for self-programming (SPM) has to\nbe written within four instructions before this write.\nValue Name Description"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "BOOTLOCK",
              "title": "Boot Section Lock"
            },
            {
              "name": "APCWP",
              "title": "Application Code Section Write Protection",
              "description": "Writing a '1' to this bit protects the application code section from further writes.\nThis bit can only be written to '1', it is cleared to '0' only by Reset."
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "STATUS",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "WRERROR",
              "title": "Write Error"
            },
            {
              "name": "EEBUSY",
              "title": "EEPROM Busy"
            },
            {
              "name": "FBUSY",
              "title": "Flash Busy",
              "description": "This bit will read '1' when the Flash is busy with a command."
            }
          ],
          "title": "Status",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "EEREADY",
              "title": "EEPROM Ready Interrupt",
              "description": "Writing a '1' to this bit enables the interrupt which indicates that the EEPROM is ready for new write/erase operations.\nThis is a level interrupt that will be triggered only when the EEREADY flag in the INTFLAGS register is set to zero.\nThus, the interrupt should not be enabled before triggering an NVM command, as the EEREADY flag will not be set\nbefore the NVM command issued. The interrupt should be disabled in the interrupt handler."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "EEREADY",
              "title": "EEREADY Interrupt Flag",
              "description": "Interrupt flag for the EEPROM interrupt. This bit is cleared by writing a '1' to it. When this interrupt is enabled, it will\nimmediately request an interrupt, and it will continue to request interrupts continuously - even if no EEPROM writes\nare initiated."
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "DATA",
          "fields": [
            {
              "name": "DATA",
              "size": 8
            },
            {
              "name": "DATA",
              "size": 8
            }
          ],
          "title": "Data",
          "description": "The NVMCTRL.DATAL and NVMCTRL.DATAH register pair represents the 16-bit value, NVMCTRL.DATA. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01. For more details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nDATA[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x08",
          "name": "ADDR",
          "fields": [
            {
              "name": "ADDR",
              "size": 8
            },
            {
              "name": "ADDR",
              "size": 8
            }
          ],
          "title": "Address",
          "description": "The NVMCTRL.ADDRL and NVMCTRL.ADDRH register pair represents the 16-bit value, NVMCTRL.ADDR. The low\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\n+ 0x01. For more details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nADDR[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        }
      ]
    },
    {
      "name": "CLKCTRL",
      "datasheetPage": 78,
      "offsets": [
        {
          "offset": "0x00",
          "name": "MCLKCTRLA",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CLKSEL",
              "size": 2,
              "title": "Clock Select",
              "description": "This bit field selects the source for the Main Clock (CLK_MAIN).\nValue Name Description"
            }
          ],
          "title": "Main Clock Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "MCLKCTRLB",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "PDIV",
              "size": 4,
              "title": "Prescaler Division"
            },
            {
              "name": "PEN",
              "title": "Prescaler Enable",
              "description": "| This | bit must be written '1' to enable the prescaler. When enabled, the division ratio is selected by the PDIV bit field. |\n| When | this bit is written to '0', the Main Clock will pass through undivided (CLK_PER=CLK_MAIN), regardless of the |\n| value | of PDIV. |"
            }
          ],
          "title": "Main Clock Control B",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "MCLKLOCK",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "LOCKEN",
              "title": "Lock Enable",
              "description": "Writing this bit to '1' will lock the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers, and, if applicable,\nthe calibration settings for the current Main Clock source from further software updates. Once locked, the\nCLKCTRL.MCLKLOCK registers cannot be accessed until the next hardware Reset.\nThis provides protection for the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers and calibration\nsettings for the Main Clock source from unintentional modification by software."
            }
          ],
          "title": "Main Clock Lock",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "MCLKSTATUS",
          "fields": [
            {
              "name": "EXTS",
              "title": "External Clock Status"
            },
            {
              "name": "XOSC32KS",
              "title": "XOSC32K Status"
            },
            {
              "name": "OSC32KS",
              "title": "OSCULP32K Status"
            },
            {
              "name": "OSC20MS",
              "title": "OSC20M Status"
            },
            {
              "size": 3
            },
            {
              "name": "SOSC",
              "title": "Main Clock Oscillator Changing",
              "description": "| Value | Description |\n| 0 | The clock source for CLK_MAIN is not undergoing a switch. |\n| 1 | The clock source for CLK_MAIN is undergoing a switch, and will change as soon as the new source is |\n| stable. |  |"
            }
          ],
          "title": "Main Clock Status",
          "description": null
        },
        {
          "offset": "0x10",
          "name": "OSC20MCTRLA",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "RUNSTDBY",
              "title": "Run Standby",
              "description": "This bit force the oscillator on in all modes, even when unused by the system. In standby sleep mode this can be\nused to ensure immediate wake-up and not waiting for oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes 4 oscillator cycles to open the clock gate after a request but the oscillator analog start-up time will be\nremoved when this bit is set."
            }
          ],
          "title": "16/20MHz Oscillator Control A",
          "description": null
        },
        {
          "offset": "0x11",
          "name": "OSC20MCALIBA",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "CAL20M",
              "size": 6,
              "title": "Calibration",
              "description": "These bits change the frequency around the current center frequency of the OSC20M for fine tuning.\nAt Reset factory calibrated values are loaded based on FREQSEL bits in FUSE.OSCCFG."
            }
          ],
          "title": "16/20MHz Oscillator Calibration B",
          "description": null
        },
        {
          "offset": "0x12",
          "name": "OSC20MCALIBB",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "LOCK",
              "title": "Oscillator Calibration Locked by Fuse"
            },
            {
              "name": "TEMPCAL20M",
              "size": 4,
              "title": "Oscillator Temperature Coefficient Calibration",
              "description": "These bits tune the slope of the temperature compensation.\nAt Reset factory calibrated values are loaded based on FREQSEL bits in FUSE.OSCCFG."
            }
          ],
          "title": "16/20MHz Oscillator Calibration B",
          "description": null
        },
        {
          "offset": "0x18",
          "name": "OSC32KCTRLA",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "RUNSTDBY",
              "title": "Run Standby",
              "description": "This bit force the oscillator on in all modes, even when unused by the system. In standby sleep mode this can be\nused to ensure immediate wake-up and not waiting for oscillator start-up time.\nWhen not requested by peripherals, no oscillator output is provided.\nIt takes 4 oscillator cycles to open the clock gate after a request but the oscillator analog start-up time will be\nremoved when this bit is set."
            }
          ],
          "title": "32KHz Oscillator Control A",
          "description": null
        },
        {
          "offset": "0x1C",
          "name": "XOSC32KCTRLA",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "CSUT",
              "size": 2,
              "title": "Crystal Start-Up Time",
              "description": "These bits select the start-up time for the XOSC32K. It is write protected when the oscillator is enabled (ENABLE=1).\nIf SEL=1, the start-up time will not be applied.\nValue Name Description"
            },
            {
              "name": "SEL",
              "title": "Source Select"
            },
            {
              "name": "RUNSTDBY",
              "title": "Run Standby"
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "| When | this bit is written to '1', the configuration of the respective input pins is overridden to TOSC1 and TOSC2. Also, |\n| the | Source Select bit (SEL) and Crystal Start-Up Time (CSUT) become read-only. |\n| This | bit is I/O protected to prevent unintentional enabling of the oscillator. |"
            }
          ],
          "title": "32.768kHz Crystal Oscillator Control A",
          "description": "The SEL and CSUT bits cannot be changed as long as the ENABLE bit is set or the XOSC32K Stable bit\n(XOSC32KS) in CLKCTRL.MCLKSTATUS is high.\nTo change settings in a safe way: write a '0' to the ENABLE bit and wait until XOSC32KS is '0' before re-enabling the\nXOSC32K with new settings."
        }
      ]
    },
    {
      "name": "SLPCTRL",
      "datasheetPage": 92,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "SMODE",
              "size": 2,
              "title": "Sleep Mode",
              "description": "Writing these bits selects the sleep mode entered when the Sleep Enable bit (SEN) is written to '1' and the SLEEP\ninstruction is executed.\nValue Name Description"
            },
            {
              "name": "SEN",
              "title": "Sleep Enable",
              "description": "This bit must be written to '1' before the SLEEP instruction is executed to make the MCU enter the selected sleep\nmode."
            }
          ],
          "title": "Control A",
          "description": null
        }
      ]
    },
    {
      "name": "RSTCTRL",
      "datasheetPage": 97,
      "offsets": [
        {
          "offset": "0x00",
          "name": "RSTFR",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "UPDIRF",
              "title": "UPDI Reset Flag"
            },
            {
              "name": "SWRF",
              "title": "Software Reset Flag"
            },
            {
              "name": "WDRF",
              "title": "Watchdog Reset Flag"
            },
            {
              "name": "EXTRF",
              "title": "External Reset Flag"
            },
            {
              "name": "BORF",
              "title": "Brownout Reset Flag"
            },
            {
              "name": "PORF",
              "title": "Power-On Reset Flag",
              "description": "This bit is set if a Power-on Reset occurs.\nThis flag is only cleared by writing a '1' it.\nAfter a POR, only the POR flag is set and all other flags are cleared. No other flag can be set before a full system\nboot is run after the POR."
            }
          ],
          "title": "Reset Flag Register",
          "description": "All flags are cleared by writing a '1' to them. They are also cleared by a Power-on Reset, with the exception of the\nPower-On Reset Flag (PORF)."
        },
        {
          "offset": "0x01",
          "name": "SWRR",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "SWRE",
              "title": "Software Reset Enable",
              "description": "When this bit is written to '1', a software reset will occur.\nThis bit will always read as '0'."
            }
          ],
          "title": "Software Reset Register",
          "description": null
        }
      ]
    },
    {
      "name": "CPUINT",
      "datasheetPage": 107,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "IVSEL",
              "title": "Interrupt Vector Select"
            },
            {
              "name": "CVT",
              "title": "Compact Vector Table"
            },
            {
              "size": 4
            },
            {
              "name": "LVL0RR",
              "title": "Round-Robin Priority Enable",
              "description": "| This | bit is not protected by the Configuration Change Protection mechanism. |\n| Value | Description |\n| 0 | Priority is fixed for priority level 0 interrupt requests: The lowest interrupt vector address has highest |\n| priority. |  |\n| 1 | Round Robin priority scheme is enabled for priority level 0 interrupt requests. |"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "STATUS",
          "fields": [
            {
              "name": "NMIEX",
              "title": "Non-Maskable Interrupt Executing"
            },
            {
              "size": 5
            },
            {
              "name": "LVL1EX",
              "title": "Level 1 Interrupt Executing"
            },
            {
              "name": "LVL0EX",
              "title": "Level 0 Interrupt Executing",
              "description": "This flag is set when a priority level 0 interrupt is executing, or when the interrupt handler has been interrupted by a\npriority level 1 interrupt or an NMI. The flag is cleared when returning (RETI) from the interrupt handler."
            }
          ],
          "title": "Status",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "LVL0PRI",
          "fields": [
            {
              "name": "LVL0PRI",
              "size": 8,
              "title": "Interrupt Priority Level 0",
              "description": "When Round Robin is enabled (LVL0RR bit in CPUINT.CTRLA is '1'), this bit field stores the vector of the last\nacknowledged priority level 0 (LVL0) interrupt. The stored vector will have the lowest priority next time one or more\nLVL0 interrupts are pending.\nIf Round Robin is disabled (LVL0RR in CPUINT.CTRLA is '0'), the vector address based priority scheme (lowest\naddress has highest priority) is governing the priorities of LVL0 interrupt requests.\nIf a system Reset is asserted, the lowest interrupt vector address will have highest priority within the LVL0."
            }
          ],
          "title": "Interrupt Priority Level 0",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "LVL1VEC",
          "fields": [
            {
              "name": "LVL1VEC",
              "size": 8,
              "title": "Interrupt Vector with Priority Level 1",
              "description": "This bit field contains the address of the single vector with increased priority level 1 (LVL1).\nIf this bit field has the value 0x00, no vector has LVL1. Consequently, the LVL1 interrupt is disabled."
            }
          ],
          "title": "Interrupt Vector with Priority Level 1",
          "description": null
        }
      ]
    },
    {
      "name": "EVSYS",
      "datasheetPage": 117,
      "offsets": [
        {
          "offset": "0x00",
          "name": "ASYNCSTROBE",
          "fields": [
            {
              "name": "ASYNCSTROBE",
              "size": 8,
              "title": "Asynchronous Channel Strobe",
              "description": "If the strobe register location is written, each Event channel will be inverted for one system clock cycle, i.e. a single\nEvent is generated."
            }
          ],
          "title": "Asynchronous Channel Strobe",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "SYNCSTROBE",
          "fields": [
            {
              "name": "SYNCSTROBE",
              "size": 8,
              "title": "Synchronous Channel Strobe",
              "description": "If the strobe register location is written, each Event channel will be inverted for one system clock cycle, i.e. a single\nevent is generated."
            }
          ],
          "title": "Synchronous Channel Strobe",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "ASYNCCH0",
          "fields": [
            {
              "name": "ASYNCCH",
              "size": 8,
              "title": "Asynchronous Channel Generator Selection",
              "description": "Table 14-2.\u2000Asynchronous Channel Generator selection\nValue ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"
            }
          ],
          "title": "Asynchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "ASYNCCH1",
          "fields": [
            {
              "name": "ASYNCCH",
              "size": 8,
              "title": "Asynchronous Channel Generator Selection",
              "description": "Table 14-2.\u2000Asynchronous Channel Generator selection\nValue ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"
            }
          ],
          "title": "Asynchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "ASYNCCH2",
          "fields": [
            {
              "name": "ASYNCCH",
              "size": 8,
              "title": "Asynchronous Channel Generator Selection",
              "description": "Table 14-2.\u2000Asynchronous Channel Generator selection\nValue ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"
            }
          ],
          "title": "Asynchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "ASYNCCH3",
          "fields": [
            {
              "name": "ASYNCCH",
              "size": 8,
              "title": "Asynchronous Channel Generator Selection",
              "description": "Table 14-2.\u2000Asynchronous Channel Generator selection\nValue ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"
            }
          ],
          "title": "Asynchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "SYNCCH0",
          "fields": [
            {
              "name": "SYNCCH",
              "size": 8,
              "title": "Synchronous Channel Generator Selection",
              "description": "Table 14-3.\u2000Synchronous Channel Generator selection\nValue SYNCCH0 SYNCCH1"
            }
          ],
          "title": "Synchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "SYNCCH1",
          "fields": [
            {
              "name": "SYNCCH",
              "size": 8,
              "title": "Synchronous Channel Generator Selection",
              "description": "Table 14-3.\u2000Synchronous Channel Generator selection\nValue SYNCCH0 SYNCCH1"
            }
          ],
          "title": "Synchronous Channel n Generator Selection",
          "description": null
        },
        {
          "offset": "0x12",
          "name": "ASYNCUSER0",
          "fields": [
            {
              "name": "ASYNCUSER",
              "size": 8,
              "title": "Asynchronous User Channel Selection",
              "description": "Table 14-4.\u2000User Multiplexer Numbers\nUSERn User Multiplexer Description\nn=0 TCB0 Timer/Counter B 0\nn=1 ADC0 ADC 0\nn=2 CCL_LUT0EV0 CCL LUT0 Event 0\nn=3 CCL_LUT1EV0 CCL LUT1 Event 0\nn=4 CCL_LUT0EV1 CCL LUT0 Event 1\nn=5 CCL_LUT1EV1 CCL LUT1 Event 1\nn=6 TCD0_EV0 Timer Counter D 0 Event 0\nn=7 TCD0_EV1 Timer Counter D 0 Event 1\nn=8 EVOUT0 Event OUT 0\nn=9 EVOUT1 Event OUT 1\nn=10 EVOUT2 Event OUT 2\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | OFF |\n| 0x1 | SYNCCH0 |\n| 0x2 | SYNCCH1 |\n| 0x3 | ASYNCCH0 |\n| 0x4 | ASYNCCH1 |\n| 0x5 | ASYNCCH2 |\n| 0x6 | ASYNCCH3 |"
            }
          ],
          "title": "Asynchronous User Channel n Input Selection",
          "description": null
        },
        {
          "offset": "0x22",
          "name": "SYNCUSER0",
          "fields": [
            {
              "name": "SYNCUSER",
              "size": 8,
              "title": "Synchronous User Channel Selection",
              "description": "Table 14-5.\u2000User Multiplexer Numbers\nUSERn User Multiplexer Description\nn=0 TCA0 Timer/Counter A\nn=1 USART0 USART\nValue Name"
            }
          ],
          "title": "Synchronous User Channel n Input Selection",
          "description": null
        },
        {
          "offset": "0x23",
          "name": "SYNCUSER1",
          "fields": [
            {
              "name": "SYNCUSER",
              "size": 8,
              "title": "Synchronous User Channel Selection",
              "description": "Table 14-5.\u2000User Multiplexer Numbers\nUSERn User Multiplexer Description\nn=0 TCA0 Timer/Counter A\nn=1 USART0 USART\nValue Name"
            }
          ],
          "title": "Synchronous User Channel n Input Selection",
          "description": null
        }
      ]
    },
    {
      "name": "PORTMUX",
      "datasheetPage": 125,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "EVOUT1",
              "title": "Event Output 1"
            },
            {
              "name": "EVOUT0",
              "title": "Event Output 0",
              "description": "Write this bit to '1' to enable event output 0."
            }
          ],
          "title": "Control C",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "TWI0",
              "title": "TWI 0 communication"
            },
            {},
            {
              "name": "SPI0",
              "title": "SPI 0 communication"
            },
            {},
            {
              "name": "USART0",
              "title": "USART 0 communication",
              "description": "Write this bit to '1' to select alternative communication pins for USART 0."
            }
          ],
          "title": "Control C",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLC",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "TCA00",
              "title": "TCA0 Waveform output 0",
              "description": "Write this bit to '1' to select alternative output pin for TCA0 waveform output 0.\nIn Split Mode, this bit controls output from low-byte compare channel 0."
            }
          ],
          "title": "Control C",
          "description": null
        }
      ]
    },
    {
      "name": "PORT",
      "datasheetPage": 135,
      "offsets": [
        {
          "offset": "0x00",
          "name": "DIR",
          "fields": [
            {
              "name": "DIR",
              "size": 8,
              "title": "Data Direction",
              "description": "This bit field selects the data direction for the individual pins n of the Port.\nWriting a '1' to PORT.DIR[n] configures and enables pin n as output pin.\nWriting a '0' to PORT.DIR[n] configures pin n as input pin. It can be configured by writing to the ISC bit in\nPORT.PINnCTRL."
            }
          ],
          "title": "Data Direction",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "DIRSET",
          "fields": [
            {
              "name": "DIRSET",
              "size": 8,
              "title": "Data Direction Set",
              "description": "This bit field can be used instead of a read-modify-write to set individual pins as output.\nWriting a '1' to DIRSET[n] will set the corresponding PORT.DIR[n] bit.\nReading this bit field will always return the value of PORT.DIR."
            }
          ],
          "title": "Data Direction Set",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "DIRCLR",
          "fields": [
            {
              "name": "DIRCLR",
              "size": 8,
              "title": "Data Direction Clear",
              "description": "This register can be used instead of a read-modify-write to configure individual pins as input.\nWriting a '1' to DIRCLR[n] will clear the corresponding bit in PORT.DIR.\nReading this bit field will always return the value of PORT.DIR."
            }
          ],
          "title": "Data Direction Clear",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "DIRTGL",
          "fields": [
            {
              "name": "DIRTGL",
              "size": 8,
              "title": "Data Direction Toggle",
              "description": "This bit field can be used instead of a read-modify-write to toggle the direction of individual pins.\nWriting a '1' to DIRTGL[n] will toggle the corresponding bit in PORT.DIR.\nReading this bit field will always return the value of PORT.DIR."
            }
          ],
          "title": "Data Direction Toggle",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "OUT",
          "fields": [
            {
              "name": "OUT",
              "size": 8,
              "title": "Output Value",
              "description": "This bit field defines the data output value for the individual pins n of the port.\nIf OUT[n] is written to '1', pin n is driven high.\nIf OUT[n] is written to '0', pin n is driven low.\nIn order to have any effect, the pin direction must be configured as output."
            }
          ],
          "title": "Output Value",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "OUTSET",
          "fields": [
            {
              "name": "OUTSET",
              "size": 8,
              "title": "Output Value Set",
              "description": "This bit field can be used instead of a read-modify-write to set the output value of individual pins to '1'.\nWriting a '1' to OUTSET[n] will set the corresponding bit in PORT.OUT.\nReading this bit field will always return the value of PORT.OUT."
            }
          ],
          "title": "Output Value Set",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "OUTCLR",
          "fields": [
            {
              "name": "OUTCLR",
              "size": 8,
              "title": "Output Value Clear",
              "description": "This register can be used instead of a read-modify-write to clear the output value of individual pins to '0'.\nWriting a '1' to OUTCLR[n] will clear the corresponding bit in PORT.OUT.\nReading this bit field will always return the value of PORT.OUT."
            }
          ],
          "title": "Output Value Clear",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "OUTTGL",
          "fields": [
            {
              "name": "OUTTGL",
              "size": 8,
              "title": "Output Value Toggle",
              "description": "This register can be used instead of a read-modify-write to toggle the output value of individual pins.\nWriting a '1' to OUTTGL[n] will toggle the corresponding bit in PORT.OUT.\nReading this bit field will always return the value of PORT.OUT."
            }
          ],
          "title": "Output Value Toggle",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "IN",
          "fields": [
            {
              "name": "IN",
              "size": 8,
              "title": "Input Value",
              "description": "This register shows the value present on the pins if the digital input driver is enabled. IN[n] shows the value of pin n of\nthe Port. The input is not sampled and cannot be read if the digital input buffers are disabled.\nWriting to a bit of PORT.IN will toggle the corresponding bit in PORT.OUT."
            }
          ],
          "title": "Input Value",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "INTFLAGS",
          "fields": [
            {
              "name": "INT",
              "size": 8,
              "title": "Interrupt Pin Flag",
              "description": "The INT Flag is set when a pin change/state matches the pin's input sense configuration.\nWriting a '1' to a flag's bit location will clear the flag.\nFor enabling and executing the interrupt, refer to ISC bit description in PORT.PINnCTRL."
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x10",
          "name": "PIN0CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x11",
          "name": "PIN1CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x12",
          "name": "PIN2CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x13",
          "name": "PIN3CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x14",
          "name": "PIN4CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x15",
          "name": "PIN5CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x16",
          "name": "PIN6CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        },
        {
          "offset": "0x17",
          "name": "PIN7CTRL",
          "fields": [
            {
              "name": "INVEN",
              "title": "Inverted I/O Enable"
            },
            {
              "size": 3
            },
            {
              "name": "PULLUPEN",
              "title": "Pullup Enable"
            },
            {
              "name": "ISC",
              "size": 3,
              "title": "Input/Sense Configuration",
              "description": "| These | bits configure the input and sense configuration of pin n. The sense configuration determines how a port |\n| interrupt | can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. |\n| Value | Name Description |\n| 0x0 | INTDISABLE Interrupt disabled but input buffer enabled |\n| 0x1 | BOTHEDGES Sense both edges |\n| 0x2 | RISING Sense rising edge |\n| 0x3 | FALLING Sense falling edge |\n| 0x4 | INPUT_DISABLE Digital input buffer disabled |\n| 0x5 | LEVEL Sense low level |\n| other | - Reserved |"
            }
          ],
          "title": "Pin n Control",
          "description": null
        }
      ]
    },
    {
      "name": "VPORT",
      "datasheetPage": 147,
      "offsets": [
        {
          "offset": "0x00",
          "name": "DIR",
          "fields": [
            {
              "name": "DIR",
              "size": 8,
              "title": "Data Direction",
              "description": "This bit field selects the data direction for the individual pins in the Port."
            }
          ],
          "title": "Data Direction",
          "description": "Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\nwhere the regular Port registers reside."
        },
        {
          "offset": "0x01",
          "name": "OUT",
          "fields": [
            {
              "name": "OUT",
              "size": 8,
              "title": "Output Value",
              "description": "This bit field selects the data output value for the individual pins in the Port."
            }
          ],
          "title": "Output Value",
          "description": "Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\nwhere the regular Port registers reside."
        },
        {
          "offset": "0x02",
          "name": "IN",
          "fields": [
            {
              "name": "IN",
              "size": 8,
              "title": "Input Value",
              "description": "This bit field holds the value present on the pins if the digital input buffer is enabled.\nWriting to a bit of VPORT.IN will toggle the corresponding bit in VPORT.OUT."
            }
          ],
          "title": "Input Value",
          "description": "Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\nwhere the regular Port registers reside."
        },
        {
          "offset": "0x03",
          "name": "INTFLAGS",
          "fields": [
            {
              "name": "INT",
              "size": 8,
              "title": "Interrupt Pin Flag",
              "description": "The INT flag is set when a pin change/state matches the pin's input sense configuration, and the pin is configured as\nsource for port interrupt.\nWriting a '1' to this flag's bit location will clear the flag.\nFor enabling and executing the interrupt, refer to PORT_PINnCTRL.ISC."
            }
          ],
          "title": "Interrupt Flag",
          "description": "Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\nwhere the regular Port registers reside.w"
        }
      ]
    },
    {
      "name": "BOD",
      "datasheetPage": 156,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "SAMPFREQ",
              "title": "Sample Frequency"
            },
            {
              "name": "ACTIVE",
              "size": 2,
              "title": "Active"
            },
            {
              "name": "SLEEP",
              "size": 2,
              "title": "Sleep",
              "description": "| These | bits select the BOD operation mode when the device is in standby or power-down sleep mode. |\n| These | bits are under Configuration Change Protection (CCP). |\n| The | Reset value is loaded from the SLEEP bits in FUSE.BODCFG. |\n| Value | Description |\n| 0x0 | Disabled |\n| 0x1 | Enabled |\n| 0x2 | Sampled |\n| 0x3 | Reserved |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "LVL",
              "size": 3,
              "title": "BOD Level",
              "description": "These bits select the BOD threshold level.\nThe Reset value is loaded from the BOD Level bits (LVL) in the BOD Configuration Fuse (FUSE.BODCFG).\nValue Name Description"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "VLMCTRLA",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "VLMLVL",
              "size": 2,
              "title": "VLM Level",
              "description": "These bit select the Voltage Level Monitor threshold relative to the BOD threshold (LVL in BOD.CTRLB).\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | VLM threshold 5% above BOD threshold |\n| 0x1 | VLM threshold 15% above BOD threshold |\n| 0x2 | VLM threshold 25% above BOD threshold |\n| other | Reserved |"
            }
          ],
          "title": "VLM Control A",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "VLMCFG",
              "size": 2,
              "title": "VLM Configuration"
            },
            {
              "name": "VLMIE",
              "title": "VLM Interrupt Enable",
              "description": "| Writing | a '1' to this bit enables the Voltage Level Monitor (VLM) interrupt. |"
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "VLMIF",
              "title": "VLM Interrupt Flag",
              "description": "This flag is set when a trigger from the VLM is given, as configured by the VLMCFG bit in the BOD.INTCTRL register.\nThe flag is only updated when the BOD is enabled."
            }
          ],
          "title": "VLM Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "STATUS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "VLMS",
              "title": "VLM Status",
              "description": "This bit is only valid when the bod is enabled.\n\n| Value | Description |\n| ----- | ----------- |\n| 0 | The voltage is above the VLM threshold level |\n| 1 | The voltage is below the VLM threshold level |"
            }
          ],
          "title": "VLM Status",
          "description": null
        }
      ]
    },
    {
      "name": "VREF",
      "datasheetPage": 164,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "ADC0REFSEL",
              "size": 3,
              "title": "ADC0 Reference Select"
            },
            {},
            {
              "name": "DAC0REFSEL",
              "size": 3,
              "title": "DAC0 and AC0 Reference Select",
              "description": "| These | bits select reference voltage for the DAC0 and AC0. |\n| Value | Description |\n| 0x0 | 0.55V |\n| 0x1 | 1.1V |\n| 0x2 | 2.5V |\n| 0x3 | 4.3V |\n| 0x4 | 1.5V |\n| other | Reserved |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "ADC0REFEN",
              "title": "ADC0 Reference Force Enable"
            },
            {
              "name": "DAC0REFEN",
              "title": "DAC0 and AC0 Reference Force Enable",
              "description": "Writing a '1' to this bit forces the voltage reference for the DAC0 and AC0 to be running, even if it not requested.\nWriting a '0' to this bit allows to automatic enable/disable of the reference source by the peripheral."
            }
          ],
          "title": "Control B",
          "description": null
        }
      ]
    },
    {
      "name": "WDT",
      "datasheetPage": 172,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "WINDOW",
              "size": 4,
              "title": "Window",
              "description": "Writing a non-zero value to these bits enables the window mode, and selects the according duration of the closed\nperiod.\nThe bits are optionally lock protected:\n\u2022 If LOCK bit in WDT.STATUS is '1', all bits are change protected (Access = R)\n\u2022 If LOCK bit in WDT.STATUS is '0', all bits can be changed (Access = R/W)\nValue Name Description"
            },
            {
              "name": "PERIOD",
              "size": 4,
              "title": "Period",
              "description": "Writing a non-zero value to this bit enables the WDT, and selects the according timeout period in normal mode. In\nwindow mode, these bits select the duration of the open window.\nThe bits are optionally lock protected:\n\u2022 If LOCK in WDT.STATUS is '1', all bits are change protected (Access = R)\n\u2022 If LOCK in WDT.STATUS is '0', all bits can be changed (Access = R/W)\nValue Name Description"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "STATUS",
          "fields": [
            {
              "name": "LOCK",
              "title": "Lock"
            },
            {
              "size": 6
            },
            {
              "name": "SYNCBUSY",
              "title": "Synchronization Busy",
              "description": "This bit is set after writing to the WDT.CTRLA register while the data is being synchronized from the system clock\ndomain to the WDT clock domain.\nThis bit is cleared by system after the synchronization is finished.\nThis bit is not under Configuration Change Protection (CCP)."
            }
          ],
          "title": "Status",
          "description": null
        }
      ]
    },
    {
      "name": "TCA",
      "datasheetPage": 188,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CLKSEL",
              "size": 3,
              "title": "Clock Select",
              "description": "These bits select the clock frequency for the timer/counter.\nValue Name Description"
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is disabled |\n| 1 | The peripheral is enabled |"
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "CMPnEN2"
            },
            {
              "name": "CMPnEN1"
            },
            {
              "name": "CMPnEN0"
            },
            {
              "name": "ALUPD",
              "title": "Auto Lock Update"
            },
            {
              "name": "WGMODE",
              "size": 3,
              "title": "Waveform Generation Mode",
              "description": "| These | bits select the waveform generation mode, and control the counting sequence of the counter, TOP value, |\n| UPDATE | condition, interrupt condition, and type of waveform that is generated. |\n| No | waveform generation is performed in the normal mode of operation. For all other modes, the result from the |\n| waveform | generator will only be directed to the PORT pins if the corresponding CMPnEN bit has been set to enable |\n| this. | The port pin direction must be set as output. |\n| Table | 20-5.\u2000Timer Waveform Generation Mode |\n| WGMODE[2:0] | Group Configuration Mode of Operation Top Update OVF |\n| 000 | NORMAL Normal PER TOP TOP |\n| 001 | FRQ Frequency CMP0 TOP TOP |\n| 010 | - Reserved - - - |\n| 011 | SINGLESLOPE Single-slope PWM PER BOTTOM BOTTOM |\n| 100 | - Reserved - - - |\n| 101 | DSTOP Dual-slope PWM PER BOTTOM TOP |\n| 110 | DSBOTH Dual-slope PWM PER BOTTOM TOP and BOTTOM |\n| 111 | DSBOTTOM Dual-slope PWM PER BOTTOM BOTTOM |\n| Value | Name Description |\n| 0x0 | NORMAL Normal operation mode |\n| 0x1 | FRQ Frequency mode |\n| 0x3 | SINGLESLOPE Single-slope PWM mode |"
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLC",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "CMP2OV",
              "title": "Compare Output Value 2"
            },
            {
              "name": "CMP1OV",
              "title": "Compare Output Value 1"
            },
            {
              "name": "CMP0OV",
              "title": "Compare Output Value 0",
              "description": "The CMPnOV bits allow direct access to the waveform generator's output compare value when the timer/counter is\nnot enabled. This is used to set or clear the WG output value when the timer/counter is not running."
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "CTRLD",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "SPLITM",
              "title": "Enable Split Mode",
              "description": "This bit sets the timer/counter in split mode operation. It will then work as two 8-bit timer/counters. The register map\nwill change compared to normal 16-bit mode."
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "CTRLECLR",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are\nalways read as zero.\nValue Name Description"
            },
            {
              "name": "LUPD",
              "title": "Lock Update"
            },
            {
              "name": "DIR",
              "title": "Counter Direction",
              "description": "| Normally | this bit is controlled in hardware by the waveform generation mode or by event actions, but this bit can also |\n| be | changed from software. |\n| Value | Description |\n| 0 | The counter is counting up (incrementing). |\n| 1 | The counter is counting down (decrementing). |"
            }
          ],
          "title": "Control Register E Clear - Normal Mode",
          "description": "The individual status bit can be cleared by writing a one to its bit location. This allows each bit to be cleared without\nuse of a read-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."
        },
        {
          "offset": "0x05",
          "name": "CTRLESET",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are\nalways read as zero.\nValue Name Description"
            },
            {
              "name": "LUPD",
              "title": "Lock Update"
            },
            {
              "name": "DIR",
              "title": "Counter Direction",
              "description": "| Normally | this bit is controlled in hardware by the waveform generation mode or by event actions, but this bit can also |\n| be | changed from software. |\n| Value | Description |\n| 0 | The counter is counting up (incrementing). |\n| 1 | The counter is counting down (decrementing). |"
            }
          ],
          "title": "Control Register E Set - Normal Mode",
          "description": "The individual status bit can be set by writing a '1' to its bit location. This allows each bit to be set without use of a\nread-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."
        },
        {
          "offset": "0x06",
          "name": "CTRLFCLR",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CMP2BV",
              "title": "Compare 2 Buffer Valid"
            },
            {
              "name": "CMP1BV",
              "title": "Compare 1 Buffer Valid"
            },
            {
              "name": "CMP0BV",
              "title": "Compare 0 Buffer Valid"
            },
            {
              "name": "PERBV",
              "title": "Period Buffer Valid",
              "description": "This bit is set when a new value is written to the PERB register. This bit is automatically cleared on an UPDATE\ncondition."
            }
          ],
          "title": "Control Register F Clear",
          "description": "The individual status bit can be cleared by writing a one to its bit location. This allows each bit to be cleared without\nuse of a read-modify-write operation on a single register."
        },
        {
          "offset": "0x07",
          "name": "CTRLFSET",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CMP2BV",
              "title": "Compare 2 Buffer Valid"
            },
            {
              "name": "CMP1BV",
              "title": "Compare 1 Buffer Valid"
            },
            {
              "name": "CMP0BV",
              "title": "Compare 0 Buffer Valid"
            },
            {
              "name": "PERBV",
              "title": "Period Buffer Valid",
              "description": "This bit is set when a new value is written to the PERB register. This bit is automatically cleared on an UPDATE\ncondition."
            }
          ],
          "title": "Control Register F Set",
          "description": "The individual status bit can be set by writing a one to its bit location. This allows each bit to be set without use of a\nread-modify-write operation on a single register."
        },
        {
          "offset": "0x09",
          "name": "EVCTRL",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "EVACT",
              "size": 2,
              "title": "Event Action",
              "description": "These bits define on what type of event action the counter will increment or decrement.\nValue Name Description"
            },
            {
              "name": "CNTEI",
              "title": "Enable Count on Event Input",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | Counting on Event input is disabled. |\n| 1 | Counting on Event input is enabled according to EVACT bit field. |"
            }
          ],
          "title": "Event Control",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "CMP2",
              "title": "Compare Channel 2 Interrupt Enable"
            },
            {
              "name": "CMP1",
              "title": "Compare Channel 1 Interrupt Enable"
            },
            {
              "name": "CMP0",
              "title": "Compare Channel 0 Interrupt Enable"
            },
            {
              "size": 3
            },
            {
              "name": "OVF",
              "title": "Timer Overflow/Underflow Interrupt Enable",
              "description": "Writing OVF bit to '1' enables overflow interrupt."
            }
          ],
          "title": "Interrupt Control Register - Normal Mode",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "CMP2",
              "title": "Compare Channel 2 Interrupt Flag"
            },
            {
              "name": "CMP1",
              "title": "Compare Channel 1 Interrupt Flag"
            },
            {
              "name": "CMP0",
              "title": "Compare Channel 0 Interrupt Flag"
            },
            {
              "size": 3
            },
            {
              "name": "OVF",
              "title": "Overflow/Underflow Interrupt Flag",
              "description": "This flag is set either on a TOP (overflow) or BOTTOM (underflow) condition, depending on the WGMODE setting.\nOVF is not automatically cleared and needs to be cleared by software. This is done by writing a one to its bit location."
            }
          ],
          "title": "Interrupt Flag Register - Normal Mode",
          "description": "The individual status bit can be cleared by writing a '1'e to its bit location. This allows each bit to be set without use of\na read-modify-write operation on a single register."
        },
        {
          "offset": "0x0E",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Run in Debug",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control Register",
          "description": null
        },
        {
          "offset": "0x0F",
          "name": "TEMP",
          "fields": [
            {
              "name": "TEMP",
              "size": 8,
              "title": "Temporary Bits for 16-bit Access"
            }
          ],
          "title": "Temporary bits for 16-bit Access",
          "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\nTemporary register for all the 16-bit registers of this peripheral."
        },
        {
          "offset": "0x20",
          "name": "CNT",
          "fields": [
            {
              "name": "CNT",
              "size": 8,
              "title": "Counter low byte",
              "description": "These bits hold the LSB of the 16-bit counter register."
            },
            {
              "name": "CNT",
              "size": 8,
              "title": "Counter low byte",
              "description": "These bits hold the LSB of the 16-bit counter register."
            }
          ],
          "title": "Counter Register - Normal Mode",
          "description": "The TCA.CNTL and TCA.CNTH register pair represents the 16-bit value, TCA.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nCPU and UPDI write access has priority over internal updates of the register.\nBit 15 14 13 12 11 10 9 8\nCNT[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x26",
          "name": "PER",
          "fields": [
            {
              "name": "PER",
              "size": 8,
              "title": "Periodic low byte",
              "description": "These bits hold the LSB of the 16-bit period register."
            },
            {
              "name": "PER",
              "size": 8,
              "title": "Periodic low byte",
              "description": "These bits hold the LSB of the 16-bit period register."
            }
          ],
          "title": "Period Register - Normal Mode",
          "description": "TCA.PER contains the 16-bit TOP value in the timer/counter.\nThe TCA.PERL and TCA.PERH register pair represents the 16-bit value, TCA.PER. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nPER[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 1 1 1 1 1 1 1 1"
        },
        {
          "offset": "0x28",
          "name": "CMP0",
          "fields": [
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            },
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            }
          ],
          "title": "Compare n Register - Normal Mode",
          "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\nused for generating waveforms.\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\nUPDATE condition occurs.\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x2A",
          "name": "CMP1",
          "fields": [
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            },
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            }
          ],
          "title": "Compare n Register - Normal Mode",
          "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\nused for generating waveforms.\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\nUPDATE condition occurs.\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x2C",
          "name": "CMP2",
          "fields": [
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            },
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            }
          ],
          "title": "Compare n Register - Normal Mode",
          "description": "This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\nused for generating waveforms.\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\nUPDATE condition occurs.\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x36",
          "name": "PERBUF",
          "fields": [
            {
              "name": "PERBUF",
              "size": 8,
              "title": "Period Buffer low byte",
              "description": "These bits hold the LSB of the 16-bit period buffer register."
            },
            {
              "name": "PERBUF",
              "size": 8,
              "title": "Period Buffer low byte",
              "description": "These bits hold the LSB of the 16-bit period buffer register."
            }
          ],
          "title": "Period Buffer Register",
          "description": "This register serves as the buffer for the period register (TCA.PER). Accessing this register using the CPU or UPDI\nwill affect the PERBV flag.\nThe TCA.PERBUFL and TCA.PERBUFH register pair represents the 16-bit value, TCA.PERBUF. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more\ndetails on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nPERBUF[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 1 1 1 1 1 1 1 1"
        },
        {
          "offset": "0x38",
          "name": "CMP0BUF",
          "fields": [
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            },
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            }
          ],
          "title": "Compare n Buffer Register",
          "description": "This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMPBUF[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x3A",
          "name": "CMP1BUF",
          "fields": [
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            },
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            }
          ],
          "title": "Compare n Buffer Register",
          "description": "This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMPBUF[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x3C",
          "name": "CMP2BUF",
          "fields": [
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            },
            {
              "name": "CMPBUF",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare buffer register."
            }
          ],
          "title": "Compare n Buffer Register",
          "description": "This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMPBUF[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        }
      ]
    },
    {
      "name": "TCA-SPLIT",
      "datasheetPage": 208,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CLKSEL",
              "size": 3,
              "title": "Clock Select",
              "description": "These bits select the clock frequency for the timer/counter.\nValue Name Description"
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is disabled |\n| 1 | The peripheral is enabled |"
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "HCMP2EN",
              "title": "High-byte Compare 2 Enable"
            },
            {
              "name": "HCMP1EN",
              "title": "High-byte Compare 1 Enable"
            },
            {
              "name": "HCMP0EN",
              "title": "High-byte Compare 0 Enable"
            },
            {
              "name": "LCMP2EN",
              "title": "Low-byte Compare 2 Enable"
            },
            {
              "name": "LCMP1EN",
              "title": "Low-byte Compare 1 Enable"
            },
            {
              "name": "LCMP0EN",
              "title": "Low-byte Compare 0 Enable",
              "description": "Setting the LCMPnEN/HCMPnEN bits in the FRQ or PWM waveform generation mode of operation will override the\nport output register for the corresponding WOn pin."
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLC",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "HCMP2OV",
              "title": "High-byte Compare 2 Output Value"
            },
            {
              "name": "HCMP1OV",
              "title": "High-byte Compare 1 Output Value"
            },
            {
              "name": "HCMP0OV",
              "title": "High-byte Compare 0 Output Value"
            },
            {
              "name": "LCMP2OV",
              "title": "Low-byte Compare 2 Output Value"
            },
            {
              "name": "LCMP1OV",
              "title": "Low-byte Compare 1 Output Value"
            },
            {
              "name": "LCMP0OV",
              "title": "Low-byte Compare 0 Output Value",
              "description": "The LCMPnOV/HCMPn bits allow direct access to the waveform generator's output compare value when the timer/\ncounter is not enabled. This is used to set or clear the WOn output value when the timer/counter is not running."
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "CTRLD",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "SPLITM",
              "title": "Enable Split Mode",
              "description": "This bit sets the timer/counter in split mode operation. It will then work as two 8-bit timer/counters. The register map\nwill change compared to normal 16-bit mode."
            }
          ],
          "title": "Control D",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "CTRLECLR",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are\nalways read as zero.\nValue Name Description"
            }
          ],
          "title": "Control Register E Clear - Split Mode",
          "description": "The individual status bit can be cleared by writing a '1' to its bit location. This allows each bit to be cleared without\nuse of a read-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."
        },
        {
          "offset": "0x05",
          "name": "CTRLESET",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are\nalways read as zero.\nValue Name Description"
            }
          ],
          "title": "Control Register E Set - Split Mode",
          "description": "The individual status bit can be set by writing a '1' to its bit location. This allows each bit to be set without use of a\nread-modify-write operation on a single register.\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."
        },
        {
          "offset": "0x0A",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "LCMP2",
              "title": "Low-byte Compare Channel 0 Interrupt Enable"
            },
            {
              "name": "LCMP1",
              "title": "Low-byte Compare Channel 1 Interrupt Enable"
            },
            {
              "name": "LCMP0",
              "title": "Low-byte Compare Channel 0 Interrupt Enable"
            },
            {
              "size": 2
            },
            {
              "name": "HUNF",
              "title": "High-byte Underflow Interrupt Enable"
            },
            {
              "name": "LUNF",
              "title": "Low-byte Underflow Interrupt Enable",
              "description": "Writing HUNF bit to '1' enables low-byte underflow interrupt."
            }
          ],
          "title": "Interrupt Control Register - Split Mode",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "LCMP2",
              "title": "Low-byte Compare Channel 0 Interrupt Flag"
            },
            {
              "name": "LCMP1",
              "title": "Low-byte Compare Channel 0 Interrupt Flag"
            },
            {
              "name": "LCMP0",
              "title": "Low-byte Compare Channel 0 Interrupt Flag"
            },
            {
              "size": 2
            },
            {
              "name": "HUNF",
              "title": "High-byte Underflow Interrupt Flag"
            },
            {
              "name": "LUNF",
              "title": "Low-byte Underflow Interrupt Flag",
              "description": "This flag is set on a low-byte timer BOTTOM (underflow) condition. LUNF is not automatically cleared and needs to\nbe cleared by software. This is done by writing a \u20181\u2019 to its bit location."
            }
          ],
          "title": "Interrupt Flag Register - Split Mode",
          "description": "The individual status bit can be cleared by writing a \u20181\u2019 to its bit location. This allows each bit to be set without use of\na read-modify-write operation on a single register."
        },
        {
          "offset": "0x0E",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Run in Debug",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control Register",
          "description": null
        },
        {
          "offset": "0x20",
          "name": "LCNT",
          "fields": [
            {
              "name": "LCNT",
              "size": 8,
              "title": "Counter value for low-byte timer",
              "description": "These bits define the counter value of the low-byte timer."
            }
          ],
          "title": "Low-byte Timer Counter Register - Split Mode",
          "description": "TCA.LCNT contains the counter value in low-byte timer. CPU and UPDI write access has priority over count, clear, or\nreload of the counter."
        },
        {
          "offset": "0x21",
          "name": "HCNT",
          "fields": [
            {
              "name": "HCNT",
              "size": 8,
              "title": "Counter value for high-byte timer",
              "description": "These bits define the counter value in high-byte timer."
            }
          ],
          "title": "High-byte Timer Counter Register - Split Mode",
          "description": "TCA.HCNT contains the counter value in high-byte timer. CPU and UPDI write access has priority over count, clear,\nor reload of the counter."
        },
        {
          "offset": "0x26",
          "name": "LPER",
          "fields": [
            {
              "name": "LPER",
              "size": 8,
              "title": "Period value low-byte timer",
              "description": "These bits hold the TOP value of low-byte timer."
            }
          ],
          "title": "Low-byte Timer Period Register - Split Mode",
          "description": "The TCA.LPER register contains the TOP value of low-byte timer."
        },
        {
          "offset": "0x27",
          "name": "HPER",
          "fields": [
            {
              "name": "HPER",
              "size": 8,
              "title": "Period value high-byte timer",
              "description": "These bits hold the TOP value of high-byte timer."
            }
          ],
          "title": "High-byte Period Register - Split Mode",
          "description": "The TCA.HPER register contains the TOP value of high-byte timer."
        },
        {
          "offset": "0x28",
          "name": "LCMP0",
          "fields": [
            {
              "name": "LCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to LCNT."
            }
          ],
          "title": "Compare Register n for low-byte Timer - Split Mode",
          "description": "The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\nthen used for generating waveforms."
        },
        {
          "offset": "0x29",
          "name": "HCMP0",
          "fields": [
            {
              "name": "HCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to HCNT."
            }
          ],
          "title": "High-byte Compare Register n - Split Mode",
          "description": "The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\nare then used for generating waveforms."
        },
        {
          "offset": "0x2A",
          "name": "LCMP1",
          "fields": [
            {
              "name": "LCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to LCNT."
            }
          ],
          "title": "Compare Register n for low-byte Timer - Split Mode",
          "description": "The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\nthen used for generating waveforms."
        },
        {
          "offset": "0x2B",
          "name": "HCMP1",
          "fields": [
            {
              "name": "HCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to HCNT."
            }
          ],
          "title": "High-byte Compare Register n - Split Mode",
          "description": "The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\nare then used for generating waveforms."
        },
        {
          "offset": "0x2C",
          "name": "LCMP2",
          "fields": [
            {
              "name": "LCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to LCNT."
            }
          ],
          "title": "Compare Register n for low-byte Timer - Split Mode",
          "description": "The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\nthen used for generating waveforms."
        },
        {
          "offset": "0x2D",
          "name": "HCMP2",
          "fields": [
            {
              "name": "HCMP",
              "size": 8,
              "title": "Compare value of channel n",
              "description": "These bits hold the compare value of channel n that is compared to HCNT."
            }
          ],
          "title": "High-byte Compare Register n - Split Mode",
          "description": "The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\nare then used for generating waveforms."
        }
      ]
    },
    {
      "name": "TCB",
      "datasheetPage": 234,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "RUNSTDBY",
              "title": "Run Standby",
              "description": "Writing a '1' to this bit will enable the peripheral to run in Standby sleep mode. Not applicable when CLKSEL is set to"
            },
            {},
            {
              "name": "SYNCUPD",
              "title": "Synchronize Update"
            },
            {},
            {
              "name": "CLKSEL",
              "size": 2,
              "title": "Clock Select"
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "| Writing | this bit to '1' enables the Timer/Counter type B peripheral. |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "ASYNC",
              "title": "Asynchronous Enable"
            },
            {
              "name": "CCMPINIT",
              "title": "Compare/Capture Pin Initial Value"
            },
            {
              "name": "CCMPEN",
              "title": "Compare/Capture Output Enable"
            },
            {},
            {
              "name": "CNTMODE",
              "size": 3,
              "title": "Timer Mode",
              "description": "| Writing | these bits selects the timer mode. |\n| Value | Description |\n| 0x0 | Periodic interrupt mode |\n| 0x1 | Timeout check mode |\n| 0x2 | Input capture on event mode |\n| 0x3 | Input capture frequency measurement mode |\n| 0x4 | Input capture pulse width measurement mode |\n| 0x5 | Input capture frequency and pulse width measurement mode |\n| 0x6 | Single shot mode |\n| 0x7 | 8-bit PWM mode |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "EVCTRL",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "FILTER",
              "title": "Input Capture Noise Cancellation Filter"
            },
            {},
            {
              "name": "EDGE",
              "title": "Event Edge",
              "description": "This bit is used to select the Event edge. The effect of this bit is dependent on the selected Count Mode (CNTMODE)\nin TCB.CTRLB.\nCount Mode EDGE Positive Edge Negative Edge\nPeriodic Interrupt Mode 0 Not Applicable Not Applicable"
            },
            {
              "size": 3
            },
            {
              "name": "CAPTEI",
              "title": "Capture Event Input Enable",
              "description": "Writing this bit to '1' enables the event input capture."
            }
          ],
          "title": "Event Control",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "CAPT",
              "title": "Capture Interrupt Enable",
              "description": "Writing this bit to '1' enables the Capture interrupt."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "CAPT",
              "title": "Interrupt Flag",
              "description": "This bit is set when an interrupt occurs. The interrupt conditions are dependent on the Counter mode (CNTMODE) in\nTCB.CTRLB.\nThis bit is cleared by writing a '1' to it or when the Capture register is read in capture mode.\nCounter Mode Interrupt Set Condition\nPeriodic Interrupt Mode Set when the counter reaches TOP\nTimeout Check Mode Set when the counter reaches TOP\nInput Capture on Event Mode Set when an event occurs and the capture register is loaded, Flag clears\nwhen capture is read\nInput Capture Frequency Measurement\nMode\nSet on edge when the capture register is loaded and count initialized,\nFlag clears when capture is read\nInput Capture Pulse Width\nMeasurement Mode\nSet on a edge when the capture register is loaded, previous edge\ninitialized the count, Flag clears when capture is read\nInput Capture Frequency and Pulse\nWidth Measurement Mode\nSet on second (positive or negative) edge when the counter is stopped,\nFlag clears when capture is read\nSingle Shot Mode Set when counter reaches TOP"
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "STATUS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "RUN",
              "title": "Run",
              "description": "When the counter is running, this bit is set to '1'. When the counter is stopped, this bit is cleared '0'.\nThe bit it is read only and cannot be set by UPDI."
            }
          ],
          "title": "Status",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "TEMP",
          "fields": [
            {
              "name": "TEMP",
              "size": 8,
              "title": "Temporary Value"
            }
          ],
          "title": "Temporary Value",
          "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\nTemporary register for all the 16-bit registers of this peripheral."
        },
        {
          "offset": "0x0A",
          "name": "CNT",
          "fields": [
            {
              "name": "CNT",
              "size": 8,
              "title": "Count Value low",
              "description": "These bits hold the LSB of the 16-bit counter register."
            },
            {
              "name": "CNT",
              "size": 8,
              "title": "Count Value low",
              "description": "These bits hold the LSB of the 16-bit counter register."
            }
          ],
          "title": "Count",
          "description": "The TCB.CNTL and TCB.CNTH register pair represents the 16-bit value TCB.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nCPU and UPDI write access has priority over internal updates of the register.\nBit 15 14 13 12 11 10 9 8\nCNT[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x0C",
          "name": "CCMP",
          "fields": [
            {
              "name": "CCMP",
              "size": 8,
              "title": "Capture/Compare Value low byte",
              "description": "These bits hold the LSB of the 16-bit compare, capture and top value"
            },
            {
              "name": "CCMP",
              "size": 8,
              "title": "Capture/Compare Value low byte",
              "description": "These bits hold the LSB of the 16-bit compare, capture and top value"
            }
          ],
          "title": "Capture/Compare",
          "description": "The TCB.CCMPL and TCB.CCMPH register pair represents the 16-bit value TCB.CCMP. The low byte [7:0] (suffix L)\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nThis register has different functions depending on the mode of operation:\n\u2022 For capture operation, these registers contain the captured value of the counter at the time the capture occurs\n\u2022 In periodic interrupt/timeout and single shot mode this register acts as the TOP value.\n\u2022 In 8-bit PWM mode, TCB.CCMPL and TCB.CCMPH act as two independent registers.\nBit 15 14 13 12 11 10 9 8\nCCMP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        }
      ]
    },
    {
      "name": "TCD",
      "datasheetPage": 269,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "CLKSEL",
              "size": 2,
              "title": "Clock Select"
            },
            {
              "name": "CNTPRES",
              "size": 2,
              "title": "Counter Prescaler"
            },
            {
              "name": "SYNCPRES",
              "size": 2,
              "title": "Synchronization Prescaler"
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "| When | this bit is written to, it will automatically be synchronized to the TCD clock domain. |\n| This | bit can be changed as long as synchronization of this bit is not ongoing, see Enable Ready bit (ENRDY) in |\n| Status | register (STATUS). |\n| This | bit is not enable-protected. |\n| Value | Description |\n| 0 | The TCD is disabled. |\n| 1 | The TCD is enabled and running. |"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "WGMODE",
              "size": 2,
              "title": "Waveform Generation Mode",
              "description": "These bits select the waveform generation\nValue Name Description"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLC",
          "fields": [
            {
              "name": "CMPDSEL",
              "title": "Compare D Output Select",
              "description": "Value Name Description"
            },
            {
              "name": "CMPCSEL",
              "title": "Compare C Output Select",
              "description": "Value Name Description"
            },
            {
              "size": 2
            },
            {
              "name": "FIFTY",
              "title": "Fifty Percent Waveform"
            },
            {},
            {
              "name": "AUPDATE",
              "title": "Automatically Update"
            },
            {
              "name": "CMPOVR",
              "title": "Compare Output Value Override",
              "description": "When this bit is written, default values of the Waveform Outputs A and B are overridden by the values written in the\nCompare x Value in active state bit fields in the Control D register (CTRLD.CMPnxVAL). See the Control D register\ndescription for more details."
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "CTRLD",
          "fields": [
            {
              "name": "CMPBVAL",
              "size": 4
            },
            {
              "name": "CMPAVAL",
              "size": 4
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "CTRLE",
          "fields": [
            {
              "name": "DISEOC",
              "title": "Disable at End of TCD Cycle Strobe"
            },
            {
              "size": 2
            },
            {
              "name": "SCAPTUREB",
              "title": "Software Capture B Strobe"
            },
            {
              "name": "SCAPTUREA",
              "title": "Software Capture A Strobe"
            },
            {
              "name": "RESTART",
              "title": "Restart Strobe"
            },
            {
              "name": "SYNC",
              "title": "Synchronize Strobe"
            },
            {
              "name": "SYNCEOC",
              "title": "Synchronize End of TCD Cycle Strobe",
              "description": "When this bit is written to '1' the doubled buffered registers will be loaded to the TCD domain at the end of the next\nTCD cycle.\nWriting to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in\nTCD.STATUS."
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "EVCTRLA",
          "fields": [
            {
              "name": "CFG",
              "size": 2,
              "title": "Event Configuration",
              "description": "When the Input Capture Noise canceler is activated (FILTERON), the Event input is filtered. The filter function\nrequires four successive equal valued samples of the Retrigger pin for changing its output. The Input Capture is\ntherefore delayed by four clock cycles when the noise canceler is enabled.\nWhen the Asynchronous Event is enabled (ASYNCON), the Event input will qualify the output directly.\nValue Name Description"
            },
            {},
            {
              "name": "EDGE",
              "title": "Edge Selection",
              "description": "This bit is used to select the active edge or level for the event input.\nValue Name Description"
            },
            {},
            {
              "name": "ACTION",
              "title": "Event Action",
              "description": "This bit enables Capture on Event input. By default, the input will trigger a Fault, depending on the Input x register\ninput mode (TCD.INPUTx). It is also possible to trigger a Capture on the Event input.\nValue Name Description"
            },
            {},
            {
              "name": "TRIGEI",
              "title": "Trigger Event Input Enable",
              "description": "Writing this bit to '1' enables Event as trigger for input A."
            }
          ],
          "title": "Event Control x",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "EVCTRLB",
          "fields": [
            {
              "name": "CFG",
              "size": 2,
              "title": "Event Configuration",
              "description": "When the Input Capture Noise canceler is activated (FILTERON), the Event input is filtered. The filter function\nrequires four successive equal valued samples of the Retrigger pin for changing its output. The Input Capture is\ntherefore delayed by four clock cycles when the noise canceler is enabled.\nWhen the Asynchronous Event is enabled (ASYNCON), the Event input will qualify the output directly.\nValue Name Description"
            },
            {},
            {
              "name": "EDGE",
              "title": "Edge Selection",
              "description": "This bit is used to select the active edge or level for the event input.\nValue Name Description"
            },
            {},
            {
              "name": "ACTION",
              "title": "Event Action",
              "description": "This bit enables Capture on Event input. By default, the input will trigger a Fault, depending on the Input x register\ninput mode (TCD.INPUTx). It is also possible to trigger a Capture on the Event input.\nValue Name Description"
            },
            {},
            {
              "name": "TRIGEI",
              "title": "Trigger Event Input Enable",
              "description": "Writing this bit to '1' enables Event as trigger for input A."
            }
          ],
          "title": "Event Control x",
          "description": null
        },
        {
          "offset": "0x0C",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "TRIGB"
            },
            {
              "name": "TRIGA"
            },
            {},
            {
              "name": "OVF",
              "title": "Counter Overflow",
              "description": "Writing this bit to '1' enables executing an interrupt at Restart of the sequence or Overflow of the counter."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x0D",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "TRIGB"
            },
            {
              "name": "TRIGA"
            },
            {},
            {
              "name": "OVF",
              "title": "Overflow Interrupt Flag",
              "description": "When a capture is overflow, this flag is raised. This bit is cleared by writing a '1' to it."
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x0E",
          "name": "STATUS",
          "fields": [
            {
              "name": "PWMACTB"
            },
            {
              "name": "PWMACTA"
            },
            {
              "size": 4
            },
            {
              "name": "CMDRDY",
              "title": "Command Ready",
              "description": "This status bit tells when a command is synced to the TCD domain and the system is ready to receive new\ncommands.\nThe following clears the CMDRDY bit:"
            },
            {
              "name": "ENRDY",
              "title": "Enable Ready",
              "description": "This status bit tells when the ENABLE value in TCD.CTRLA is synced to the TCD domain, and is ready to be written\nto again.\nThe following clears the ENRDY bit:"
            }
          ],
          "title": "Status",
          "description": null
        },
        {
          "offset": "0x10",
          "name": "INPUTCTRLA",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "INPUTMODE",
              "size": 4,
              "title": "Input Mode",
              "description": "Value Name Description"
            }
          ],
          "title": "Input Control x",
          "description": null
        },
        {
          "offset": "0x11",
          "name": "INPUTCTRLB",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "INPUTMODE",
              "size": 4,
              "title": "Input Mode",
              "description": "Value Name Description"
            }
          ],
          "title": "Input Control x",
          "description": null
        },
        {
          "offset": "0x12",
          "name": "FAULTCTRL",
          "fields": [
            {
              "name": "CMPDEN"
            },
            {
              "name": "CMPCEN"
            },
            {
              "name": "CMPBEN"
            },
            {
              "name": "CMPAEN"
            },
            {
              "name": "CMPD"
            },
            {
              "name": "CMPC"
            },
            {
              "name": "CMPB"
            },
            {
              "name": "CMPA"
            }
          ],
          "title": "Fault Control",
          "description": null
        },
        {
          "offset": "0x14",
          "name": "DLYCTRL",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "DLYPRESC",
              "size": 2,
              "title": "Delay Prescaler"
            },
            {
              "name": "DLYTRIG",
              "size": 2,
              "title": "Delay Trigger"
            },
            {
              "name": "DLYSEL",
              "size": 2,
              "title": "Delay Select",
              "description": "| These | bits control what function should be used by the delay trigger the blanking or output event delay. |\n| Value | Description |\n| 0x0 | Delay functionality not used |\n| 0x1 | Input blanking enabled |\n| 0x2 | Event delay enabled |\n| 0x3 | Reserved |"
            }
          ],
          "title": "Delay Control",
          "description": null
        },
        {
          "offset": "0x15",
          "name": "DLYVAL",
          "fields": [
            {
              "name": "DLYVAL",
              "size": 8,
              "title": "Delay Value",
              "description": "These bits configure the blanking/ output event delay time or event output synchronization delay in number of\nprescaled TCD cycles."
            }
          ],
          "title": "Delay Value",
          "description": null
        },
        {
          "offset": "0x18",
          "name": "DITCTRL",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "DITHERSEL",
              "size": 2,
              "title": "Dither Select",
              "description": "These bits select which Compare register is using the dither function. See also 22.3.2.5 Dithering.\nValue Name Description"
            }
          ],
          "title": "Dither Control",
          "description": null
        },
        {
          "offset": "0x19",
          "name": "DITVAL",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "DITHER",
              "size": 4,
              "title": "Dither Value",
              "description": "These bits configure the fractional adjustment of the on-time or off-time according to Dither Selection bits\n(DITHERSEL) in the Dither Control register (TCD.DITCTRL). The DITHER value is added to a 4-bit accumulator at\nthe end of each TCD cycle. When the accumulator overflows the frequency adjustment will occur.\nThe DITHER bits are doubled buffered so the new value is copied in at an update condition."
            }
          ],
          "title": "Dither Value",
          "description": null
        },
        {
          "offset": "0x1E",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "FAULTDET",
              "title": "Fault Detection",
              "description": "This bit defines how the peripheral behaves when stopped in Debug mode.\nValue Name Description"
            },
            {},
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "When written to '1', the peripheral will continue operating in debug mode when the CPU is halted.\n\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control",
          "description": null
        },
        {
          "offset": "0x22",
          "name": "CAPTUREA",
          "fields": [
            {
              "name": "CAPTURE",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CAPTURE",
              "size": 4
            }
          ],
          "title": "Capture x",
          "description": "For capture operation, these registers constitute the second buffer level and access point for the CPU. The\nTCD.CAPTUREx registers are updated with the buffer value when an UPDATE condition occurs. CAPTURE A\nregister contains the value from the TCD counter when a Trigger A or a software capture A occurs. CAPTURE B\nregister contain the value from the TCD counter when Trigger B or software capture B occurs.\nThe TCD counter value is synchronized to CAPTUREx by either software or an event.\nThe capture register is blocked for update of new capture data until TCDn.CAPTURExH is read.\nBit 15 14 13 12 11 10 9 8\nCAPTURE[11:8]\nAccess R R R R\nReset 0 0 0 0"
        },
        {
          "offset": "0x24",
          "name": "CAPTUREB",
          "fields": [
            {
              "name": "CAPTURE",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CAPTURE",
              "size": 4
            }
          ],
          "title": "Capture x",
          "description": "For capture operation, these registers constitute the second buffer level and access point for the CPU. The\nTCD.CAPTUREx registers are updated with the buffer value when an UPDATE condition occurs. CAPTURE A\nregister contains the value from the TCD counter when a Trigger A or a software capture A occurs. CAPTURE B\nregister contain the value from the TCD counter when Trigger B or software capture B occurs.\nThe TCD counter value is synchronized to CAPTUREx by either software or an event.\nThe capture register is blocked for update of new capture data until TCDn.CAPTURExH is read.\nBit 15 14 13 12 11 10 9 8\nCAPTURE[11:8]\nAccess R R R R\nReset 0 0 0 0"
        },
        {
          "offset": "0x28",
          "name": "CMPASET",
          "fields": [
            {
              "name": "CMPSET",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CMPSET",
              "size": 4
            }
          ],
          "title": "Compare Set x",
          "description": "For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\nthe comparators are then used for generating waveforms.\nBit 15 14 13 12 11 10 9 8\nCMPSET[11:8]\nAccess R/W R/W R/W R/W\nReset 0 0 0 0"
        },
        {
          "offset": "0x2A",
          "name": "CMPACLR",
          "fields": [
            {
              "name": "CMPCLR",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CMPCLR",
              "size": 4
            }
          ],
          "title": "Compare Clear x",
          "description": "For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\nthe comparators are then used for generating waveforms.\nBit 15 14 13 12 11 10 9 8\nCMPCLR[11:8]\nAccess R/W R/W R/W R/W\nReset 0 0 0 0"
        },
        {
          "offset": "0x2C",
          "name": "CMPBSET",
          "fields": [
            {
              "name": "CMPSET",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CMPSET",
              "size": 4
            }
          ],
          "title": "Compare Set x",
          "description": "For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\nthe comparators are then used for generating waveforms.\nBit 15 14 13 12 11 10 9 8\nCMPSET[11:8]\nAccess R/W R/W R/W R/W\nReset 0 0 0 0"
        },
        {
          "offset": "0x2E",
          "name": "CMPBCLR",
          "fields": [
            {
              "name": "CMPCLR",
              "size": 8
            },
            {
              "size": 4
            },
            {
              "name": "CMPCLR",
              "size": 4
            }
          ],
          "title": "Compare Clear x",
          "description": "For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\nthe comparators are then used for generating waveforms.\nBit 15 14 13 12 11 10 9 8\nCMPCLR[11:8]\nAccess R/W R/W R/W R/W\nReset 0 0 0 0"
        }
      ]
    },
    {
      "name": "RTC",
      "datasheetPage": 295,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RUNSTDBY",
              "title": "Run in Standby"
            },
            {
              "name": "PRESCALER",
              "size": 4,
              "title": "Prescaler"
            },
            {
              "size": 2
            },
            {
              "name": "RTCEN",
              "title": "RTC Enable",
              "description": "| Value | Description |\n| 0 | RTC disabled |\n| 1 | RTC enabled |"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "STATUS",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "CMPBUSY",
              "title": "Compare Synchronization Busy"
            },
            {
              "name": "PERBUSY",
              "title": "Period Synchronization Busy"
            },
            {
              "name": "CNTBUSY",
              "title": "Counter Synchronization Busy"
            },
            {
              "name": "CTRLABUSY",
              "title": "Control A Synchronization Busy",
              "description": "This bit is indicating whether the RTC is busy synchronizing the Control A register (RTC.CTRLA) in RTC clock\ndomain."
            }
          ],
          "title": "Status",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CMP",
              "title": "Compare Match Interrupt Enable"
            },
            {
              "name": "OVF",
              "title": "Overflow Interrupt Enable",
              "description": "Enable interrupt on counter overflow, i.e. when the Counter value (RTC.CNT) matched the Period value (RTC.PER)\nand wraps around to zero."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CMP",
              "title": "Compare Match Interrupt Flag"
            },
            {
              "name": "OVF",
              "title": "Overflow Interrupt Flag",
              "description": "This flag is set when the Counter value (RTC.CNT) has reached the Period value (RTC.PER) and wrapped to zero.\nWriting a '1' to this bit clears the flag."
            }
          ],
          "title": "Interrupt Flag",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "TEMP",
          "fields": [
            {
              "name": "TEMP",
              "size": 8,
              "title": "Temporary"
            }
          ],
          "title": "Temporary",
          "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\nTemporary register for all the 16-bit registers of this peripheral."
        },
        {
          "offset": "0x05",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "CLKSEL",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "CLKSEL",
              "size": 2,
              "title": "Clock Select",
              "description": "Writing these bits selects the source for the RTC clock (CLK_RTC).\nWhen configuring the RTC to use either XOSC32K or the external clock on TOSC1, XOSC32K needs to be enabled\nand the Source Select bit (SEL) and Run Standby bit (RUNSTDBY) in the XOSC32K Control A register of the Clock\nController (CLKCTRL.XOSC32KCTRLA) must be configured accordingly.\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | 32KHz from OSCULP32K |\n| 0x1 | 1KHz from OSCULP32K |\n| 0x2 | 32.768kHz from XOSC32K |\n| 0x3 | External clock from TOSC1 pin |"
            }
          ],
          "title": "Clock Selection",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "CNT",
          "fields": [
            {
              "name": "CNT",
              "size": 8,
              "title": "Counter low byte",
              "description": "These bits hold the LSB of the 16-bit counter register."
            },
            {
              "name": "CNT",
              "size": 8,
              "title": "Counter low byte",
              "description": "These bits hold the LSB of the 16-bit counter register."
            }
          ],
          "title": "Count",
          "description": "The RTC.CNTL and RTC.CNTH register pair represents the 16-bit value, RTC.CNT. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC clock cycles\nfrom updating the register until this has an effect. Application software needs to check that the STATUS.CNTBUSY\nflag is cleared before writing to this register.\nBit 15 14 13 12 11 10 9 8\nCNT[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x0A",
          "name": "PER",
          "fields": [
            {
              "name": "PER",
              "size": 8,
              "title": "Period low byte",
              "description": "These bits hold the LSB of the 16-bit period register."
            },
            {
              "name": "PER",
              "size": 8,
              "title": "Period low byte",
              "description": "These bits hold the LSB of the 16-bit period register."
            }
          ],
          "title": "Period",
          "description": "The RTC.PERL and RTC.PERH register pair represents the 16-bit value, RTC.PER. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC clock cycles\nfrom updating the register until this has an effect. Application software needs to check that the STATUS.PERBUSY\nflag is cleared before writing to this register.\nBit 15 14 13 12 11 10 9 8\nPER[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 1 1 1 1 1 1 1 1"
        },
        {
          "offset": "0x0C",
          "name": "CMP",
          "fields": [
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            },
            {
              "name": "CMP",
              "size": 8,
              "title": "Compare low byte",
              "description": "These bits hold the LSB of the 16-bit compare register."
            }
          ],
          "title": "Compare",
          "description": "The RTC.CMPL and RTC.CMPH register pair represents the 16-bit value, RTC.CMP. The low byte [7:0] (suffix L) is\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nCMP[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x10",
          "name": "PITCTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "PERIOD",
              "size": 4,
              "title": "Period",
              "description": "Writing this bit field selects the number of RTC clock cycles between each interrupt.\nValue Name Description"
            },
            {
              "size": 2
            },
            {
              "name": "PITEN",
              "title": "Periodic Interrupt Timer Enable",
              "description": "Writing a '1' to this bit enables the Periodic Interrupt Timer."
            }
          ],
          "title": "Periodic Interrupt Timer Control A",
          "description": null
        },
        {
          "offset": "0x11",
          "name": "PITSTATUS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "CTRLBUSY",
              "title": "PITCTRLA Synchronization Busy",
              "description": "This bit indicates whether the RTC is busy synchronizing the Periodic Interrupt Timer Control A register\n(RTC.PITCTRLA) in the RTC clock domain."
            }
          ],
          "title": "Periodic Interrupt Timer Status",
          "description": null
        },
        {
          "offset": "0x12",
          "name": "PITINTCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "PI",
              "title": "Periodic interrupt",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The periodic interrupt is disabled |\n| 1 | The periodic interrupt is enabled |"
            }
          ],
          "title": "PIT Interrupt Control",
          "description": null
        },
        {
          "offset": "0x13",
          "name": "PITINTFLAGS",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "PI",
              "title": "Periodic interrupt Flag",
              "description": "This flag is set when a periodic interrupt is issued.\nWriting a '1' clears the flag."
            }
          ],
          "title": "PIT Interrupt Flag",
          "description": null
        },
        {
          "offset": "0x15",
          "name": "PITDBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "Writing this bit to '1' will enable the PIT to run in Debug mode while the CPU is halted.\n\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Periodic Interrupt Timer Debug Control",
          "description": null
        }
      ]
    },
    {
      "name": "USART",
      "datasheetPage": 327,
      "offsets": [
        {
          "offset": "0x00",
          "name": "RXDATAL",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "Receiver Data Register",
              "description": "When USART receiver is set to LINAUTO mode, this bit indicates if the received data is within the response space of\na LIN frame. If the received data is the Protected identifier field, this bit will be read as zero. Otherwise the bit will be\nread as one. For receiver mode other than LINAUTO mode, DATA[8] holds the ninth data bit in the received character\nwhen operating with serial frames with nine data bits."
            }
          ],
          "title": "Receiver Data Register High Byte",
          "description": "Reading the RXDATAH Register location will return the contents of the ninth DATA bit plus status bits.\nThe receive buffer consists of a two level FIFO. The FIFO and the corresponding flags in the high byte of\nUSART.RXDATAH will change state whenever the receive buffer is accessed (read). If CHSIZE in USART.CTRLC is\nset to 9BIT Low byte first, read USART.RXDATAL before USART.RXDATAH, otherwise always read\nUSART.RXDATAH before USART.RXDATAL in order to get the correct flags."
        },
        {
          "offset": "0x01",
          "name": "RXDATAH",
          "fields": [
            {
              "name": "RXCIF",
              "title": "USART Receive Complete Interrupt Flag"
            },
            {
              "name": "BUFOVF",
              "title": "Buffer Overflow"
            },
            {
              "size": 3
            },
            {
              "name": "FERR",
              "title": "Frame Error"
            },
            {
              "name": "PERR",
              "title": "Parity Error"
            },
            {
              "name": "DATA[8]"
            }
          ],
          "title": "Receiver Data Register High Byte",
          "description": "Reading the RXDATAH Register location will return the contents of the ninth DATA bit plus status bits.\nThe receive buffer consists of a two level FIFO. The FIFO and the corresponding flags in the high byte of\nUSART.RXDATAH will change state whenever the receive buffer is accessed (read). If CHSIZE in USART.CTRLC is\nset to 9BIT Low byte first, read USART.RXDATAL before USART.RXDATAH, otherwise always read\nUSART.RXDATAH before USART.RXDATAL in order to get the correct flags."
        },
        {
          "offset": "0x02",
          "name": "TXDATAL",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "Transmit Data Register",
              "description": "This bit is used when CHSIZE=9BIT in USART.CTRLC."
            }
          ],
          "title": "Transmit Data Register High Byte",
          "description": "USART.TXDATAH holds the ninth data bit in the character to be transmitted when operating with serial frames with\nnine data bits. When used this bit must be written before writing to USART.TXDATAL except if CHSIZE in\nUSART.CTRLC is set to 9BIT Low byte first where USART.TXDATAL should be written first.\nThis bit is unused in Master SPI mode of operation."
        },
        {
          "offset": "0x03",
          "name": "TXDATAH",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DATA[8]"
            }
          ],
          "title": "Transmit Data Register High Byte",
          "description": "USART.TXDATAH holds the ninth data bit in the character to be transmitted when operating with serial frames with\nnine data bits. When used this bit must be written before writing to USART.TXDATAL except if CHSIZE in\nUSART.CTRLC is set to 9BIT Low byte first where USART.TXDATAL should be written first.\nThis bit is unused in Master SPI mode of operation."
        },
        {
          "offset": "0x04",
          "name": "STATUS",
          "fields": [
            {
              "name": "RXCIF",
              "title": "USART Receive Complete Interrupt Flag"
            },
            {
              "name": "TXCIF",
              "title": "USART Transmit Complete Interrupt Flag"
            },
            {
              "name": "DREIF",
              "title": "USART Data Register Empty Flag"
            },
            {
              "name": "RXSIF",
              "title": "USART Receive Start Interrupt Flag"
            },
            {
              "name": "ISFIF",
              "title": "Inconsistent Sync Field Interrupt Flag"
            },
            {},
            {
              "name": "BDF",
              "title": "Break Detected Flag"
            },
            {
              "name": "WFB",
              "title": "Wait For Break",
              "description": "Writing this bit to '1' will register the next low and high transition on RxD line as a break character. This can be used\nto wait for a BREAK character of arbitrary width. Combined with USART set to GENAUTO mode, this allow the user"
            }
          ],
          "title": "USART Status Register",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RXCIE",
              "title": "Receive Complete Interrupt Enable"
            },
            {
              "name": "TXCIE",
              "title": "Transmit Complete Interrupt Enable"
            },
            {
              "name": "DREIE",
              "title": "Data Register Empty Interrupt Enable"
            },
            {
              "name": "RXSIE",
              "title": "Receiver Start Frame Interrupt Enable"
            },
            {
              "name": "LBME",
              "title": "Loop-back Mode Enable"
            },
            {
              "name": "ABEIE",
              "title": "Auto-baud Error Interrupt Enable"
            },
            {
              "name": "RS485",
              "size": 2,
              "title": "RS485 Mode",
              "description": "These bits enable the RS485 and select the operation mode.\nValue Name Description"
            }
          ],
          "title": "Control C - Master SPI Mode",
          "description": "This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\nCMODE values, see Control C - Async Mode the correct description.\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."
        },
        {
          "offset": "0x06",
          "name": "CTRLB",
          "fields": [
            {
              "name": "RXEN",
              "title": "Receiver Enable"
            },
            {
              "name": "TXEN",
              "title": "Transmitter Enable"
            },
            {},
            {
              "name": "SFDEN",
              "title": "Start Frame Detection Enable"
            },
            {
              "name": "ODME",
              "title": "Open Drain Mode Enable"
            },
            {
              "name": "RXMODE",
              "size": 2,
              "title": "Receiver Mode",
              "description": "In CLK2X mode, the divisor of the baud rate divider will be reduced from 16 to 8 effectively doubling the transfer rate\nfor asynchronous communication modes. For synchronous operation, the CLK2X mode has no effect and RXMODE\nshould always be written to '0'. RXMODE must be '0' when the USART Communication mode is configured to\nIRCOM. Setting RXMODE to GENAUTO enables generic auto-baud where the SYNC character is valid when eight\nlow and high bits have been registered. In this mode, any SYNC character that gives a valid BAUD rate will be\naccepted. In LINAUTO mode the SYNC character is constrained and found valid if every two bits falls within 16 \u00b13\nbaud samples of the internal baud rate and match data value 0x55. The GENAUTO and LINAUTO mode is only\nsupported for USART operated in Asynchronous Slave mode.\nValue Name Description"
            },
            {
              "name": "MPCM",
              "title": "Multi-Processor Communication Mode",
              "description": "Writing a \u20181\u2019 to this bit enables the Multi-Processor Communication mode: the USART receiver ignores all the\nincoming frames that do not contain address information. The transmitter is unaffected by the MPCM setting. For\nmore detailed information see 24.3.2.10 Multiprocessor Communication Mode."
            }
          ],
          "title": "Control C - Master SPI Mode",
          "description": "This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\nCMODE values, see Control C - Async Mode the correct description.\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."
        },
        {
          "offset": "0x07",
          "name": "CTRLC",
          "fields": [
            {
              "name": "CMODE",
              "size": 2,
              "title": "USART Communication Mode",
              "description": "Writing these bits selects the communication mode of the USART.\nWriting a value different than 0x3 to these bits alters the available bit fields in this register, see Control C - Async\nMode.\nValue Name Description"
            },
            {
              "name": "PMODE",
              "size": 2,
              "title": "Parity Mode",
              "description": "Writing these bits enables and selects the type of parity generation.\nWhen enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each\nframe. The Receiver will generate a parity value for the incoming data, compare it to the PMODE setting, and set the\nParity Error flag (PERR) in the Status register (USART.STATUS) if a mismatch is detected.\nValue Name Description"
            },
            {
              "name": "SBMODE",
              "title": "Stop Bit Mode"
            },
            {
              "name": "CHSIZE",
              "size": 3,
              "title": "Character Size",
              "description": "| Writing | these bits select the number of data bits in a frame. The Receiver and Transmitter use the same setting. For |\n| 9BIT | character size, the order of which byte to read or write first, low or high byte of RXDATA or TXDATA is |\n| selectable. |  |\n| Value | Name Description |\n| 0x0 | 5BIT 5-bit |\n| 0x1 | 6BIT 6-bit |\n| 0x2 | 7BIT 7-bit |\n| 0x3 | 8BIT 8-bit |\n| 0x4 | - Reserved |\n| 0x5 | - Reserved |\n| 0x6 | 9BIT 9-bit (Low byte first) |\n| 0x7 | 9BIT 9-bit (High byte first) |"
            }
          ],
          "title": "Control C - Master SPI Mode",
          "description": "This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\nCMODE values, see Control C - Async Mode the correct description.\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."
        },
        {
          "offset": "0x07",
          "name": "CTRLC",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "CMODE",
              "size": 2,
              "title": "USART Communication Mode",
              "description": "Writing these bits selects the communication mode of the USART.\nWriting a value different than 0x3 to these bits alters the available bit fields in this register, see Control C - Async\nMode.\nValue Name Description"
            },
            {
              "size": 3
            },
            {
              "name": "UDORD",
              "title": "Data Order"
            },
            {
              "name": "UCPHA",
              "title": "Clock Phase",
              "description": "| The | UCPHA bit setting determine if data is sampled on the leading (first) edge or tailing (last) edge of XCKn. Refer to |\n| the | 24.3.2.1.5 Master SPI Mode Clock Generation for details. |"
            }
          ],
          "title": "Control C - Master SPI Mode",
          "description": "This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\nCMODE values, see Control C - Async Mode the correct description.\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."
        },
        {
          "offset": "0x08",
          "name": "BAUD",
          "fields": [
            {
              "name": "BAUD",
              "size": 8,
              "title": "USART Baud Rate low byte",
              "description": "These bits hold the LSB of the 16-bit Baud register."
            },
            {
              "name": "BAUD",
              "size": 8,
              "title": "USART Baud Rate low byte",
              "description": "These bits hold the LSB of the 16-bit Baud register."
            }
          ],
          "title": "Baud Register",
          "description": "The USART.BAUDL and USART.BAUDH register pair represents the 16-bit value, USART.BAUD. The low byte [7:0]\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more\ndetails on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nOngoing transmissions of the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing this\nregister will trigger an immediate update of the baud rate prescaler. For more information of how to set the baud rate,\nsee Table 24-2\nBit 15 14 13 12 11 10 9 8\nBAUD[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x0B",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control Register",
          "description": null
        },
        {
          "offset": "0x0C",
          "name": "EVCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "IREI",
              "title": "IrDA Event Input Enable",
              "description": "This bit enables the event source for the IRCOM Receiver. If event input is selected for the IRCOM Receiver, the\ninput from the USART\u2019s RX pin is automatically disabled."
            }
          ],
          "title": "IrDA Control Register",
          "description": null
        },
        {
          "offset": "0x0D",
          "name": "TXPLCTRL",
          "fields": [
            {
              "name": "TXPL",
              "size": 8,
              "title": "Transmitter Pulse Length",
              "description": "The 8-bit value sets the pulse modulation scheme for the transmitter. Setting this register will only have effect if\nIRCOM mode is selected by a USART. By leaving this register value to zero, 3/16 of baud rate period pulse\nmodulation is used. Setting this value from 1 to 254 will give a fixed pulse length coding. The 8-bit value sets the\nnumber of system clock periods for the pulse. The start of the pulse will be synchronized with the rising edge of the\nbaud rate clock. Setting the value to 255 (0xFF) will disable pulse coding, letting the RX and TX signals pass through\nthe IRCOM Module unaltered. This enables other features through the IRCOM Module, such as half-duplex USART,\nLoop-back testing and USART RX input from an Event Channel.\nTXPL must be configured before USART transmitter is enabled (TXEN)."
            }
          ],
          "title": "IRCOM Transmitter Pulse Length Control Register",
          "description": null
        },
        {
          "offset": "0x0E",
          "name": "RXPLCTRL",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "RXPL",
              "size": 7,
              "title": "Receiver Pulse Length",
              "description": "The 8-bit value sets the filter coefficient for the IRCOM transceiver. Setting this register will only have effect if IRCOM\nmode is selected by a USART.\nBy leaving this register value to zero, filtering is disabled. Setting this value between 0x01 and 0xFF will enable\nfiltering, where x+1 equal samples are required for the pulse to be accepted.\nRXPL must be configured before USART receiver is enabled (RXEN)."
            }
          ],
          "title": "IRCOM Receiver Pulse Length Control Register",
          "description": null
        }
      ]
    },
    {
      "name": "SPI",
      "datasheetPage": 353,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "DORD",
              "title": "Data Order"
            },
            {
              "name": "MASTER",
              "title": "Master/Slave Select"
            },
            {
              "name": "CLK2X",
              "title": "Clock Double"
            },
            {},
            {
              "name": "PRESC",
              "size": 2,
              "title": "Prescaler"
            },
            {
              "name": "ENABLE",
              "title": "SPI Enable",
              "description": "| Value | Description |\n| 0 | SPI is disabled. |\n| 1 | SPI is enabled. |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "name": "BUFEN",
              "title": "Buffer Mode Enable"
            },
            {
              "name": "BUFWR",
              "title": "Buffer Mode Wait for Receive"
            },
            {
              "size": 3
            },
            {
              "name": "SSD",
              "title": "Slave Select Disable"
            },
            {
              "name": "MODE",
              "size": 2,
              "title": "Mode",
              "description": "| These | bits select the transfer mode. The four combinations of SCK phase and polarity with respect to the serial data |\n| are | shown in the table below. These bits decide whether the first edge of a clock cycle (leading edge) is rising or |\n| falling, | and whether data setup and sample occur on the leading or trailing edge. When the leading edge is rising, the |\n| SCK | signal is low when idle, and when the leading edge is falling, the SCK signal is high when idle. |\n| Value | Name Description |\n| 0x0 | 0 Leading edge: Rising, sample |\n| Trailing | edge: Falling, setup |\n| 0x1 | 1 Leading edge: Rising, setup |\n| Trailing | edge: Falling, sample |\n| 0x2 | 2 Leading edge: Falling, sample |\n| Trailing | edge: Rising, setup |\n| 0x3 | 3 Leading edge: Falling, setup |\n| Trailing | edge: Rising, sample |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "INTCTRL",
          "fields": [
            {
              "name": "RXCIE",
              "title": "Receive Complete Interrupt Enable"
            },
            {
              "name": "TXCIE",
              "title": "Transfer Complete Interrupt Enable"
            },
            {
              "name": "DREIE",
              "title": "Data Register Empty Interrupt Enable"
            },
            {
              "name": "SSIE",
              "title": "Slave Select Trigger Interrupt Enable"
            },
            {
              "size": 3
            },
            {
              "name": "IE",
              "title": "Interrupt Enable",
              "description": "This bit enables the SPI interrupt when the SPI is not in buffer mode. The enabled interrupt will be triggered when\nRXCIF/IF is set in the INTFLAG register."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "INTFLAGS",
          "fields": [
            {
              "name": "RXCIF/IF",
              "title": "Receive Complete Interrupt Flag/Interrupt Flag"
            },
            {
              "name": "TXCIF/WRCOL",
              "title": "Transfer Complete Interrupt Flag/Write Collision Flag"
            },
            {
              "name": "DREIF",
              "title": "Data Register Empty Interrupt Flag"
            },
            {
              "name": "SSIF",
              "title": "Slave Select Trigger Interrupt Flag"
            },
            {
              "size": 3
            },
            {
              "name": "BUFOVF",
              "title": "Buffer Overflow",
              "description": "This flash is only used in buffer mode. This flag indicates data loss due to a receiver buffer full condition. This flag is\nset if a buffer overflow condition is detected. A buffer overflow occurs when the receive buffer is full (two characters)\nand a third byte has been received in the shift register. If there is no transmit data the buffer overflow will not be set\nbefore the start of a new serial transfer. This flag is valid until the receive buffer (DATA) is read. Always write this bit\nlocation to zero when writing the SPI.INTFLAGS register. In non-buffer mode this bit is always zero"
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "DATA",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "SPI Data",
              "description": "The DATA register is used for sending and receiving data. Writing to the register initiates the data transmission, and\nthe byte written to the register will be shifted out on the SPI output line.\nReading this register in buffer mode will read the second receive buffer and the contents of the first receive buffer will\nbe moved to the second receive buffer."
            }
          ],
          "title": "Data",
          "description": null
        }
      ]
    },
    {
      "name": "TWI",
      "datasheetPage": 373,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "SDASETUP",
              "title": "SDA Setup Time",
              "description": "By default, there are 4 clock cycles of setup time on SDA out signal while reading from slave part of the TWI module.\nWriting this bit to '1' will change the setup time to 8 clocks.\nValue Name Description"
            },
            {
              "name": "SDAHOLD",
              "size": 2,
              "title": "SDA Hold Time",
              "description": "Writing these bits selects the SDA hold time.\nTable 26-3.\u2000SDA Hold Time\nSDAHOLD[1:0] Nominal Hold Time Hold Time Range across All\nCorners (ns)\nDescription"
            },
            {
              "name": "FMPEN",
              "title": "FM Plus Enable",
              "description": "Writing these bits selects the 1MHz bus speed (Fast mode plus, Fm+) for the TWI in default configuration.\n\n| Value | Description |\n| ----- | ----------- |\n| 0 | Fm+ disabled |\n| 1 | Fm+ enabled |"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Control",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "MCTRLA",
          "fields": [
            {
              "name": "RIEN",
              "title": "Read Interrupt Enable"
            },
            {
              "name": "WIEN",
              "title": "Write Interrupt Enable"
            },
            {},
            {
              "name": "QCEN",
              "title": "Quick Command Enable"
            },
            {
              "name": "TIMEOUT",
              "size": 2,
              "title": "Inactive Bus Timeout",
              "description": "Value Name Description"
            },
            {
              "name": "SMEN",
              "title": "Smart Mode Enable"
            },
            {
              "name": "ENABLE",
              "title": "Enable TWI Master",
              "description": "Writing this bit to '1' enables the TWI as Master."
            }
          ],
          "title": "Master Control B",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "MCTRLB",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "FLUSH",
              "title": "Flush"
            },
            {
              "name": "ACKACT",
              "title": "Acknowledge Action"
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "| The | master command bits are strobes. These bits are always read as zero. |\n| Writing | to these bits triggers a master operation as defined by the table below. |\n| Table | 26-4.\u2000Command Settings |\n| CMD[1:0] | DIR Description |\n| 0x0 | X NOACT |\n| 0x1 | X REPSTART - Execute Acknowledge Action succeeded by repeated Start. |\n| 0x2 | 0 RECVTRANS - Execute Acknowledge Action succeeded by a byte read operation. |\n| 1 | Execute Acknowledge Action (no action) succeeded by a byte send operation.(1) |\n| 0x3 | X STOP - Execute Acknowledge Action succeeded by issuing a STOP condition. |\n| Note: |  |\n| 1. | For a master being a sender, it will normally wait for new data written to the Master Data Register |\n| (TWI.MDATA). |  |\n| The | acknowledge action bits and command bits can be written at the same time. |"
            }
          ],
          "title": "Master Control B",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "MSTATUS",
          "fields": [
            {
              "name": "RIF",
              "title": "Read Interrupt Flag"
            },
            {
              "name": "WIF",
              "title": "Write Interrupt Flag"
            },
            {
              "name": "CLKHOLD",
              "title": "Clock Hold",
              "description": "If read as '1', this bit indicates that the master is currently holding the TWI clock (SCL) low, stretching the TWI clock\nperiod.\nWriting a '1' to this bit will clear the CLKHOLD flag. However, normal use of the TWI does not require the CLKHOLD\nflag to be cleared by this method, since the flag is automatically cleared when accessing several other TWI registers.\nThe CLKHOLD flag can be cleared by:"
            },
            {
              "name": "RXACK",
              "title": "Received Acknowledge"
            },
            {
              "name": "ARBLOST",
              "title": "Arbitration Lost",
              "description": "If read as '1' this bit indicates that the master has lost arbitration while transmitting a high data or NACK bit, or while\nissuing a start or repeated start condition (S/Sr) on the bus."
            },
            {
              "name": "BUSERR",
              "title": "Bus Error"
            },
            {
              "name": "BUSSTATE",
              "size": 2,
              "title": "Bus State",
              "description": "These bits indicate the current TWI bus state as defined in the table below. After a System Reset or re-enabling, the\nTWI master bus state will be unknown. The change of bus state is dependent on bus activity.\nWriting 0x1 to the BUSSTATE bits forces the bus state logic into its 'idle' state. However, the bus state logic cannot be\nforced into any other state. When the master is disabled, the bus-state is 'unknown'.\nValue Name Description"
            }
          ],
          "title": "Master Status",
          "description": "Normal TWI operation dictates that this register is regarded purely as a read-only register. Clearing any of the status\nflags is done indirectly by accessing the Master transmits address (TWI.MADDR), Master Data register\n(TWI.MDATA), or the Command bits (CMD) in the Master Control B register (TWI.MCTRLB)."
        },
        {
          "offset": "0x06",
          "name": "MBAUD",
          "fields": [
            {
              "name": "BAUD",
              "size": 8,
              "title": "Baud Rate",
              "description": "This bit field is used to derive the SCL high and low time and should be written while the master is disabled (ENABLE\nbit in TWI.MCTRLA is '0').\nFor more information on how to calculate the frequency, see 26.3.4.2.1 Clock Generation."
            }
          ],
          "title": "Master Baud Rate",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "MADDR",
          "fields": [
            {
              "name": "ADDR",
              "size": 8,
              "title": "Address",
              "description": "When this bit field is written, a START condition and slave address protocol sequence is initiated dependent on the\nbus state.\nIf the bus state is unknown the Master Write Interrupt Flag (WIF) and bus error flag (BUSERR) in the Master Status\nregister (TWI.MSTATUS) are set and the operation is terminated.\nIf the bus is busy the master awaits further operation until the bus becomes idle. When the bus is or becomes idle,\nthe master generates a START condition on the bus, copies the ADDR value into the data shift register (TWI.MDATA)\nand performs a byte transmit operation by sending the contents of the data register onto the bus. The master then\nreceives the response i.e. the acknowledge bit from the slave. After completing the operation the bus clock (SCL) is\nforced and held low only if arbitration was not lost. The CLKHOLD bit in the Master Setup register (TWI.MSETUP) is\nset accordingly. Completing the operation sets the WIF in the Master Status register (TWI.MSTATUS).\nIf the bus is already owned, a repeated start (Sr) sequence is performed. In two ways the repeated start (Sr)\nsequence deviates from the start sequence. Firstly, since the bus is already owned by the master, no wait for idle bus\nstate is necessary. Secondly, if the previous transaction was a read, the acknowledge action is sent before the\nrepeated start bus condition is issued on the bus.\nThe master receives one data byte from the slave before the master sets the Master Read Interrupt Flag (RIF) in the\nMaster Status register (TWI.MSTATUS). All TWI Master flags are cleared automatically when this bit field is written.\nThis includes bus error, arbitration lost, and both master interrupt flags.\nThis register can be read at any time without interfering with ongoing bus activity, since a read access does not\ntrigger the master logic to perform any bus protocol related operations.\nThe master control logic uses bit 0 of the TWI.MADDR register as the bus protocol\u2019s read/write flag (R/W)."
            }
          ],
          "title": "Master Address",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "MDATA",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "Data",
              "description": "The bit field gives direct access to the masters physical shift register which is used both to shift data out onto the bus\n(write) and to shift in data received from the bus (read).\nThe direct access implies that the data register cannot be accessed during byte transmissions. Build-in logic prevents\nany write access to this register during the shift operations. Reading valid data or writing data to be transmitted can\nonly be successfully done when the bus clock (SCL) is held low by the master, i.e. when the CLKHOLD bit in the\nMaster Status register (TWI.MSTATUS) is set. However, it is not necessary to check the CLKHOLD bit in software\nbefore accessing this register if the software keeps track of the present protocol state by using interrupts or observing\nthe interrupt flags.\nAccessing this register assumes that the master clock hold is active, auto-triggers bus operations dependent of the\nstate of the acknowledge action command bit (ACKACT) in TWI.MSTATUS and type of register access (read or\nwrite).\nA write access to this register will, independent of ACKACT in TWI.MSTATUS, command the master to perform a\nbyte transmit operation on the bus directly followed by receiving the acknowledge bit from the slave. When the\nacknowledge bit is received, the Master Write Interrupt Flag (WIF) in TWI.MSTATUS is set regardless of any bus\nerrors or arbitration. If operating in a multi-master environment, the interrupt handler or application software must\ncheck the Arbitration Lost Status Flag (ARBLOST) in TWI.MSTATUS before continuing from this point. If the\narbitration was lost, the application software must decide to either abort or to resend the packet by rewriting this\nregister. The entire operation is performed (i.e. all bits are clocked), regardless of winning or losing arbitration before\nthe write interrupt flag is set. When arbitration is lost, only '1's are transmitted for the remainder of the operation,\nfollowed by a write interrupt with ARBLOST flag set.\nBoth TWI master interrupt flags are cleared automatically when this register is written. However, the Master\nArbitration Lost and Bus Error flags are left unchanged.\nReading this register triggers a bus operation, dependent on the setting of the acknowledge action command bit\n(ACKACT) in TWI.MSTATUS. Normally the ACKACT bit is preset to either ACK or NACK before the register read\noperation. If ACK or NACK action is selected, the transmission of the acknowledge bit precedes the release of the\nclock hold. The clock is released for one byte, allowing the slave to put one byte of data on the bus. The Master Read\nInterrupt flag RIF in TWI.MSTATUS is then set if the procedure was successfully executed. However, if arbitration\nwas lost when sending NACK, or a bus error occurred during the time of operation, the Master Write Interrupt flag\n(WIF) is set instead. Observe that the two master interrupt flags are mutual exclusive, i.e. both flags will not be set\nsimultaneously.\nBoth TWI master interrupt flags are cleared automatically if this register is read while ACKACT is set to either ACK or\nNACK. However, arbitration lost and bus error flags are left unchanged."
            }
          ],
          "title": "Master DATA",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "SCTRLA",
          "fields": [
            {
              "name": "DIEN",
              "title": "Data Interrupt Enable"
            },
            {
              "name": "APIEN",
              "title": "Address or Stop Interrupt Enable"
            },
            {
              "name": "PIEN",
              "title": "Stop Interrupt Enable"
            },
            {
              "size": 2
            },
            {
              "name": "PMEN",
              "title": "Address Recognition Mode"
            },
            {
              "name": "SMEN",
              "title": "Smart Mode Enable"
            },
            {
              "name": "ENABLE",
              "title": "Enable TWI Slave",
              "description": "Writing this bit to '1' enables the TWI slave."
            }
          ],
          "title": "Slave Control B",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "SCTRLB",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "ACKACT",
              "title": "Acknowledge Action",
              "description": "This bit defines the slave\u2019s behavior under certain conditions defined by the bus protocol state and software\ninteraction. The table below lists the acknowledge procedure performed by the slave if action is initiated by software.\nThe acknowledge action is performed when TWI.SDATA is read or written, or when an execute command is written to\nthe CMD bits in this register.\nThe ACKACT bit is not a flag or strobe, but an ordinary read/write accessible register bit.\nValue Name Description"
            },
            {
              "name": "CMD",
              "size": 2,
              "title": "Command",
              "description": "Unlike the acknowledge action bits, the slave command bits are strobes. These bits always read as zero. Writing to\nthese bits trigger a slave operation as defined in the table below.\nTable 26-5.\u2000Command Settings\nCMD[1:0] DIR Description"
            }
          ],
          "title": "Slave Control B",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "SSTATUS",
          "fields": [
            {
              "name": "DIF",
              "title": "Data Interrupt Flag",
              "description": "This flag is set when a slave byte transmit or byte receive operation is successfully completed without any bus error.\nThe flag can be set with an unsuccessful transaction in case of collision detection (see description of the COLL status\nbit). Writing a '1' to its bit location will clear the DIF. However, normal use of the TWI does not require the DIF flag to\nbe cleared by using this method, since the flag is automatically cleared when:"
            },
            {
              "name": "APIF",
              "title": "Address or Stop Interrupt Flag"
            },
            {
              "name": "CLKHOLD",
              "title": "Clock Hold"
            },
            {
              "name": "RXACK",
              "title": "Received Acknowledge"
            },
            {
              "name": "COLL",
              "title": "Collision",
              "description": "If read as '1', the transmit collision flag indicates that the slave has not been able to transmit a high data or NACK bit.\nIf a slave transmit collision is detected, the slave will commence its operation as normal, except no low values will be\nshifted out onto the SDA line (i.e., when the COLL flag is set to '1' it disables the data and acknowledge output from\nthe slave logic). DIF flag will be set to '1' at the end as a result of internal completion of unsuccessful transaction.\nSimilarly when collision occurs because slave is not been able to transmit NACK bit, it means address match already\nhappened and APIF flag is set as a result. APIF/DIF flags can only generate interrupt whose handlers can be used to\ncheck for the collision. Writing a '1' to its bit location will clear the COLL flag. However, the flag is automatically\ncleared if any START condition (S/Sr) is detected.\nThis flag is intended for systems where address resolution protocol (ARP) is employed. However, a detected collision\nin non-ARP situations indicates that there has been a protocol violation and should be treated as a bus error."
            },
            {
              "name": "BUSERR",
              "title": "Bus Error"
            },
            {
              "name": "DIR",
              "title": "Read/Write Direction"
            },
            {
              "name": "AP",
              "title": "Address or Stop",
              "description": "When the TWI slave address or stop interrupt flag (APIF) is set, this bit determines whether the interrupt is due to\naddress detection or a stop condition.\nValue Name Description"
            }
          ],
          "title": "Slave Status",
          "description": "Normal TWI operation dictates that the slave status register should be regarded purely as a read-only register.\nClearing any of the status flags will indirectly be done when accessing the slave data (TWI.SDATA) register or the\nCMD bits in the Slave Control B register (TWI.SCTRLB)."
        },
        {
          "offset": "0x0C",
          "name": "SADDR",
          "fields": [
            {
              "name": "ADDR",
              "size": 8,
              "title": "Address",
              "description": "The slave address register in combination with the slave address mask register (TWI.SADDRMASK) is used by the\nslave address match logic to determine if a master TWI device has addressed the TWI slave. The slave address\ninterrupt flag (APIF) is set to one if the received address is recognized. The slave address match logic supports\nrecognition of 7- and 10-bits addresses, and general call address.\nWhen using 7-bit or 10-bit address recognition mode, the upper 7-bits of the address register (ADDR[7:1]) represents\nthe slave address and the least significant bit (ADDR[0]) is used for general call address recognition. Setting the\nADDR[0] bit in this case enables the general call address recognition logic. The TWI slave address match logic only\nsupport recognition of the first byte of a 10-bit address i.e. by setting ADDRA[7:1] = \u201c0b11110aa\u201d where \u201caa\u201d\nrepresents bit 9 and 8 or the slave address. The second 10-bit address byte must be handled by software."
            }
          ],
          "title": "Slave Address",
          "description": null
        },
        {
          "offset": "0x0D",
          "name": "SDATA",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "Data",
              "description": "The slave data register I/O location (DATA) provides direct access to the slave's physical shift register, which is used\nboth to shift data out onto the bus (transmit) and to shift in data received from the bus (receive). The direct access\nimplies that the data register cannot be accessed during byte transmissions. Built-in logic prevents any write\naccesses to the data register during the shift operations. Reading valid data or writing data to be transmitted can only\nbe successfully done when the bus clock (SCL) is held low by the slave, i.e. when the slave CLKHOLD bit is set.\nHowever, it is not necessary to check the CLKHOLD bit in software before accessing the slave DATA register if the\nsoftware keeps track of the present protocol state by using interrupts or observing the interrupt flags. Accessing the\nslave DATA register, assumed that clock hold is active, auto-trigger bus operations dependent of the state of the\nslave acknowledge action command bits (ACKACT) and type of register access (read or write)."
            }
          ],
          "title": "Slave Data",
          "description": null
        },
        {
          "offset": "0x0E",
          "name": "SADDRMASK",
          "fields": [
            {
              "name": "ADDRMASK",
              "size": 7,
              "title": "Address Mask"
            },
            {
              "name": "ADDREN",
              "title": "Address Mask Enable",
              "description": "If this bit is written to '1', the slave address match logic responds to the 2 unique addresses in slave ADDR and\nADDRMASK.\nIf this bit is '0', the ADDRMASK register acts as a mask to the slave ADDR register."
            }
          ],
          "title": "Slave Address Mask",
          "description": null
        }
      ]
    },
    {
      "name": "CRCSCAN",
      "datasheetPage": 395,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RESET",
              "title": "Reset CRCSCAN"
            },
            {
              "size": 5
            },
            {
              "name": "NMIEN",
              "title": "Enable NMI Trigger"
            },
            {
              "name": "ENABLE",
              "title": "Enable CRCSCAN",
              "description": "Writing this bit to '1' enables the CRCSCAN peripheral with the current settings. It will stay '1' even after a CRC check\nhas completed, but writing it to \u20181\u2019 again will start a new check.\nWriting the bit to '0' will disable the CRCSCAN after the ongoing check is completed (after reaching the end of the\nsection it is set up to check). A failure in the ongoing check will still be detected and can cause an NMI if the NMIEN\nbit is '1'.\nThe CRCSCAN can be enabled during the internal Reset initialization to verify Flash sections before letting the CPU\nstart normal code execution (see the device data sheet fuse description). If the CRCSCAN is enabled during the\ninternal Reset initialization, the ENABLE bit will read as '1' when normal code execution starts.\nTo see whether the CRCSCAN peripheral is busy with an ongoing check, poll the Busy bit (BUSY) in the STATUS\nregister (CRCSCAN.STATUS)."
            }
          ],
          "title": "Control B",
          "description": "The CTRLB register contains the mode and source settings for the CRC. It is not writable when the CRC is busy or\nwhen an NMI has been triggered."
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "MODE",
              "size": 2,
              "title": "CRC Flash Access Mode",
              "description": "The CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see\nthe device data sheet fuse description). If the CRC is enabled during internal Reset initialization, the MODE bit field\nwill read out non-zero when normal code execution starts. To ensure proper operation of the CRC under code\nexecution, write the MODE bit to 0x0 again.\nValue Name Description"
            },
            {
              "size": 2
            },
            {
              "name": "SRC",
              "size": 2,
              "title": "CRC Source",
              "description": "The SRC bit field selects which section of the Flash the CRC module should check. To set up section sizes, refer to\nthe fuse description.\nThe CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see\nfuse description). If the CRC is enabled during internal Reset initialization, the SRC bit field will read out as FLASH,\nBOOTAPP, or BOOT when normal code execution starts (depending on the configuration).\nValue Name Description"
            }
          ],
          "title": "Control B",
          "description": "The CTRLB register contains the mode and source settings for the CRC. It is not writable when the CRC is busy or\nwhen an NMI has been triggered."
        },
        {
          "offset": "0x02",
          "name": "STATUS",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "OK",
              "title": "CRC OK"
            },
            {
              "name": "BUSY",
              "title": "CRC Busy",
              "description": "When this bit is read as '1', the CRC module is busy. As long as the module is busy, the access to the control\nregisters is limited."
            }
          ],
          "title": "Status",
          "description": "The STATUS register contains the busy and OK information. It is not writable, only readable."
        }
      ]
    },
    {
      "name": "CCL",
      "datasheetPage": 410,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "RUNSTDBY",
              "title": "Run in Standby"
            },
            {
              "size": 5
            },
            {
              "name": "ENABLE",
              "title": "Enable",
              "description": "| Value | Description |\n| 0 | The peripheral is disabled. |\n| 1 | The peripheral is enabled. |"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "SEQCTRL0",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "SEQSEL",
              "size": 4,
              "title": "Sequential Selection",
              "description": "These bits select the sequential configuration.\nValue Name Description"
            }
          ],
          "title": "Sequential Control 0",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "LUT0CTRLA",
          "fields": [
            {
              "name": "EDGEDET",
              "title": "Edge Detection"
            },
            {
              "name": "CLKSRC",
              "title": "Clock Source Selection"
            },
            {
              "name": "FILTSEL",
              "size": 2,
              "title": "Filter Selection"
            },
            {
              "name": "OUTEN",
              "title": "Output Enable"
            },
            {
              "size": 2
            },
            {
              "name": "ENABLE",
              "title": "LUT Enable",
              "description": "| Value | Description |\n| 0 | The LUT is disabled. |\n| 1 | The LUT is enabled. |"
            }
          ],
          "title": "LUT n Control A",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "LUT0CTRLB",
          "fields": [
            {
              "name": "INSEL1",
              "size": 4,
              "title": "LUT n Input 1 Source Selection",
              "description": "These bits select the source for input 1 of LUT n:\nValue Name Description"
            },
            {
              "name": "INSEL0",
              "size": 4,
              "title": "LUT n Input 0 Source Selection",
              "description": "These bits select the source for input 0 of LUT n:\nValue Name Description"
            }
          ],
          "title": "LUT n Control B",
          "description": "SPI connections to the CCL work only in master SPI mode.\nUSART connections to the CCL work only in asynchronous/synchronous USART Master mode."
        },
        {
          "offset": "0x07",
          "name": "LUT0CTRLC",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "INSEL2",
              "size": 4,
              "title": "LUT n Input 2 Source Selection",
              "description": "These bits select the source for input 2 of LUT n:\nValue Name Description"
            }
          ],
          "title": "LUT n Control C",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "TRUTH0",
          "fields": [
            {
              "name": "TRUTH",
              "size": 8,
              "title": "Truth Table",
              "description": "These bits define the value of truth logic as a function of inputs IN[2:0]."
            }
          ],
          "title": "TRUTHn",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "LUT1CTRLA",
          "fields": [
            {
              "name": "EDGEDET",
              "title": "Edge Detection"
            },
            {
              "name": "CLKSRC",
              "title": "Clock Source Selection"
            },
            {
              "name": "FILTSEL",
              "size": 2,
              "title": "Filter Selection"
            },
            {
              "name": "OUTEN",
              "title": "Output Enable"
            },
            {
              "size": 2
            },
            {
              "name": "ENABLE",
              "title": "LUT Enable",
              "description": "| Value | Description |\n| 0 | The LUT is disabled. |\n| 1 | The LUT is enabled. |"
            }
          ],
          "title": "LUT n Control A",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "LUT1CTRLB",
          "fields": [
            {
              "name": "INSEL1",
              "size": 4,
              "title": "LUT n Input 1 Source Selection",
              "description": "These bits select the source for input 1 of LUT n:\nValue Name Description"
            },
            {
              "name": "INSEL0",
              "size": 4,
              "title": "LUT n Input 0 Source Selection",
              "description": "These bits select the source for input 0 of LUT n:\nValue Name Description"
            }
          ],
          "title": "LUT n Control B",
          "description": "SPI connections to the CCL work only in master SPI mode.\nUSART connections to the CCL work only in asynchronous/synchronous USART Master mode."
        },
        {
          "offset": "0x0B",
          "name": "LUT1CTRLC",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "INSEL2",
              "size": 4,
              "title": "LUT n Input 2 Source Selection",
              "description": "These bits select the source for input 2 of LUT n:\nValue Name Description"
            }
          ],
          "title": "LUT n Control C",
          "description": null
        },
        {
          "offset": "0x0C",
          "name": "TRUTH1",
          "fields": [
            {
              "name": "TRUTH",
              "size": 8,
              "title": "Truth Table",
              "description": "These bits define the value of truth logic as a function of inputs IN[2:0]."
            }
          ],
          "title": "TRUTHn",
          "description": null
        }
      ]
    },
    {
      "name": "AC",
      "datasheetPage": 421,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RUNSTDBY",
              "title": "Run in Standby Mode"
            },
            {
              "name": "OUTEN",
              "title": "Analog Comparator Output Pad Enable"
            },
            {
              "name": "INTMODE",
              "size": 2,
              "title": "Interrupt Modes"
            },
            {
              "name": "LPMODE",
              "title": "Low Power Mode"
            },
            {
              "name": "HYSMODE",
              "size": 2,
              "title": "Hysteresis Mode Select"
            },
            {
              "name": "ENABLE",
              "title": "Enable AC",
              "description": "| Writing | this bit to '1' enables the AC. |"
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "MUXCTRLA",
          "fields": [
            {
              "name": "INVERT",
              "title": "Invert AC Output",
              "description": "Writing a '1' to this bit enables inversion of the output of the AC. This effectively inverts the input to all the peripherals\nconnected to the signal, and also affects the internal status signals.\nWriting to this bit field selects the input signal to the positive input of the AC.\nValue Name Description"
            },
            {
              "size": 5
            },
            {
              "name": "MUXNEG",
              "size": 2,
              "title": "Negative Input MUX Selection",
              "description": "Writing to this bit field selects the input signal to the negative input of the AC.\nValue Name Description"
            }
          ],
          "title": "Mux Control A",
          "description": "AC.MUXCTRLA controls Analog Comparator Muxes"
        },
        {
          "offset": "0x06",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "CMP",
              "title": "Analog Comparator Interrupt Enable",
              "description": "Writing this bit to '1' enables Analog Comparator Interrupt."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "STATUS",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "STATE",
              "title": "Analog Comparator State"
            },
            {
              "size": 3
            },
            {
              "name": "CMP",
              "title": "Analog Comparator Interrupt Flag",
              "description": "This is the interrupt flag for AC. Writing a '1' to this bit will clear the Interrupt flag."
            }
          ],
          "title": "Status",
          "description": null
        }
      ]
    },
    {
      "name": "ADC",
      "datasheetPage": 437,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RUNSTBY",
              "title": "Run in Standby"
            },
            {
              "size": 4
            },
            {
              "name": "RESSEL",
              "title": "Resolution Selection"
            },
            {
              "name": "FREERUN",
              "title": "Free Running"
            },
            {
              "name": "ENABLE",
              "title": "ADC Enable",
              "description": "| Value | Description |\n| 0 | ADC is disabled. |\n| 1 | ADC is enabled. |"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "CTRLB",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "SAMPNUM",
              "size": 3,
              "title": "Sample Accumulation Number Select",
              "description": "These bits select how many consecutive ADC sampling results are accumulated automatically. When this bit is\nwritten to a value greater than 0x0, the according number of consecutive ADC sampling results are accumulated into\nthe ADC Result register (RES) in one complete conversion.\nValue Name Description"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLC",
          "fields": [
            {
              "size": 1
            },
            {
              "name": "SAMPCAP",
              "title": "Sample Capacitance Selection"
            },
            {
              "name": "REFSEL",
              "size": 2,
              "title": "Reference Selection"
            },
            {},
            {
              "name": "PRESC",
              "size": 3,
              "title": "Prescaler",
              "description": "| These | bits defines the division factor from peripheral clock (CLK_PER) to the ADC clock (CLK_ADC). |\n| Value | Name Description |\n| 0x0 | DIV2 CLK_PER divided by 2 |\n| 0x1 | DIV4 CLK_PER divided by 4 |\n| 0x2 | DIV8 CLK_PER divided by 8 |\n| 0x3 | DIV16 CLK_PER divided by 16 |\n| 0x4 | DIV32 CLK_PER divided by 32 |\n| 0x5 | DIV64 CLK_PER divided by 64 |\n| 0x6 | DIV128 CLK_PER divided by 128 |\n| 0x7 | DIV256 CLK_PER divided by 256 |"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "CTRLD",
          "fields": [
            {
              "name": "INITDLY",
              "size": 3,
              "title": "Initialization Delay",
              "description": "These bits defines the initialization/startup delay before the first sample when enabling the ADC or changing to\ninternal reference voltage. Setting this delay will ensure that the reference, muxes, etc are ready before starting the\nfirst conversion. The initialization delay will also take place when waking up from deep sleep to do a measurement.\nThe delay is expressed as a number of CLK_ADC cycles.\nValue Name Description"
            },
            {
              "name": "ASDV",
              "title": "Automatic Sampling Delay Variation",
              "description": "Writing this bit to '1' enables automatic sampling delay variation between ADC conversions. The purpose of varying\nsampling instant is to randomize the sampling instant and thus avoid standing frequency components in frequency\nspectrum. The value of the SAMPDLY bits is automatically incremented by one after each sample.\nWhen the Automatic Sampling Delay Variation is enabled and the SAMPDLY value reaches 0xF, it wraps around to"
            },
            {
              "name": "SAMPDLY",
              "size": 4,
              "title": "Sampling Delay Selection",
              "description": "These bits define the delay between consecutive ADC samples. The programmable Sampling Delay allows modifying\nthe sampling frequency during hardware accumulation, to suppress periodic noise sources that may otherwise disturb\nthe sampling. The SAMPDLY field can be also modified automatically from sampling cycle to another, by setting the\nASDV bit. The delay is expressed as CLK_ADC cycles and is given directly by the bitfield setting. The sampling cap\nis kept open during the delay."
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x04",
          "name": "CTRLE",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "WINCM",
              "size": 3,
              "title": "Window Comparator Mode",
              "description": "This field enable and define when the interrupt flag is set in Window Comparator mode. RESULT is the 16-bit\naccumulator result. WINLT and WINHT are 16-bit lower threshold value and 16-bit higher threshold value,\nrespectively.\nValue Name Description"
            }
          ],
          "title": "Control E",
          "description": null
        },
        {
          "offset": "0x05",
          "name": "SAMPCTRL",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "SAMPLEN",
              "size": 5,
              "title": "Sample Length",
              "description": "These bits extend the ADC sampling length in number of CLK_ADC cycles. By default the sampling time is two\nCLK_ADC cycles. Increasing the sampling length allows sampling sources with higher impedance. The total\nconversion time increased with the selected sampling length."
            }
          ],
          "title": "Sample Control",
          "description": null
        },
        {
          "offset": "0x06",
          "name": "MUXPOS",
          "fields": [
            {
              "size": 3
            },
            {
              "name": "MUXPOS",
              "size": 5,
              "title": "MUXPOS",
              "description": "This bit field selects which single-ended analog input is connected to the ADC. If these bits are changed during a\nconversion, the change will not take effect until this conversion is complete.\nValue Name Description"
            }
          ],
          "title": "MUXPOS",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "COMMAND",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "STCONV",
              "title": "Start Conversion",
              "description": "Writing a '1' to this bit will start a single measurement. If in free running mode this will start the first conversion.\nSTCONV will read as '1' as long as a conversion is in progress. When the conversion is complete, this bit is\nautomatically cleared.\nWriting the bit to '0' during an ongoing conversion will stop the conversion."
            }
          ],
          "title": "Command",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "EVCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "STARTEI",
              "title": "Start Event Input",
              "description": "This bit enables event input as source for conversion start."
            }
          ],
          "title": "Event Control",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "INTCTRL",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "WCOMP",
              "title": "Window Comparator Interrupt Enable"
            },
            {
              "name": "RESRDY",
              "title": "Result Ready Interrupt Enable",
              "description": "Writing a '1' to this bit enables result ready interrupt."
            }
          ],
          "title": "Interrupt Control",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "INTFLAGS",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "WCOMP",
              "title": "Window Comparator Interrupt Flag"
            },
            {
              "name": "RESRDY",
              "title": "Result Ready Interrupt Flag",
              "description": "The result ready interrupt flag is set when a measurement is complete and a new result is ready. The flag is cleared\nby either writing a '1' to the bit location or by reading the result register (ADCn.RES). Writing a '0' to this bit has no\neffect."
            }
          ],
          "title": "Interrupt Flags",
          "description": null
        },
        {
          "offset": "0x0C",
          "name": "DBGCTRL",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DBGRUN",
              "title": "Debug Run",
              "description": "\n| Value | Description |\n| ----- | ----------- |\n| 0 | The peripheral is halted in break debug mode and ignores events. |\n| 1 | The peripheral will continue to run in break debug mode when the CPU is halted. |"
            }
          ],
          "title": "Debug Run",
          "description": null
        },
        {
          "offset": "0x0D",
          "name": "TEMP",
          "fields": [
            {
              "name": "TEMP",
              "size": 8,
              "title": "Temporary",
              "description": "Temporary register for read/write operations in 16-bit registers."
            }
          ],
          "title": "Temporary",
          "description": "The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\nTemporary register for all the 16-bit registers of this peripheral."
        },
        {
          "offset": "0x10",
          "name": "RES",
          "fields": [
            {
              "name": "RES",
              "size": 8,
              "title": "Result low byte",
              "description": "These bits constitute the LSB of ADC/Accumulator Result, (RES) register. The data format in ADC and Digital\nAccumulation is 1\u2019s complement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full\nscale)."
            },
            {
              "name": "RES",
              "size": 8,
              "title": "Result low byte",
              "description": "These bits constitute the LSB of ADC/Accumulator Result, (RES) register. The data format in ADC and Digital\nAccumulation is 1\u2019s complement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full\nscale)."
            }
          ],
          "title": "Result",
          "description": "The RESL and RESH register pair represents the 16-bit value, RES. The low byte [7:0] (suffix L) is accessible at the\noriginal offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading and\nwriting 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nIf the analog input is higher than the reference level of the ADC, the 10 bit ADC result will be equal the max value of\n0x3FF. Likewise, if the input is below 0V, the ADC result will be 0x000. As the ADC cannot produce a result above\n0x3FF values, the accumulated value will never exceed 0xFFC0 even after maximum allowed 64 accumulations.\nBit 15 14 13 12 11 10 9 8\nRES[15:8]\nAccess R R R R R R R R\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x12",
          "name": "WINLT",
          "fields": [
            {
              "name": "WINLT",
              "size": 8,
              "title": "Window Comparator Low Threshold low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            },
            {
              "name": "WINLT",
              "size": 8,
              "title": "Window Comparator Low Threshold low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            }
          ],
          "title": "Window Comparator Low Threshold",
          "description": "This register is the 16-bit Low Threshold for the digital comparator monitoring the RES register. The ADC itself has\n10-bit output, RES[9:0], where the msb is RES[9]. The data format in ADC and Digital Accumulation is one\u2019s\ncomplement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale).\nThe WINLTH and WINLTL register pair represent the 16-bit value, WINLT. The low byte [7:0] (suffix L) is accessible at\nthe original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading and\nwriting 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nWhen accumulating samples, the window comparator thresholds are applied on the accumulated value and not on\neach sample.\nBit 15 14 13 12 11 10 9 8\nWINLT[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x14",
          "name": "WINHT",
          "fields": [
            {
              "name": "WINHT",
              "size": 8,
              "title": "Window Comparator High Threshold low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            },
            {
              "name": "WINHT",
              "size": 8,
              "title": "Window Comparator High Threshold low byte",
              "description": "These bits hold the LSB of the 16-bit register."
            }
          ],
          "title": "Window Comparator High Threshold",
          "description": "This register is the 16-bit High Threshold for the digital comparator monitoring the RES register. The ADC itself has\n10-bit output, RES[9:0], where the msb is RES[9]. The data format in ADC and Digital Accumulation is one\u2019s\ncomplement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale).\nThe WINHTH and WINHTL register pair represent the 16-bit value, WINHT. The low byte [7:0] (suffix L) is accessible\nat the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading\nand writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\nBit 15 14 13 12 11 10 9 8\nWINHT[15:8]\nAccess R/W R/W R/W R/W R/W R/W R/W R/W\nReset 0 0 0 0 0 0 0 0"
        },
        {
          "offset": "0x16",
          "name": "CALIB",
          "fields": [
            {
              "size": 7
            },
            {
              "name": "DUTYCYC",
              "title": "Duty Cycle",
              "description": "This bit determines the duty cycle of the ADC clock.\nADCclk > 1.5 MHz requires a minimum operating voltage of 2.7V\n\n| Value | Description |\n| ----- | ----------- |\n| 0 | 50% Duty Cycle must be used if ADCclk > 1.5 MHz |\n| 1 | 25% Duty Cycle (high 25% and low 75%) must be used for ADCclk \u2264 1.5 MHz |"
            }
          ],
          "title": "Calibration",
          "description": null
        }
      ]
    },
    {
      "name": "DAC",
      "datasheetPage": 458,
      "offsets": [
        {
          "offset": "0x00",
          "name": "CTRLA",
          "fields": [
            {
              "name": "RUNSTDBY",
              "title": "Run in Standby Mode"
            },
            {
              "name": "OUTEN",
              "title": "Output Buffer Enable"
            },
            {
              "size": 5
            },
            {
              "name": "ENABLE",
              "title": "DAC Enable",
              "description": "Writing a '1' to this bit enables the DAC."
            }
          ],
          "title": "Control A",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "DATA",
          "fields": [
            {
              "name": "DATA",
              "size": 8,
              "title": "Data",
              "description": "These bits contains the digital data which will be converted to an analog voltage."
            }
          ],
          "title": "DATA",
          "description": null
        }
      ]
    },
    {
      "name": "UPDI",
      "datasheetPage": 485,
      "offsets": [
        {
          "offset": "0x00",
          "name": "STATUSA",
          "fields": [
            {
              "size": 4
            },
            {
              "name": "UPDIREV",
              "size": 4,
              "title": "UPDI Revision",
              "description": "These bits are read-only and contain the revision of the current UPDI implementation."
            }
          ],
          "title": "Status B",
          "description": null
        },
        {
          "offset": "0x01",
          "name": "STATUSB",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "PESIG",
              "size": 3,
              "title": "UPDI Error Signature",
              "description": "These bits describe the UPDI Error Signature, and is set when an internal UPDI error condition occurs. The PESIG\nfield is cleared on a read from the debugger.\nTable 33-7.\u2000Valid Error Signatures\nPESIG[2:0] Error Type Error Description"
            }
          ],
          "title": "Status B",
          "description": null
        },
        {
          "offset": "0x02",
          "name": "CTRLA",
          "fields": [
            {
              "name": "IBDLY",
              "title": "Inter-Byte Delay Enable"
            },
            {},
            {
              "name": "PARD",
              "title": "Parity Disable"
            },
            {
              "name": "DTD",
              "title": "Disable Timeout Detection"
            },
            {
              "name": "RSD",
              "title": "Response Signature Disable"
            },
            {
              "name": "GTVAL",
              "size": 3,
              "title": "Guard Time Value",
              "description": "This bit field selects the Guard Time Value that will be used by the UPDI when the transmission mode switches from\nRX to TX. The Guard time is equal to the Baud Rate used in 1-Wire mode.\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | UPDI Guard Time: 128 cycles (default) |\n| 0x1 | UPDI Guard Time: 64 cycles |\n| 0x2 | UPDI Guard Time: 32 cycles |\n| 0x3 | UPDI Guard Time: 16 cycles |\n| 0x4 | UPDI Guard Time: 8 cycles |\n| 0x5 | UPDI Guard Time: 4 cycles |\n| 0x6 | UPDI Guard Time: 2 cycles |\n| 0x7 | GT off (no extra Idle bits inserted) |"
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x03",
          "name": "CTRLB",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "NACKDIS",
              "title": "Disable NACK Response"
            },
            {
              "name": "CCDETDIS",
              "title": "Collision and Contention Detection Disable"
            },
            {
              "name": "UPDIDIS",
              "title": "UPDI Disable",
              "description": "Writing a '1' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and the UPDI is\nreset. All UPDI PHY configurations and KEYs will be reset when the UPDI is disabled."
            }
          ],
          "title": "Control B",
          "description": null
        },
        {
          "offset": "0x07",
          "name": "ASI_KEY_STATUS",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "UROWWRITE",
              "title": "User Row Write Key Status"
            },
            {
              "name": "NVMPROG",
              "title": "NVM Programming"
            },
            {
              "name": "CHIPERASE",
              "title": "Chip Erase",
              "description": "This bit is set to '1' if the CHIPERASE KEY is active. This bit will automatically be reset when the chip erase\nsequence is completed. Otherwise this bit reads as zero."
            }
          ],
          "title": "ASI Key Status",
          "description": null
        },
        {
          "offset": "0x08",
          "name": "ASI_RESET_REQ",
          "fields": [
            {
              "name": "RSTREQ",
              "size": 8,
              "title": "Reset Request",
              "description": "A Reset is signalized to the System when writing the Reset signature 0x59h to this address.\nWriting any other signature to this register will clear the Reset.\nWhen reading this register, reading bit RSTREQ[0] will tell if the UPDI is holding an active Reset on the system. If this\nbit is '1', the UPDI has an active Reset request to the system. All other bits will read as '0'.\nThe UPDI will not be reset when issuing a System Reset from this register."
            }
          ],
          "title": "ASI Reset Request",
          "description": null
        },
        {
          "offset": "0x09",
          "name": "ASI_CTRLA",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "UPDICLKSEL",
              "size": 2,
              "title": "UPDI Clock Select",
              "description": "Writing these bits selects the UPDI clock output frequency. Default setting after reset and enable is 4MHz. Any other\nclock output selection is only recommended when the BOD is at the highest level. For all other BOD settings, the\ndefault 4MHz selection is recommended.\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | Reserved |\n| 0x1 | 16MHz UPDI clock |\n| 0x2 | 8MHz UPDI clock |\n| 0x3 | 4MHz UPDI clock (Default Setting) |"
            }
          ],
          "title": "ASI Control A",
          "description": null
        },
        {
          "offset": "0x0A",
          "name": "ASI_SYS_CTRLA",
          "fields": [
            {
              "size": 6
            },
            {
              "name": "UROWWRITE_FINAL",
              "title": "User Row Programming Done"
            },
            {
              "name": "CLKREQ",
              "title": "Request System Clock",
              "description": "If this bit is written to '1', the ASI is requesting the system clock, independent of system sleep modes. This makes it\npossible for the UPDI to access the ACC layer, also if the system is in sleep mode.\nWriting a zero to this bit will lower the clock request.\nThis bit will be reset when the UPDI is disabled.\nThis bit is set by default when the UPDI is enabled in any mode (Fuse, 12V)."
            }
          ],
          "title": "ASI System Control A",
          "description": null
        },
        {
          "offset": "0x0B",
          "name": "ASI_SYS_STATUS",
          "fields": [
            {
              "size": 2
            },
            {
              "name": "RSTSYS",
              "title": "System Reset Active"
            },
            {
              "name": "INSLEEP",
              "title": "System Domain in Sleep"
            },
            {
              "name": "NVMPROG",
              "title": "Start NVM Programming"
            },
            {
              "name": "UROWPROG",
              "title": "Start User Row Programming"
            },
            {},
            {
              "name": "LOCKSTATUS",
              "title": "NVM Lock Status",
              "description": "If this bit is set, the device is locked. If a Chiperase is done, and the Lockbits are cleared, this bit will read as zero."
            }
          ],
          "title": "ASI System Status",
          "description": null
        },
        {
          "offset": "0x0C",
          "name": "ASI_CRC_STATUS",
          "fields": [
            {
              "size": 5
            },
            {
              "name": "CRC_STATUS",
              "size": 3,
              "title": "CRC Execution Status",
              "description": "These bits signalize the status of the CRC conversion. The bits are one-hot encoded.\n\n| Value | Description |\n| ----- | ----------- |\n| 0x0 | Not enabled |\n| 0x1 | CRC enabled, busy |\n| 0x2 | CRC enabled, done with OK signature |\n| 0x4 | CRC enabled, done with FAILED signature |\n| Other | Reserved |"
            }
          ],
          "title": "ASI CRC Status",
          "description": null
        }
      ]
    }
  ]
}