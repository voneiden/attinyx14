(this.webpackJsonpattinyx14=this.webpackJsonpattinyx14||[]).push([[0],{135:function(e,t,i){},22:function(e,t,i){},23:function(e,t,i){},347:function(e,t){},365:function(e,t,i){"use strict";i.r(t);var n=i(0),s=i.n(n),r=i(16),a=i.n(r),o=(i(68),i(57)),l=i.n(o),c=i(58),d=i.n(c),h=i(59),u=(i(69),i(29)),f=function(e){var t=e.pin,i=e.children;return s.a.createElement("div",{className:"pin-row pin-".concat(t.pin)},i)},p=(i(72),function(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];return t.filter((function(e){return e})).join(" ")}),m=i(2),b=m.b.model({type:m.b.string,label:m.b.string,alt:m.b.optional(m.b.boolean,!1),groups:m.b.array(m.b.string)}),g=m.b.model({pin:m.b.number,attributes:m.b.array(b)}),T=m.b.model({topic:m.b.string,title:m.b.string,text:m.b.string,chip:m.b.optional(m.b.boolean,!1)}),C=m.b.model({name:m.b.maybeNull(m.b.string),title:m.b.maybeNull(m.b.string),size:m.b.optional(m.b.number,1),description:m.b.maybeNull(m.b.string),relatedGroups:m.b.array(m.b.string)}),S=m.b.model({name:m.b.string,title:m.b.string,fields:m.b.array(C),description:m.b.maybeNull(m.b.string)}),R=m.b.model({name:m.b.string,datasheetPage:m.b.maybeNull(m.b.number),offsets:m.b.array(S)}),w=m.b.model({topics:m.b.array(T),registries:m.b.array(R),pins:m.b.array(g),highlightGroups:m.b.array(m.b.string),datasheetUrl:m.b.optional(m.b.string,"http://ww1.microchip.com/downloads/en/DeviceDoc/ATtiny214-414-814-DataSheet-DS40001912C.pdf")}).actions((function(e){return{setTopics:function(t){e.topics=t},setRegistries:function(t){e.registries=t},setPins:function(t){e.pins=t},setHighlightGroups:function(t){t!==e.highlightGroups&&(e.highlightGroups=t||[])}}})).views((function(e){return{get primaryHighlightGroup(){return e.highlightGroups.length?e.highlightGroups[0]:null},get secondaryHighlightGroups(){return e.highlightGroups.slice(1)},getTopic:function(t){return e.topics.find((function(e){return e.topic===t}))},getRegistry:function(t){return e.registries.find((function(e){return e.name===t}))},getRegistryDatasheetLink:function(t){return e.getDatasheetPageLink(t.datasheetPage)},getDatasheetPageLink:function(t){return t?"".concat(e.datasheetUrl,"#page=").concat(t):null},get chipTopics(){return e.topics.filter((function(e){return e.chip}))}}})).create(),A=i(10),E=i(4),D=i(9),y=Object(A.a)((function(e){var t=e.pin,i=e.attribute,n=i.label,r=i.type,a=i.alt,o=i.groups,l=Object(E.f)(),c=l.activeGroup,d=parseInt(l.activePin),h=o.length?o[0]:null,u=d&&d===t.pin,f=o.includes(c),b=c&&!f,g=o.includes(w.primaryHighlightGroup),T=!g&&w.secondaryHighlightGroups.filter((function(e){return o.includes(e)})).length;return s.a.createElement(D.b,{to:"/topic/".concat(h,"/").concat(t.pin),className:p("pin-attribute","".concat(r,"-pin"),a&&"alt-pin",g&&"highlight-primary-pin",T&&"highlight-secondary-pin",u&&"active-pin",f&&"active-group",b&&"inactive-group"),onMouseEnter:function(){return w.setHighlightGroups(Object(m.a)(o))},onMouseLeave:function(){return w.setHighlightGroups([])},onClick:function(e){e.stopPropagation()}},n)})),I=(i(22),function(e){var t=e.pin;return s.a.createElement("div",{className:"chip-leg"},s.a.createElement("span",{className:"pin-number"},t))}),v=(i(23),Object(A.a)((function(e){var t=e.topic,i=Object(E.f)().activeGroup,n=i===t,r=i&&!n;return s.a.createElement(D.b,{to:"/topic/".concat(t),className:p("chip-topic",n&&"active-topic",r&&"inactive-topic"),onMouseEnter:function(){return w.setHighlightGroups([t])},onMouseLeave:function(){return w.setHighlightGroups([])},onClick:function(e){e.stopPropagation()}},t)}))),L=Object(E.g)((function(e){var t=w.pins,i=t.length/2,n=t.slice(0,i).map((function(e){var t=e.attributes.map((function(t,i){return s.a.createElement(y,{key:"attr-".concat(i),attribute:t,pin:e})}));return t.reverse(),s.a.createElement(f,{pin:e,key:"pin-".concat(e.pin)},t,s.a.createElement(I,{pin:e.pin}))})),r=t.slice(i,t.length).map((function(e){var t=e.attributes.map((function(t,i){return s.a.createElement(y,{key:i,attribute:t,pin:e})}));return s.a.createElement(f,{pin:e,key:"pin-".concat(e.pin)},s.a.createElement(I,{pin:e.pin}),t)})),a=w.chipTopics.map((function(e){return s.a.createElement(v,{key:e.topic,topic:e.topic})})),o=e.history;return s.a.createElement("div",{className:"model-row",onClick:function(){return o.push("/")}},s.a.createElement("div",{className:"model-row--left-column"},n),s.a.createElement("div",{className:"model-row--middle-column"},s.a.createElement("div",{className:"attiny"},s.a.createElement("div",{className:"pin1marker"}),a)),s.a.createElement("div",{className:"model-row--right-column"},r))})),P=i(19),x=(i(79),function(e){var t=e.registry,i=e.offset,n=(e.field,i?"".concat(t,".").concat(i):"".concat(t));return s.a.createElement("a",null,n)}),N=i(62),M=(i(80),i(18)),U=i.n(M),O=new U.a,B=function(e){var t=e.registry,i=e.offset,r=e.field,a=parseInt(r),o=0,l=Object(E.f)().activeGroup,c=Object(n.useState)(null),d=Object(P.a)(c,2),h=(d[0],d[1],null),u=i.fields.map((function(e,t){o+=e.size;var i=e.relatedGroups.includes(l)||r===e.name;i&&(h=e);var n=!e.name,a=e.size>1&&!n?"[".concat(7-o+e.size,":").concat(7-o+1,"]"):"",c=e.name?"".concat(e.name).concat(a):"";return s.a.createElement("div",{className:p("field-size-".concat(e.size),i&&"active",n&&"disabled"),key:c},c)})),f=[Object(N.a)(Array(o).keys()).map((function(e){return s.a.createElement("div",{className:p("field-size-1","bit-number",a===e&&"active"),key:"bit-".concat(e)},e)})).reverse(),u].map((function(e,t){return s.a.createElement("div",{key:"block-".concat(t),className:"block-row"},e)})),m="".concat(t.name,"_").concat(i.name," - ").concat(i.title);return s.a.createElement(s.a.Fragment,null,s.a.createElement("span",{className:"title"},m),s.a.createElement("div",{className:"registry-offset offset-fields"},f),h&&s.a.createElement("div",null,s.a.createElement("div",null,h.name," - ",h.title),s.a.createElement("div",{className:"field-description",dangerouslySetInnerHTML:{__html:O.render(h.description)}})))},F=(i(135),Object(A.a)((function(e){var t=e.registry,i=t.offsets.map((function(e,i){return s.a.createElement(B,{key:i,registry:t,offset:e})}));return s.a.createElement(s.a.Fragment,null,i)}))),V=function(e){var t=e.registry,i=e.page,n=t?w.getRegistryDatasheetLink(t):w.getDatasheetPageLink(i);return n?s.a.createElement("a",{href:n,target:"_blank",rel:"noopener noreferrer"},"\ud83d\uddce"):s.a.createElement("span",null,"(??? link ???)")},z=function(e){var t=w.getRegistry(e.registry);if(!t)return s.a.createElement("div",null,"Registry definition for '",e.registry,"' is missing");var i=t.offsets.find((function(t){return t.name===e.offset})),n=e.field,r=i?"".concat(t.name," > ").concat(i.name):t.name,a=s.a.createElement(V,{registry:t});return e.offset?s.a.createElement("div",{className:"registry"},s.a.createElement("div",null,s.a.createElement("span",{className:"title"},r," ",a),i&&s.a.createElement(B,{registry:t,offset:i,field:n}))):s.a.createElement("div",{className:"registry"},s.a.createElement("div",null,s.a.createElement("span",{className:"title"},r," ",a),s.a.createElement(F,{registry:t})))},W=i(32),k=(i(322),i(33)),H=i.n(k),K=function(e){var t=e.topic,i=w.getTopic(t);return i?s.a.createElement(D.b,{className:"topic-link",to:"/topic/".concat(t)},i.title):s.a.createElement("span",null,'"'.concat(t,'" (topic missing)'))},G=new U.a({highlight:function(e,t){if(t&&W.getLanguage(t))try{return W.highlight(t,e).value}catch(i){}return""},html:!0}),Y=Object(A.a)((function(e){var t=Object(E.f)().activeGroup,i=null;if(t){var n=w.getTopic(t);i=n?s.a.createElement(s.a.Fragment,null,s.a.createElement("h3",null,n.title),s.a.createElement("div",{className:"topic-text"},function(e){var t=[],i=G.render(e),n=H()(i,{transform:function e(i,n){if(i&&"reg"===i.name){var r=i.children[0].data.split("."),a=Object(P.a)(r,3),o=a[0],l=a[1],c=a[2];return t.push(s.a.createElement(z,{key:"registry-".concat(o,"-").concat(l,"-").concat(c),registry:o,offset:l,field:c})),s.a.createElement(x,{registry:o,offset:l,field:c})}return i&&"ref"===i.name?s.a.createElement(V,{page:i.children[0].data}):i&&"topic"===i.name?s.a.createElement(K,{topic:i.children[0].data}):i&&"example"===i.name?(i.name="div",i.attribs={class:"code-example"},Object(k.convertNodeToElement)(i,n,e)):void 0}});return s.a.createElement(s.a.Fragment,null,n,s.a.createElement("div",{className:"references"},t))}(n.text))):s.a.createElement("span",null,"Topic '",t,"' not found")}if(!i){var r=w.primaryHighlightGroup,a=w.getTopic(r);i=a?s.a.createElement("h3",null,a.title):null}return s.a.createElement("div",{className:"topic-view",onClick:function(e){return e.stopPropagation()}},s.a.createElement("div",null,i))}));function X(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText}var q=X(l.a),_=X(d.a);w.setPins(u.parse(q).pins),w.setTopics(u.parse(_).topics),w.setRegistries(h.regs);var Q=function(){return s.a.createElement(D.a,null,s.a.createElement("div",{className:"App"},s.a.createElement("h1",null,"ATtinyX14 Quick Reference"),s.a.createElement(E.c,null,s.a.createElement(E.a,{path:"/topic/:activeGroup?/:activePin?"},s.a.createElement(L,null),s.a.createElement(Y,null)),s.a.createElement(E.a,{path:"/"},s.a.createElement(L,null),s.a.createElement(Y,null))),s.a.createElement("div",{className:"data-row"})))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));a.a.render(s.a.createElement(Q,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(e){e.unregister()})).catch((function(e){console.error(e.message)}))},57:function(e,t,i){e.exports=i.p+"static/media/attinyx14-pins.febae19a.toml"},58:function(e,t,i){e.exports=i.p+"static/media/attinyx14-topics.e4c18e46.toml"},59:function(e){e.exports=JSON.parse('{"regs":[{"name":"GPIOR","datasheetPage":20,"offsets":[{"offset":"0x00","name":"GPIOR0","fields":[{"name":"GPIOR","size":8,"title":"GPIO Register byte"}],"title":"General Purpose I/O register n","description":"These are general purpose registers that can be used to store data, such as global variables and flags, in the\\nbitaccessible I/O memory space."},{"offset":"0x01","name":"GPIOR1","fields":[{"name":"GPIOR","size":8,"title":"GPIO Register byte"}],"title":"General Purpose I/O register n","description":"These are general purpose registers that can be used to store data, such as global variables and flags, in the\\nbitaccessible I/O memory space."},{"offset":"0x02","name":"GPIOR2","fields":[{"name":"GPIOR","size":8,"title":"GPIO Register byte"}],"title":"General Purpose I/O register n","description":"These are general purpose registers that can be used to store data, such as global variables and flags, in the\\nbitaccessible I/O memory space."},{"offset":"0x03","name":"GPIOR3","fields":[{"name":"GPIOR","size":8,"title":"GPIO Register byte"}],"title":"General Purpose I/O register n","description":"These are general purpose registers that can be used to store data, such as global variables and flags, in the\\nbitaccessible I/O memory space."}]},{"name":"SIGROW","datasheetPage":22,"offsets":[{"offset":"0x00","name":"DEVICEID0","fields":[{"name":"DEVICEID","size":8,"title":"Byte n of the Device ID"}],"title":"Device ID n","description":"Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\\nof three bytes: SIGROW.DEVICEID[2:0]."},{"offset":"0x01","name":"DEVICEID1","fields":[{"name":"DEVICEID","size":8,"title":"Byte n of the Device ID"}],"title":"Device ID n","description":"Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\\nof three bytes: SIGROW.DEVICEID[2:0]."},{"offset":"0x02","name":"DEVICEID2","fields":[{"name":"DEVICEID","size":8,"title":"Byte n of the Device ID"}],"title":"Device ID n","description":"Each device has a Device ID, identifying the device and its properties, such as memory sizes, pin count, and die\\nrevision. This can be used to identify a device and hence, the available features by software. The Device ID consists\\nof three bytes: SIGROW.DEVICEID[2:0]."},{"offset":"0x03","name":"SERNUM0","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x04","name":"SERNUM1","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x05","name":"SERNUM2","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x06","name":"SERNUM3","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x07","name":"SERNUM4","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x08","name":"SERNUM5","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x09","name":"SERNUM6","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x0A","name":"SERNUM7","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x0B","name":"SERNUM8","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x0C","name":"SERNUM9","fields":[{"name":"SERNUM","size":8,"title":"Serial Number Byte n"}],"title":"Serial Number Byte n","description":"Each device has an individual serial number, representing a unique ID. This can be used to identify a specific device\\nin the field. The serial number consists of ten bytes: SIGROW.SERNUM[9:0]."},{"offset":"0x20","name":"TEMPSENSE0","fields":[{"name":"TEMPSENSE","size":8,"title":"Temperature Sensor Calibration Byte n","description":"Refer to 30.3.2.6 Temperature Measurement for how to use the values; 6.9.2 Signature Row Description section for location of values."}],"title":"Temperature Sensor Calibration n","description":"These registers contain correction factors for temperature measurements by the ADC. SIGROW.TEMPSENSE0 is a\\ncorrection factor for the gain/slope (unsigned), SIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."},{"offset":"0x21","name":"TEMPSENSE1","fields":[{"name":"TEMPSENSE","size":8,"title":"Temperature Sensor Calibration Byte n","description":"Refer to 30.3.2.6 Temperature Measurement for how to use the values; 6.9.2 Signature Row Description section for location of values."}],"title":"Temperature Sensor Calibration n","description":"These registers contain correction factors for temperature measurements by the ADC. SIGROW.TEMPSENSE0 is a\\ncorrection factor for the gain/slope (unsigned), SIGROW.TEMPSENSE1 is a correction factor for the offset (signed)."},{"offset":"0x22","name":"OSC16ERR3V","fields":[{"name":"OSC16ERR3V","size":8,"title":"OSC16 error at 3V","description":"This registers contain the signed oscillator frequency error value when running at internal 16MHz at 3V, as measured during production."}],"title":"OSC16 error at 3V","description":null},{"offset":"0x23","name":"OSC16ERR5V","fields":[{"name":"OSC16ERR5V","size":8,"title":"OSC16 error at 5V","description":"This registers contain the signed oscillator frequency error value when running at internal 16MHz at 5V, as measured during production."}],"title":"OSC16 error at 5V","description":null},{"offset":"0x24","name":"OSC20ERR3V","fields":[{"name":"OSC20ERR3V","size":8,"title":"OSC20 error at 3V","description":"This registers contain the signed oscillator frequency error value when running at internal 20MHz at 3V, as measured during production."}],"title":"OSC20 error at 3V","description":null},{"offset":"0x25","name":"OSC20ERR5V","fields":[{"name":"OSC20ERR5V","size":8,"title":"OSC20 error at 5V","description":"This registers contain the signed oscillator frequency error value when running at internal 20MHz at 5V, as measured during production."}],"title":"OSC20 error at 5V","description":null}]},{"name":"FUSE","datasheetPage":30,"offsets":[{"offset":"0x00","name":"WDTCFG","fields":[{"name":"WINDOW","size":4,"title":"Watchdog Window Timeout Period","description":"This value is loaded into the WINDOW bit field of the Watchdog Control A register (WDT.CTRLA) during Reset."},{"name":"PERIOD","size":4,"title":"Watchdog Timeout Period","description":"This value is loaded into the PERIOD bit field of the Watchdog Control A register (WDT.CTRLA) during Reset."}],"title":"Watchdog Configuration","description":null},{"offset":"0x01","name":"BODCFG","fields":[{"name":"LVL","size":3,"title":"BOD Level","description":"This value is loaded into the LVL bit field of the BOD Control B register (BOD.CTRLB) during Reset. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|BODLEVEL0|1.8V |\\n | 0x2|BODLEVEL2|2.6V |\\n | 0x7|BODLEVEL7|4.2V\\nNote:\\n\u2022 Values in the description are typical values.\\n\u2022 Refer to the BOD and POR Characteristics in Electrical Characteristics for maximum and minimum values. |\\n"},{"name":"SAMPFREQ","title":"BOD Sample Frequency","description":"This value is loaded into the SAMPFREQ bit of the BOD Control A register (BOD.CTRLA) during Reset. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Sample frequency is 1 kHz |\\n | 0x1|Sample frequency is 125 Hz |\\n"},{"name":"ACTIVE","size":2,"title":"BOD Operation Mode in Active and Idle","description":"This value is loaded into the ACTIVE bit field of the BOD Control A register (BOD.CTRLA) during Reset. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Disabled |\\n | 0x1|Enabled |\\n | 0x2|Sampled |\\n | 0x3|Enabled with wake-up halted until BOD is ready |\\n"},{"name":"SLEEP","size":2,"title":"BOD Operation Mode in Sleep","description":"This value is loaded into the SLEEP bit field of the BOD Control A register (BOD.CTRLA) during Reset. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Disabled |\\n | 0x1|Enabled |\\n | 0x2|Sampled |\\n | 0x3|Reserved |\\n"}],"title":"BOD Configuration","description":"The settings of the BOD will be reloaded from this Fuse after a Power-on Reset. For all other Resets, the BOD\\nconfiguration remains unchanged."},{"offset":"0x02","name":"OSCCFG","fields":[{"name":"OSCLOCK","title":"Oscillator Lock","description":"This fuse bit is loaded to LOCK in CLKCTRL.OSC20MCALIBB during reset. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Calibration registers of the 20 MHz oscillator are accessible |\\n | 1|Calibration registers of the 20 MHz oscillator are locked |\\n"},{"size":5},{"name":"FREQSEL","size":2,"title":"Frequency Select","description":"These bits selects the operation frequency of the 16/20MHz internal oscillator (OSC20M), and determine the respective factory calibration values to be written to CAL20M in CLKCTRL.OSC20MCALIBA and TEMPCAL20M in CLKCTRL.OSC20MCALIBB. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x1|Run at 16MHz with corresponding factory calibration |\\n | 0x2|Run at 20MHz with corresponding factory calibration\\nOther Reserved |\\n"}],"title":"Oscillator Configuration","description":null},{"offset":"0x04","name":"TCD0CFG","fields":[{"name":"CMPDEN"},{"name":"CMPCEN"},{"name":"CMPBEN"},{"name":"CMPAEN"},{"name":"CMPD"},{"name":"CMPC"},{"name":"CMPB"},{"name":"CMPA"}],"title":"Timer Counter Type D Configuration","description":"The bit values of this fuse register are written to the corresponding bits in the TCD.FAULTCTRL register of TCD0 at\\nstart-up.\\nThe CMPEN and CMP settings of the TCD will only be reloaded from the FUSE values after a Power-On Reset. For\\nall other resets the corresponding TCD settings of the device will remain unchanged."},{"offset":"0x05","name":"SYSCFG0","fields":[{"name":"CRCSRC","size":2,"title":"CRC Source","description":"See the CRC description for more information about the functionality. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 00|FLASH|CRC of full Flash (boot, application code and application data) |\\n | 01|BOOT|CRC of the boot section |\\n | 10|BOOTAPP|CRC of application code and boot sections |\\n | 11|NOCRC|No CRC |\\n"},{"size":2},{"name":"RSTPINCFG","size":2,"title":"Reset Pin Configuration","description":"These bits select the Reset/UPDI pin configuration. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|GPIO |\\n | 0x1|UPDI |\\n | 0x2|RESET |\\n | 0x3|Reserved\\nNote:\u2000 When configuring the Reset Pin as GPIO, there is a potential conflict between the GPIO actively driving the\\noutput, and a 12V UPDI enable sequence initiation. To avoid this, the GPIO output driver is disabled for 768 OSC32K\\ncycles after a System Reset. Enable any interrupts for this pin only after this period. |\\n"},{},{"name":"EESAVE","title":"EEPROM Save During Chip Erase","description":"If the device is locked, the EEPROM is always erased by a chip erase, regardless of this bit. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|EEPROM erased during chip erase |\\n | 1|EEPROM not erased under chip erase |\\n"}],"title":"System Configuration 0","description":null},{"offset":"0x06","name":"SYSCFG1","fields":[{"size":5},{"name":"SUT","size":3,"title":"Start Up Time Setting","description":"These bits selects the start-up time between power-on and code execution. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|0ms |\\n | 0x1|1ms |\\n | 0x2|2ms |\\n | 0x3|4ms |\\n | 0x4|8ms |\\n | 0x5|16ms |\\n | 0x6|32ms |\\n | 0x7|64ms |\\n"}],"title":"System Configuration 1","description":null},{"offset":"0x07","name":"APPEND","fields":[{"name":"APPEND","size":8,"title":"Application Code Section End","description":"These bits set the end of the application code section in blocks of 256 bytes. The end of the application code section should be set as BOOT size + application code size. The remaining Flash will be application data. A value of 0x00 defines the Flash from BOOTEND*256 to end of Flash as application code. When both FUSE.APPEND and FUSE.BOOTEND are 0x00, the entire Flash is BOOT section."}],"title":"Application Code End","description":null},{"offset":"0x08","name":"BOOTEND","fields":[{"name":"BOOTEND","size":8,"title":"Boot Section End","description":"These bits set the end of the boot section in blocks of 256 bytes. A value of 0x00 defines the whole Flash as BOOT section. When both FUSE.APPEND and FUSE.BOOTEND are 0x00, the entire Flash is BOOT section."}],"title":"Boot End","description":null},{"offset":"0x0A","name":"LOCKBIT","fields":[{"name":"LOCKBIT","size":8,"title":"Lock Bits","description":"When the part is locked, UPDI cannot access the system bus, so it cannot read out anything but CS-space. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0xC5|The device is open\\nother The device is locked |\\n"}],"title":"Lock Bits","description":null}]},{"name":"SYSCFG","datasheetPage":43,"offsets":[{"offset":"0x01","name":"REVID","fields":[{"name":"REVID","size":8,"title":"Revision ID","description":"These bits contain the device revision. 0x00 = A, 0x01 = B, and so on."}],"title":"Device Revision ID Register","description":"This register is read only and give the device revision ID."}]},{"name":"CPU","datasheetPage":52,"offsets":[{"offset":"0x04","name":"CCP","fields":[{"name":"CCP","size":8,"title":"Configuration Change Protection","description":"Writing the correct signature to this bit field allows changing protected I/O registers or executing protected instructions within the next four CPU instructions executed. All interrupts are ignored during these cycles. After these cycles, interrupts will automatically be handled again by the CPU, and any pending interrupts will be executed according to their level and priority. When the protected I/O register signature is written, CCP[0] will read as \'1\' as long as the CCP feature is enabled. When the protected self-programming signature is written, CCP[1] will read as \'1\' as long as the CCP feature is enabled. CCP[7:2] will always read as zero. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x9D|SPM|Allow Self-Programming |\\n | 0xD8|IOREG|Un-protect protected I/O registers |\\n"}],"title":"Configuration Change Protection","description":null},{"offset":"0x0D","name":"SP","fields":[{"name":"SP","size":8,"title":"Stack Pointer low byte","description":"These bits hold the LSB of the 16-bit register."},{"name":"SP","size":8,"title":"Stack Pointer low byte","description":"These bits hold the LSB of the 16-bit register."}],"title":"Stack Pointer","description":"The CPU.SP holds the Stack Pointer (SP) that points to the top of the Stack. After Reset, the Stack Pointer points to\\nthe highest internal SRAM address.\\nOnly the number of bits required to address the available data memory including external memory (up to 64KB) is\\nimplemented for each device. Unused bits will always read as zero.\\nThe CPU.SPL and CPU.SPH register pair represents the 16-bit value, CPU.SP. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nTo prevent corruption when updating the Stack Pointer from software, a write to CPU.SPL will automatically disable\\ninterrupts for the next four instructions or until the next I/O memory write."},{"offset":"0x0F","name":"SREG","fields":[{"name":"I","title":"Global Interrupt Enable","description":"Writing a \'1\' to this bit enable interrupts on the device. Writing a \'0\' to this bit disables interrupts on the device, independent of the individual interrupt enable settings of the peripherals. This bit is not cleared by hardware after an interrupt has occurred. This bit can be set and cleared by software with the SEI and CLI instructions. Changing the I flag through the I/O-register result in a one-cycle wait state on the access."},{"name":"T","title":"Bit Copy Storage","description":"The bit copy instructions bit load (BLD) and bit store (BST) use the T bit as source or destination for the operated bit. A bit from a register in the register file can be copied into this bit by the BST instruction, and this bit can be copied into a bit in a register in the register file by the BLD instruction."},{"name":"H","title":"Half Carry Flag","description":"This bit indicates a half carry in some arithmetic operations. Half carry is useful in BCD arithmetic."},{"name":"S","title":"Sign Bit, S = N \u2295 V","description":"The sign bit (S) is always an exclusive or (xor) between the negative flag (N) and the two\u2019s complement overflow flag (V)."},{"name":"V","title":"Two\u2019s Complement Overflow Flag","description":"The two\u2019s complement overflow flag (V) supports two\u2019s complement arithmetic."},{"name":"N","title":"Negative Flag","description":"The negative flag (N) indicates a negative result in an arithmetic or logic operation."},{"name":"Z","title":"Zero Flag","description":"The zero flag (Z) indicates a zero result in an arithmetic or logic operation."},{"name":"C","title":"Carry Flag","description":"The carry flag (C) indicates a carry in an arithmetic or logic operation."}],"title":"Status Register","description":"The Status register contains information about the result of the most recently executed arithmetic or logic instruction.\\nFor details about the bits in this register and how they are affected by the different instructions, see the Instruction Set\\nSummary."}]},{"name":"NVMCTRL","datasheetPage":63,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":5},{"name":"CMD","size":3,"title":"Command","description":"Write this bit field to issue a command. The Configuration Change Protection key for self-programming (SPM) has to be written within four instructions before this write. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|-|No command |\\n | 0x1|WP|Write page buffer to memory (NVMCTRL.ADDR selects which memory) |\\n | 0x2|ER|Erase page (NVMCTRL.ADDR selects which memory) |\\n | 0x3|ERWP|Erase and write page (NVMCTRL.ADDR selects which memory) |\\n | 0x4|PBC|Page buffer clear |\\n | 0x5|CHER|Chip erase: erase Flash and EEPROM (unless EESAVE in FUSE.SYSCFG is \'1\') |\\n | 0x6|EEER|EEPROM Erase |\\n | 0x7|WFU|Write fuse (only accessible through UPDI) |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":6},{"name":"BOOTLOCK","title":"Boot Section Lock","description":"Writing a \'1\' to this bit locks the boot section from read and instruction fetch. If this bit is \'1\', a read from the boot section will return \'0\'. A fetch from the boot section will also return 0 as instruction. This bit can only be written from the boot section. It can only be cleared to \'0\' by a Reset. This bit will only take effect when the boot section is left the first time after the bit is written."},{"name":"APCWP","title":"Application Code Section Write Protection","description":"Writing a \'1\' to this bit protects the application code section from further writes. This bit can only be written to \'1\', it is cleared to \'0\' only by Reset."}],"title":"Control B","description":null},{"offset":"0x02","name":"STATUS","fields":[{"size":5},{"name":"WRERROR","title":"Write Error","description":"This bit will read \'1\' when a write error has happened. A write error could be writing to different sections before doing a page write or writing to a protected area. This bit is valid for the last operation."},{"name":"EEBUSY","title":"EEPROM Busy","description":"This bit will read \'1\' when the EEPROM is busy with a command."},{"name":"FBUSY","title":"Flash Busy","description":"This bit will read \'1\' when the Flash is busy with a command."}],"title":"Status","description":null},{"offset":"0x03","name":"INTCTRL","fields":[{"size":7},{"name":"EEREADY","title":"EEPROM Ready Interrupt","description":"Writing a \'1\' to this bit enables the interrupt which indicates that the EEPROM is ready for new write/erase operations. This is a level interrupt that will be triggered only when the EEREADY flag in the INTFLAGS register is set to zero. Thus, the interrupt should not be enabled before triggering an NVM command, as the EEREADY flag will not be set before the NVM command issued. The interrupt should be disabled in the interrupt handler."}],"title":"Interrupt Control","description":null},{"offset":"0x04","name":"INTFLAGS","fields":[{"size":7},{"name":"EEREADY","title":"EEREADY Interrupt Flag","description":"Interrupt flag for the EEPROM interrupt. This bit is cleared by writing a \'1\' to it. When this interrupt is enabled, it will immediately request an interrupt, and it will continue to request interrupts continuously - even if no EEPROM writes are initiated."}],"title":"Interrupt Flags","description":null},{"offset":"0x06","name":"DATA","fields":[{"name":"DATA","size":8},{"name":"DATA","size":8}],"title":"Data","description":"The NVMCTRL.DATAL and NVMCTRL.DATAH register pair represents the 16-bit value, NVMCTRL.DATA. The low\\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\\n+ 0x01. For more details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x08","name":"ADDR","fields":[{"name":"ADDR","size":8},{"name":"ADDR","size":8}],"title":"Address","description":"The NVMCTRL.ADDRL and NVMCTRL.ADDRH register pair represents the 16-bit value, NVMCTRL.ADDR. The low\\nbyte [7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset\\n+ 0x01. For more details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."}]},{"name":"CLKCTRL","datasheetPage":78,"offsets":[{"offset":"0x00","name":"MCLKCTRLA","fields":[{"size":6},{"name":"CLKSEL","size":2,"title":"Clock Select","description":"This bit field selects the source for the Main Clock (CLK_MAIN). \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OSC20M|16/20 MHz internal oscillator |\\n | 0x1|OSCULP32K|32 KHz internal ultra low-power oscillator |\\n | 0x2|XOSC32K|32.768 kHz external crystal oscillator |\\n | 0x3|EXTCLK|External clock |\\n"}],"title":"Main Clock Control A","description":null},{"offset":"0x01","name":"MCLKCTRLB","fields":[{"size":3},{"name":"PDIV","size":4,"title":"Prescaler Division","description":"If the Prescaler Enable (PEN) bit is written to \'1\', these bits define the division ratio of the Main Clock prescaler. These bits can be written during run-time to vary the clock frequency of the system to suit the application requirements. User software must ensure a correct configuration of input frequency (CLK_MAIN) and Prescaler settings, such that the resulting frequency of CLK_PER never exceeds the allowed maximum (see Electrical Characteristics). \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|2 |\\n | 0x1|4 |\\n | 0x2|8 |\\n | 0x3|16 |\\n | 0x4|32 |\\n | 0x5|64 |\\n | 0x8|6 |\\n | 0x9|10 |\\n | 0xA|12 |\\n | 0xB|24 |\\n | 0xC|48\\nother Reserved |\\n"},{"name":"PEN","title":"Prescaler Enable","description":"This bit must be written \'1\' to enable the prescaler. When enabled, the division ratio is selected by the PDIV bit field. When this bit is written to \'0\', the Main Clock will pass through undivided (CLK_PER=CLK_MAIN), regardless of the value of PDIV."}],"title":"Main Clock Control B","description":null},{"offset":"0x02","name":"MCLKLOCK","fields":[{"size":7},{"name":"LOCKEN","title":"Lock Enable","description":"Writing this bit to \'1\' will lock the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers, and, if applicable, the calibration settings for the current Main Clock source from further software updates. Once locked, the CLKCTRL.MCLKLOCK registers cannot be accessed until the next hardware Reset. This provides protection for the CLKCTRL.MCLKCTRLA and CLKCTRL.MCLKCTRLB registers and calibration settings for the Main Clock source from unintentional modification by software."}],"title":"Main Clock Lock","description":null},{"offset":"0x03","name":"MCLKSTATUS","fields":[{"name":"EXTS","title":"External Clock Status","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|EXTCLK has not started |\\n | 1|EXTCLK has started |\\n"},{"name":"XOSC32KS","title":"XOSC32K Status","description":"The status bit will only be available if the source is requested as the main clock or by another module. If the oscillators RUNSTDBY bit is set but the oscillator is unused/not requested this bit will be 0. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|XOSC32K is not stable |\\n | 1|XOSC32K is stable |\\n"},{"name":"OSC32KS","title":"OSCULP32K Status","description":"The status bit will only be available if the source is requested as the main clock or by another module. If the oscillators RUNSTDBY bit is set but the oscillator is unused/not requested this bit will be 0. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|OSCULP32K is not stable |\\n | 1|OSCULP32K is stable |\\n"},{"name":"OSC20MS","title":"OSC20M Status","description":"The status bit will only be available if the source is requested as the main clock or by another module. If the oscillators RUNSTDBY bit is set but the oscillator is unused/not requested this bit will be 0. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|OSC20M is not stable |\\n | 1|OSC20M is stable |\\n"},{"size":3},{"name":"SOSC","title":"Main Clock Oscillator Changing","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The clock source for CLK_MAIN is not undergoing a switch. |\\n | 1|The clock source for CLK_MAIN is undergoing a switch, and will change as soon as the new source is\\nstable. |\\n"}],"title":"Main Clock Status","description":null},{"offset":"0x10","name":"OSC20MCTRLA","fields":[{"size":7},{"name":"RUNSTDBY","title":"Run Standby","description":"This bit force the oscillator on in all modes, even when unused by the system. In standby sleep mode this can be used to ensure immediate wake-up and not waiting for oscillator start-up time. When not requested by peripherals, no oscillator output is provided. It takes 4 oscillator cycles to open the clock gate after a request but the oscillator analog start-up time will be removed when this bit is set."}],"title":"16/20MHz Oscillator Control A","description":null},{"offset":"0x11","name":"OSC20MCALIBA","fields":[{"size":2},{"name":"CAL20M","size":6,"title":"Calibration","description":"These bits change the frequency around the current center frequency of the OSC20M for fine tuning. At Reset factory calibrated values are loaded based on FREQSEL bits in FUSE.OSCCFG."}],"title":"16/20MHz Oscillator Calibration A","description":null},{"offset":"0x12","name":"OSC20MCALIBB","fields":[{"size":3},{"name":"LOCK","title":"Oscillator Calibration Locked by Fuse","description":"When this bit is set, the calibration settings in CLKCTRL.OSC20MCALIBA and CLKCTRL.OSC20MCALIBB cannot be changed. The Reset value is loaded from the OSCLOCK bit in the Oscillator Configuration fuse (FUSE.OSCCFG)."},{"name":"TEMPCAL20M","size":4,"title":"Oscillator Temperature Coefficient Calibration","description":"These bits tune the slope of the temperature compensation. At Reset factory calibrated values are loaded based on FREQSEL bits in FUSE.OSCCFG."}],"title":"16/20MHz Oscillator Calibration B","description":null},{"offset":"0x18","name":"OSC32KCTRLA","fields":[{"size":7},{"name":"RUNSTDBY","title":"Run Standby","description":"This bit force the oscillator on in all modes, even when unused by the system. In standby sleep mode this can be used to ensure immediate wake-up and not waiting for oscillator start-up time. When not requested by peripherals, no oscillator output is provided. It takes 4 oscillator cycles to open the clock gate after a request but the oscillator analog start-up time will be removed when this bit is set."}],"title":"32KHz Oscillator Control A","description":null},{"offset":"0x1C","name":"XOSC32KCTRLA","fields":[{"size":3},{"name":"CSUT","size":2,"title":"Crystal Start-Up Time","description":"These bits select the start-up time for the XOSC32K. It is write protected when the oscillator is enabled (ENABLE=1). If SEL=1, the start-up time will not be applied. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|1K|1k cycles |\\n | 0x1|16K|16k cycles |\\n | 0x2|32K|32k cycles |\\n | 0x3|64K|64k cycles |\\n"},{"name":"SEL","title":"Source Select","description":"This bit select the external source type. It is write protected when the oscillator is enabled (ENABLE=1). \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|External crystal |\\n | 1|External clock on TOSC1 pin |\\n"},{"name":"RUNSTDBY","title":"Run Standby","description":"Writing this bit to \'1\' starts the crystal oscillator and forces the oscillator on in all modes, even when unused by the system if the ENABLE bit is set. In standby sleep mode this can be used to ensure immediate wake-up and not waiting for oscillator start-up time. When this bit is \'0\', the crystal oscillator is only running when requested and the ENABLE bit is set. The output of XOSC32K is not sent to other peripherals unless it is requested by one or more peripherals. When the RUNSTDBY bit is set there will only be a delay of two to three crystal oscillator cycles after a request until the oscillator output is received, if the initial crystal start-up time already has completed. According to RUNSTBY bit, the oscillator will be turned on all the time if the device is in Active, Idle or Standby sleep mode, or only be enabled when requested. This bit is I/O protected to prevent unintentional enabling of the oscillator."},{"name":"ENABLE","title":"Enable","description":"When this bit is written to \'1\', the configuration of the respective input pins is overridden to TOSC1 and TOSC2. Also, the Source Select bit (SEL) and Crystal Start-Up Time (CSUT) become read-only. This bit is I/O protected to prevent unintentional enabling of the oscillator."}],"title":"32.768kHz Crystal Oscillator Control A","description":"The SEL and CSUT bits cannot be changed as long as the ENABLE bit is set or the XOSC32K Stable bit\\n(XOSC32KS) in CLKCTRL.MCLKSTATUS is high.\\nTo change settings in a safe way: write a \'0\' to the ENABLE bit and wait until XOSC32KS is \'0\' before re-enabling the\\nXOSC32K with new settings."}]},{"name":"SLPCTRL","datasheetPage":92,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":5},{"name":"SMODE","size":2,"title":"Sleep Mode","description":"Writing these bits selects the sleep mode entered when the Sleep Enable bit (SEN) is written to \'1\' and the SLEEP instruction is executed. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|IDLE|Idle sleep mode enabled |\\n | 0x1|STANDBY|Standby sleep mode enabled |\\n | 0x2|PDOWN|Power Down sleep mode enabled\\nother - Reserved |\\n"},{"name":"SEN","title":"Sleep Enable","description":"This bit must be written to \'1\' before the SLEEP instruction is executed to make the MCU enter the selected sleep mode."}],"title":"Control A","description":null}]},{"name":"RSTCTRL","datasheetPage":97,"offsets":[{"offset":"0x00","name":"RSTFR","fields":[{"size":2},{"name":"UPDIRF","title":"UPDI Reset Flag","description":"This bit is set if a UPDI Reset occurs."},{"name":"SWRF","title":"Software Reset Flag","description":"This bit is set if a Software Reset occurs."},{"name":"WDRF","title":"Watchdog Reset Flag","description":"This bit is set if a Watchdog Reset occurs."},{"name":"EXTRF","title":"External Reset Flag","description":"This bit is set if an External reset occurs."},{"name":"BORF","title":"Brownout Reset Flag","description":"This bit is set if a Brownout Reset occurs."},{"name":"PORF","title":"Power-On Reset Flag","description":"This bit is set if a Power-on Reset occurs. This flag is only cleared by writing a \'1\' it. After a POR, only the POR flag is set and all other flags are cleared. No other flag can be set before a full system boot is run after the POR."}],"title":"Reset Flag Register","description":"All flags are cleared by writing a \'1\' to them. They are also cleared by a Power-on Reset, with the exception of the\\nPower-On Reset Flag (PORF)."},{"offset":"0x01","name":"SWRR","fields":[{"size":7},{"name":"SWRE","title":"Software Reset Enable","description":"When this bit is written to \'1\', a software reset will occur. This bit will always read as \'0\'."}],"title":"Software Reset Register","description":null}]},{"name":"CPUINT","datasheetPage":107,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"IVSEL","title":"Interrupt Vector Select","description":"If boot section is defined, it will be placed before application section. The actual start address of the application section is determined by the BOOTEND Fuse. This bit is protected by the Configuration Change Protection mechanism. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Interrupt vectors are placed at the start of the application section of the Flash. |\\n | 1|Interrupt vectors are placed at the start of the boot section of the Flash. |\\n"},{"name":"CVT","title":"Compact Vector Table","description":"This bit is protected by the Configuration Change Protection mechanism. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Compact Vector Table function is disabled |\\n | 1|Compact Vector Table function is enabled |\\n"},{"size":4},{"name":"LVL0RR","title":"Round-Robin Priority Enable","description":"This bit is not protected by the Configuration Change Protection mechanism. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Priority is fixed for priority level 0 interrupt requests: The lowest interrupt vector address has highest\\npriority. |\\n | 1|Round Robin priority scheme is enabled for priority level 0 interrupt requests. |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"STATUS","fields":[{"name":"NMIEX","title":"Non-Maskable Interrupt Executing","description":"This flag is set if a non-maskable interrupt is executing. The flag is cleared when returning (RETI) from the interrupt handler."},{"size":5},{"name":"LVL1EX","title":"Level 1 Interrupt Executing","description":"This flag is set when a priority level 1 interrupt is executing, or when the interrupt handler has been interrupted by an NMI. The flag is cleared when returning (RETI) from the interrupt handler."},{"name":"LVL0EX","title":"Level 0 Interrupt Executing","description":"This flag is set when a priority level 0 interrupt is executing, or when the interrupt handler has been interrupted by a priority level 1 interrupt or an NMI. The flag is cleared when returning (RETI) from the interrupt handler."}],"title":"Status","description":null},{"offset":"0x02","name":"LVL0PRI","fields":[{"name":"LVL0PRI","size":8,"title":"Interrupt Priority Level 0","description":"When Round Robin is enabled (LVL0RR bit in CPUINT.CTRLA is \'1\'), this bit field stores the vector of the last acknowledged priority level 0 (LVL0) interrupt. The stored vector will have the lowest priority next time one or more LVL0 interrupts are pending. If Round Robin is disabled (LVL0RR in CPUINT.CTRLA is \'0\'), the vector address based priority scheme (lowest address has highest priority) is governing the priorities of LVL0 interrupt requests. If a system Reset is asserted, the lowest interrupt vector address will have highest priority within the LVL0."}],"title":"Interrupt Priority Level 0","description":null},{"offset":"0x03","name":"LVL1VEC","fields":[{"name":"LVL1VEC","size":8,"title":"Interrupt Vector with Priority Level 1","description":"This bit field contains the address of the single vector with increased priority level 1 (LVL1). If this bit field has the value 0x00, no vector has LVL1. Consequently, the LVL1 interrupt is disabled."}],"title":"Interrupt Vector with Priority Level 1","description":null}]},{"name":"EVSYS","datasheetPage":117,"offsets":[{"offset":"0x00","name":"ASYNCSTROBE","fields":[{"name":"ASYNCSTROBE","size":8,"title":"Asynchronous Channel Strobe","description":"If the strobe register location is written, each Event channel will be inverted for one system clock cycle, i.e. a single Event is generated."}],"title":"Asynchronous Channel Strobe","description":null},{"offset":"0x01","name":"SYNCSTROBE","fields":[{"name":"SYNCSTROBE","size":8,"title":"Synchronous Channel Strobe","description":"If the strobe register location is written, each Event channel will be inverted for one system clock cycle, i.e. a single event is generated."}],"title":"Synchronous Channel Strobe","description":null},{"offset":"0x02","name":"ASYNCCH0","fields":[{"name":"ASYNCCH","size":8,"title":"Asynchronous Channel Generator Selection","description":"Table 14-2.\u2000Asynchronous Channel Generator selection Value ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"}],"title":"Asynchronous Channel n Generator Selection","description":null},{"offset":"0x03","name":"ASYNCCH1","fields":[{"name":"ASYNCCH","size":8,"title":"Asynchronous Channel Generator Selection","description":"Table 14-2.\u2000Asynchronous Channel Generator selection Value ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"}],"title":"Asynchronous Channel n Generator Selection","description":null},{"offset":"0x04","name":"ASYNCCH2","fields":[{"name":"ASYNCCH","size":8,"title":"Asynchronous Channel Generator Selection","description":"Table 14-2.\u2000Asynchronous Channel Generator selection Value ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"}],"title":"Asynchronous Channel n Generator Selection","description":null},{"offset":"0x05","name":"ASYNCCH3","fields":[{"name":"ASYNCCH","size":8,"title":"Asynchronous Channel Generator Selection","description":"Table 14-2.\u2000Asynchronous Channel Generator selection Value ASYNCCH0 ASYNCCH1 ASYNCCH2 ASYNCCH3"}],"title":"Asynchronous Channel n Generator Selection","description":null},{"offset":"0x0A","name":"SYNCCH0","fields":[{"name":"SYNCCH","size":8,"title":"Synchronous Channel Generator Selection","description":"Table 14-3.\u2000Synchronous Channel Generator selection Value SYNCCH0 SYNCCH1"}],"title":"Synchronous Channel n Generator Selection","description":null},{"offset":"0x0B","name":"SYNCCH1","fields":[{"name":"SYNCCH","size":8,"title":"Synchronous Channel Generator Selection","description":"Table 14-3.\u2000Synchronous Channel Generator selection Value SYNCCH0 SYNCCH1"}],"title":"Synchronous Channel n Generator Selection","description":null},{"offset":"0x12","name":"ASYNCUSER0","fields":[{"name":"ASYNCUSER","size":8,"title":"Asynchronous User Channel Selection","description":"Table 14-4.\u2000User Multiplexer Numbers USERn User Multiplexer Description n=0 TCB0 Timer/Counter B 0 n=1 ADC0 ADC 0 n=2 CCL_LUT0EV0 CCL LUT0 Event 0 n=3 CCL_LUT1EV0 CCL LUT1 Event 0 n=4 CCL_LUT0EV1 CCL LUT0 Event 1 n=5 CCL_LUT1EV1 CCL LUT1 Event 1 n=6 TCD0_EV0 Timer Counter D 0 Event 0 n=7 TCD0_EV1 Timer Counter D 0 Event 1 n=8 EVOUT0 Event OUT 0 n=9 EVOUT1 Event OUT 1 n=10 EVOUT2 Event OUT 2 \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|OFF |\\n | 0x1|SYNCCH0 |\\n | 0x2|SYNCCH1 |\\n | 0x3|ASYNCCH0 |\\n | 0x4|ASYNCCH1 |\\n | 0x5|ASYNCCH2 |\\n | 0x6|ASYNCCH3 |\\n"}],"title":"Asynchronous User Channel n Input Selection","description":null},{"offset":"0x22","name":"SYNCUSER0","fields":[{"name":"SYNCUSER","size":8,"title":"Synchronous User Channel Selection","description":"Table 14-5.\u2000User Multiplexer Numbers USERn User Multiplexer Description n=0 TCA0 Timer/Counter A n=1 USART0 USART Value Name"}],"title":"Synchronous User Channel n Input Selection","description":null},{"offset":"0x23","name":"SYNCUSER1","fields":[{"name":"SYNCUSER","size":8,"title":"Synchronous User Channel Selection","description":"Table 14-5.\u2000User Multiplexer Numbers USERn User Multiplexer Description n=0 TCA0 Timer/Counter A n=1 USART0 USART Value Name"}],"title":"Synchronous User Channel n Input Selection","description":null}]},{"name":"PORTMUX","datasheetPage":125,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":6},{"name":"EVOUT1","title":"Event Output 1","description":"Write this bit to \'1\' to enable event output 1."},{"name":"EVOUT0","title":"Event Output 0","description":"Write this bit to \'1\' to enable event output 0."}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":3},{"name":"TWI0","title":"TWI 0 communication","description":"Write this bit to \'1\' to select alternative communication pins for TWI 0."},{},{"name":"SPI0","title":"SPI 0 communication","description":"Write this bit to \'1\' to select alternative communication pins for SPI 0. Note:\u2000 Not available on ATtiny814"},{},{"name":"USART0","title":"USART 0 communication","description":"Write this bit to \'1\' to select alternative communication pins for USART 0."}],"title":"Control B","description":null},{"offset":"0x02","name":"CTRLC","fields":[{"size":7},{"name":"TCA00","title":"TCA0 Waveform output 0","description":"Write this bit to \'1\' to select alternative output pin for TCA0 waveform output 0. In Split Mode, this bit controls output from low-byte compare channel 0."}],"title":"Control C","description":null}]},{"name":"PORT","datasheetPage":135,"offsets":[{"offset":"0x00","name":"DIR","fields":[{"name":"DIR","size":8,"title":"Data Direction","description":"This bit field selects the data direction for the individual pins n of the Port. Writing a \'1\' to PORT.DIR[n] configures and enables pin n as output pin. Writing a \'0\' to PORT.DIR[n] configures pin n as input pin. It can be configured by writing to the ISC bit in PORT.PINnCTRL."}],"title":"Data Direction","description":null},{"offset":"0x01","name":"DIRSET","fields":[{"name":"DIRSET","size":8,"title":"Data Direction Set","description":"This bit field can be used instead of a read-modify-write to set individual pins as output. Writing a \'1\' to DIRSET[n] will set the corresponding PORT.DIR[n] bit. Reading this bit field will always return the value of PORT.DIR."}],"title":"Data Direction Set","description":null},{"offset":"0x02","name":"DIRCLR","fields":[{"name":"DIRCLR","size":8,"title":"Data Direction Clear","description":"This register can be used instead of a read-modify-write to configure individual pins as input. Writing a \'1\' to DIRCLR[n] will clear the corresponding bit in PORT.DIR. Reading this bit field will always return the value of PORT.DIR."}],"title":"Data Direction Clear","description":null},{"offset":"0x03","name":"DIRTGL","fields":[{"name":"DIRTGL","size":8,"title":"Data Direction Toggle","description":"This bit field can be used instead of a read-modify-write to toggle the direction of individual pins. Writing a \'1\' to DIRTGL[n] will toggle the corresponding bit in PORT.DIR. Reading this bit field will always return the value of PORT.DIR."}],"title":"Data Direction Toggle","description":null},{"offset":"0x04","name":"OUT","fields":[{"name":"OUT","size":8,"title":"Output Value","description":"This bit field defines the data output value for the individual pins n of the port. If OUT[n] is written to \'1\', pin n is driven high. If OUT[n] is written to \'0\', pin n is driven low. In order to have any effect, the pin direction must be configured as output."}],"title":"Output Value","description":null},{"offset":"0x05","name":"OUTSET","fields":[{"name":"OUTSET","size":8,"title":"Output Value Set","description":"This bit field can be used instead of a read-modify-write to set the output value of individual pins to \'1\'. Writing a \'1\' to OUTSET[n] will set the corresponding bit in PORT.OUT. Reading this bit field will always return the value of PORT.OUT."}],"title":"Output Value Set","description":null},{"offset":"0x06","name":"OUTCLR","fields":[{"name":"OUTCLR","size":8,"title":"Output Value Clear","description":"This register can be used instead of a read-modify-write to clear the output value of individual pins to \'0\'. Writing a \'1\' to OUTCLR[n] will clear the corresponding bit in PORT.OUT. Reading this bit field will always return the value of PORT.OUT."}],"title":"Output Value Clear","description":null},{"offset":"0x07","name":"OUTTGL","fields":[{"name":"OUTTGL","size":8,"title":"Output Value Toggle","description":"This register can be used instead of a read-modify-write to toggle the output value of individual pins. Writing a \'1\' to OUTTGL[n] will toggle the corresponding bit in PORT.OUT. Reading this bit field will always return the value of PORT.OUT."}],"title":"Output Value Toggle","description":null},{"offset":"0x08","name":"IN","fields":[{"name":"IN","size":8,"title":"Input Value","description":"This register shows the value present on the pins if the digital input driver is enabled. IN[n] shows the value of pin n of the Port. The input is not sampled and cannot be read if the digital input buffers are disabled. Writing to a bit of PORT.IN will toggle the corresponding bit in PORT.OUT."}],"title":"Input Value","description":null},{"offset":"0x09","name":"INTFLAGS","fields":[{"name":"INT","size":8,"title":"Interrupt Pin Flag","description":"The INT Flag is set when a pin change/state matches the pin\'s input sense configuration. Writing a \'1\' to a flag\'s bit location will clear the flag. For enabling and executing the interrupt, refer to ISC bit description in PORT.PINnCTRL."}],"title":"Interrupt Flags","description":null},{"offset":"0x10","name":"PIN0CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x11","name":"PIN1CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x12","name":"PIN2CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x13","name":"PIN3CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x14","name":"PIN4CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x15","name":"PIN5CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x16","name":"PIN6CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null},{"offset":"0x17","name":"PIN7CTRL","fields":[{"name":"INVEN","title":"Inverted I/O Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|I/O on pin n not inverted |\\n | 1|I/O on pin n inverted |\\n"},{"size":3},{"name":"PULLUPEN","title":"Pullup Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Pullup disabled for pin n |\\n | 1|Pullup enabled for pin n |\\n"},{"name":"ISC","size":3,"title":"Input/Sense Configuration","description":"These bits configure the input and sense configuration of pin n. The sense configuration determines how a port interrupt can be triggered. If the input buffer is disabled, the input cannot be read in the IN register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTDISABLE|Interrupt disabled but input buffer enabled |\\n | 0x1|BOTHEDGES|Sense both edges |\\n | 0x2|RISING|Sense rising edge |\\n | 0x3|FALLING|Sense falling edge |\\n | 0x4|INPUT_DISABLE|Digital input buffer disabled |\\n | 0x5|LEVEL|Sense low level\\nother - Reserved |\\n"}],"title":"Pin n Control","description":null}]},{"name":"VPORT","datasheetPage":147,"offsets":[{"offset":"0x00","name":"DIR","fields":[{"name":"DIR","size":8,"title":"Data Direction","description":"This bit field selects the data direction for the individual pins in the Port."}],"title":"Data Direction","description":"Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\\nwhere the regular Port registers reside."},{"offset":"0x01","name":"OUT","fields":[{"name":"OUT","size":8,"title":"Output Value","description":"This bit field selects the data output value for the individual pins in the Port."}],"title":"Output Value","description":"Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\\nwhere the regular Port registers reside."},{"offset":"0x02","name":"IN","fields":[{"name":"IN","size":8,"title":"Input Value","description":"This bit field holds the value present on the pins if the digital input buffer is enabled. Writing to a bit of VPORT.IN will toggle the corresponding bit in VPORT.OUT."}],"title":"Input Value","description":"Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\\nwhere the regular Port registers reside."},{"offset":"0x03","name":"INTFLAGS","fields":[{"name":"INT","size":8,"title":"Interrupt Pin Flag","description":"The INT flag is set when a pin change/state matches the pin\'s input sense configuration, and the pin is configured as source for port interrupt. Writing a \'1\' to this flag\'s bit location will clear the flag. For enabling and executing the interrupt, refer to PORT_PINnCTRL.ISC."}],"title":"Interrupt Flag","description":"Writing to the Virtual Port registers has the same effect as writing to the regular registers, but allows for memoryspecific instructions, such as bit-manipulation instructions, which are not valid for the extended I/O memory space\\nwhere the regular Port registers reside.w"}]},{"name":"BOD","datasheetPage":156,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":3},{"name":"SAMPFREQ","title":"Sample Frequency","description":"This bit selects the BOD sample frequency. The Reset value is loaded from the SAMPFREQ bit in FUSE.BODCFG.This bit is under Configuration Change Protection (CCP). \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Sample frequency is 1kHz |\\n | 0x1|Sample frequency is 125Hz |\\n"},{"name":"ACTIVE","size":2,"title":"Active","description":"These bits selects the BOD operation mode when the device is in active or idle mode. The Reset value is loaded from the ACTIVE bits in FUSE.BODCFG.These bits are not under Configuration Change Protection (CCP). \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Disabled |\\n | 0x1|Enabled |\\n | 0x2|Sampled |\\n | 0x3|Enabled with wake-up halted until BOD is ready |\\n"},{"name":"SLEEP","size":2,"title":"Sleep","description":"These bits select the BOD operation mode when the device is in standby or power-down sleep mode. These bits are under Configuration Change Protection (CCP). The Reset value is loaded from the SLEEP bits in FUSE.BODCFG. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Disabled |\\n | 0x1|Enabled |\\n | 0x2|Sampled |\\n | 0x3|Reserved |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":5},{"name":"LVL","size":3,"title":"BOD Level","description":"These bits select the BOD threshold level. The Reset value is loaded from the BOD Level bits (LVL) in the BOD Configuration Fuse (FUSE.BODCFG). \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|BODLEVEL0|1.8V |\\n | 0x2|BODLEVEL2|2.6V |\\n | 0x7|BODLEVEL7|4.2V\\nNote:\\n\u2022 Values in the description are typical values.\\n\u2022 Refer to the BOD and POR Characteristics in Electrical Characteristics for maximum and minimum values. |\\n"}],"title":"Control B","description":null},{"offset":"0x08","name":"VLMCTRLA","fields":[{"size":6},{"name":"VLMLVL","size":2,"title":"VLM Level","description":"These bit select the Voltage Level Monitor threshold relative to the BOD threshold (LVL in BOD.CTRLB). \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|VLM threshold 5% above BOD threshold |\\n | 0x1|VLM threshold 15% above BOD threshold |\\n | 0x2|VLM threshold 25% above BOD threshold\\nother Reserved |\\n"}],"title":"VLM Control A","description":null},{"offset":"0x09","name":"INTCTRL","fields":[{"size":5},{"name":"VLMCFG","size":2,"title":"VLM Configuration","description":"These bits select which incidents will trigger a VLM interrupt. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Voltage crosses VLM threshold from above |\\n | 0x1|Voltage crosses VLM threshold from below |\\n | 0x2|Either direction is triggering an interrupt request\\nOther Reserved |\\n"},{"name":"VLMIE","title":"VLM Interrupt Enable","description":"Writing a \'1\' to this bit enables the Voltage Level Monitor (VLM) interrupt."}],"title":"Interrupt Control","description":null},{"offset":"0x0A","name":"INTFLAGS","fields":[{"size":7},{"name":"VLMIF","title":"VLM Interrupt Flag","description":"This flag is set when a trigger from the VLM is given, as configured by the VLMCFG bit in the BOD.INTCTRL register. The flag is only updated when the BOD is enabled."}],"title":"VLM Interrupt Flags","description":null},{"offset":"0x0B","name":"STATUS","fields":[{"size":7},{"name":"VLMS","title":"VLM Status","description":"This bit is only valid when the bod is enabled. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The voltage is above the VLM threshold level |\\n | 1|The voltage is below the VLM threshold level |\\n"}],"title":"VLM Status","description":null}]},{"name":"VREF","datasheetPage":164,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"ADC0REFSEL","size":3,"title":"ADC0 Reference Select","description":"These bits select the reference voltage for the ADC0. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|0.55V |\\n | 0x1|1.1V |\\n | 0x2|2.5V |\\n | 0x3|4.3V |\\n | 0x4|1.5V\\nother Reserved |\\n"},{},{"name":"DAC0REFSEL","size":3,"title":"DAC0 and AC0 Reference Select","description":"These bits select reference voltage for the DAC0 and AC0. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|0.55V |\\n | 0x1|1.1V |\\n | 0x2|2.5V |\\n | 0x3|4.3V |\\n | 0x4|1.5V\\nother Reserved |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":6},{"name":"ADC0REFEN","title":"ADC0 Reference Force Enable","description":"Writing a \'1\' to this bit forces the voltage reference for the ADC0 to be running, even if it not requested. Writing a \'0\' to this bit allows to automatic enable/disable of the reference source by the peripheral."},{"name":"DAC0REFEN","title":"DAC0 and AC0 Reference Force Enable","description":"Writing a \'1\' to this bit forces the voltage reference for the DAC0 and AC0 to be running, even if it not requested. Writing a \'0\' to this bit allows to automatic enable/disable of the reference source by the peripheral."}],"title":"Control B","description":null}]},{"name":"WDT","datasheetPage":172,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"WINDOW","size":4,"title":"Window","description":"Writing a non-zero value to these bits enables the window mode, and selects the according duration of the closed period. The bits are optionally lock protected: \u2022 If LOCK bit in WDT.STATUS is \'1\', all bits are change protected (Access = R) \u2022 If LOCK bit in WDT.STATUS is \'0\', all bits can be changed (Access = R/W) \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OFF|- |\\n | 0x1|8CLK|0.008s |\\n | 0x2|16CLK|0.016s |\\n | 0x3|32CLK|0.032s |\\n | 0x4|64CLK|0.064s |\\n | 0x5|128CLK|0.128s |\\n | 0x6|256CLK|0.256s |\\n | 0x7|512CLK|0.512s |\\n | 0x8|1KCLK|1.024s |\\n | 0x9|2KCLK|2.048s |\\n | 0xA|4KCLK|4.096s |\\n | 0xB|8KCLK|8.192s\\nother - Reserved |\\n"},{"name":"PERIOD","size":4,"title":"Period","description":"Writing a non-zero value to this bit enables the WDT, and selects the according timeout period in normal mode. In window mode, these bits select the duration of the open window. The bits are optionally lock protected: \u2022 If LOCK in WDT.STATUS is \'1\', all bits are change protected (Access = R) \u2022 If LOCK in WDT.STATUS is \'0\', all bits can be changed (Access = R/W) \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OFF|- |\\n | 0x1|8CLK|0.008s |\\n | 0x2|16CLK|0.016s |\\n | 0x3|32CLK|0.032s |\\n | 0x4|64CLK|0.064s |\\n | 0x5|128CLK|0.128s |\\n | 0x6|256CLK|0.256s |\\n | 0x7|512CLK|0.512s |\\n | 0x8|1KCLK|1.0s |\\n | 0x9|2KCLK|2.0s |\\n | 0xA|4KCLK|4.1s |\\n | 0xB|8KCLK|8.2s\\nother - Reserved |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"STATUS","fields":[{"name":"LOCK","title":"Lock","description":"Writing this bit to \'1\' write protects the WDT.CTRLA register. It is only possible to write this bit to \'1\'. This bit can only be cleared in debug. If the PERIOD bits in WDT.CTRLA are different from zero after boot code, Lock will automatically be set. This bit is under Configuration Change Protection (CCP)."},{"size":6},{"name":"SYNCBUSY","title":"Synchronization Busy","description":"This bit is set after writing to the WDT.CTRLA register while the data is being synchronized from the system clock domain to the WDT clock domain. This bit is cleared by system after the synchronization is finished. This bit is not under Configuration Change Protection (CCP)."}],"title":"Status","description":null}]},{"name":"TCA","datasheetPage":188,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":4},{"name":"CLKSEL","size":3,"title":"Clock Select","description":"These bits select the clock frequency for the timer/counter. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DIV1|fTCA = fCLK_PER/1 |\\n | 0x1|DIV2|fTCA = fCLK_PER/2 |\\n | 0x2|DIV4|fTCA = fCLK_PER/4 |\\n | 0x3|DIV8|fTCA = fCLK_PER/8 |\\n | 0x4|DIV16|fTCA = fCLK_PER/16 |\\n | 0x5|DIV64|fTCA = fCLK_PER/64 |\\n | 0x6|DIV256|fTCA = fCLK_PER/256 |\\n | 0x7|DIV1024|fTCA = fCLK_PER/1024 |\\n"},{"name":"ENABLE","title":"Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is disabled |\\n | 1|The peripheral is enabled |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":1},{"name":"CMPnEN2"},{"name":"CMPnEN1"},{"name":"CMPnEN0"},{"name":"ALUPD","title":"Auto Lock Update","description":"The Auto Lock Update feature controls the Lock Update (LUPD) bit in the TCA.CTRLE register. When ALUPD is written to \u20181\u2019, LUPD will be set to \u20181\u2019 until the Buffer Valid (CMPnBV) bits of all enabled compare channels are \u20181\u2019. This condition will clear LUPD. It will remain cleared until the next UPDATE condition, where the buffer values will be transferred to the CMPn registers and LUPD will be set to \u20181\u2019 again. This makes sure that CMPnBUF register values are not transferred to the CMPn registers until all enabled compare buffers are written. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|LUPD in TCA.CTRLE not altered by system. |\\n | 1|LUPD in TCA.CTRLE set and cleared automatically. |\\n"},{"name":"WGMODE","size":3,"title":"Waveform Generation Mode","description":"These bits select the waveform generation mode, and control the counting sequence of the counter, TOP value, UPDATE condition, interrupt condition, and type of waveform that is generated. No waveform generation is performed in the normal mode of operation. For all other modes, the result from the waveform generator will only be directed to the PORT pins if the corresponding CMPnEN bit has been set to enable this. The port pin direction must be set as output. Table 20-5.\u2000Timer Waveform Generation Mode WGMODE[2:0] Group Configuration Mode of Operation Top Update OVF"}],"title":"Control B - Normal Mode","description":null},{"offset":"0x02","name":"CTRLC","fields":[{"size":5},{"name":"CMP2OV","title":"Compare Output Value 2","description":"See CMP0OV."},{"name":"CMP1OV","title":"Compare Output Value 1","description":"See CMP0OV."},{"name":"CMP0OV","title":"Compare Output Value 0","description":"The CMPnOV bits allow direct access to the waveform generator\'s output compare value when the timer/counter is not enabled. This is used to set or clear the WG output value when the timer/counter is not running."}],"title":"Control C - Normal Mode","description":null},{"offset":"0x03","name":"CTRLD","fields":[{"size":7},{"name":"SPLITM","title":"Enable Split Mode","description":"This bit sets the timer/counter in split mode operation. It will then work as two 8-bit timer/counters. The register map will change compared to normal 16-bit mode."}],"title":"Control D","description":null},{"offset":"0x04","name":"CTRLECLR","fields":[{"size":4},{"name":"CMD","size":2,"title":"Command","description":"These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are always read as zero. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No command |\\n | 0x1|UPDATE|Force update |\\n | 0x2|RESTART|Force restart |\\n | 0x3|RESET|Force hard Reset (ignored if TC is enabled) |\\n"},{"name":"LUPD","title":"Lock Update","description":"Lock update can be used to ensure that all buffers are valid before an update is performed. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The buffered registers are updated as soon as an UPDATE condition has occurred. |\\n | 1|No update of the buffered registers is performed, even though an UPDATE condition has occurred. |\\n"},{"name":"DIR","title":"Counter Direction","description":"Normally this bit is controlled in hardware by the waveform generation mode or by event actions, but this bit can also be changed from software. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The counter is counting up (incrementing). |\\n | 1|The counter is counting down (decrementing). |\\n"}],"title":"Control Register E Clear - Normal Mode","description":"The individual status bit can be cleared by writing a one to its bit location. This allows each bit to be cleared without\\nuse of a read-modify-write operation on a single register.\\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."},{"offset":"0x05","name":"CTRLESET","fields":[{"size":4},{"name":"CMD","size":2,"title":"Command","description":"These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are always read as zero. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No command |\\n | 0x1|UPDATE|Force update |\\n | 0x2|RESTART|Force restart |\\n | 0x3|RESET|Force hard Reset (ignored if TC is enabled) |\\n"},{"name":"LUPD","title":"Lock Update","description":"Locking the update ensures that all buffers are valid before an update is performed. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The buffered registers are updated as soon as an UPDATE condition has occurred. |\\n | 1|No update of the buffered registers is performed, even though an UPDATE condition has occurred. |\\n"},{"name":"DIR","title":"Counter Direction","description":"Normally this bit is controlled in hardware by the waveform generation mode or by event actions, but this bit can also be changed from software. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The counter is counting up (incrementing). |\\n | 1|The counter is counting down (decrementing). |\\n"}],"title":"Control Register E Set - Normal Mode","description":"The individual status bit can be set by writing a \'1\' to its bit location. This allows each bit to be set without use of a\\nread-modify-write operation on a single register.\\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."},{"offset":"0x06","name":"CTRLFCLR","fields":[{"size":4},{"name":"CMP2BV","title":"Compare 2 Buffer Valid","description":"See CMP0BV."},{"name":"CMP1BV","title":"Compare 1 Buffer Valid","description":"See CMP0BV."},{"name":"CMP0BV","title":"Compare 0 Buffer Valid","description":"The CMPnBV bits are set when a new value is written to the corresponding CMPnBUF register. These bits are automatically cleared on an UPDATE condition."},{"name":"PERBV","title":"Period Buffer Valid","description":"This bit is set when a new value is written to the PERB register. This bit is automatically cleared on an UPDATE condition."}],"title":"Control Register F Clear","description":"The individual status bit can be cleared by writing a one to its bit location. This allows each bit to be cleared without\\nuse of a read-modify-write operation on a single register."},{"offset":"0x07","name":"CTRLFSET","fields":[{"size":4},{"name":"CMP2BV","title":"Compare 2 Buffer Valid","description":"See CMP0BV."},{"name":"CMP1BV","title":"Compare 1 Buffer Valid","description":"See CMP0BV."},{"name":"CMP0BV","title":"Compare 0 Buffer Valid","description":"The CMPnBV bits are set when a new value is written to the corresponding CMPnBUF register. These bits are automatically cleared on an UPDATE condition."},{"name":"PERBV","title":"Period Buffer Valid","description":"This bit is set when a new value is written to the PERB register. This bit is automatically cleared on an UPDATE condition."}],"title":"Control Register F Set","description":"The individual status bit can be set by writing a one to its bit location. This allows each bit to be set without use of a\\nread-modify-write operation on a single register."},{"offset":"0x09","name":"EVCTRL","fields":[{"size":5},{"name":"EVACT","size":2,"title":"Event Action","description":"These bits define on what type of event action the counter will increment or decrement. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|EVACT_POSEDGE|Count on positive edge event |\\n | 0x1|EVACT_ANYEDGE|Count on any edge event |\\n | 0x2|EVACT_HIGHLVL|Count on prescaled clock while event line is 1. |\\n | 0x3|EVACT_UPDOWN|Count on prescaled clock. Event controls count direction. Up-count when event\\nline is 0, down-count when event line is 1. |\\n"},{"name":"CNTEI","title":"Enable Count on Event Input","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Counting on Event input is disabled. |\\n | 1|Counting on Event input is enabled according to EVACT bit field. |\\n"}],"title":"Event Control","description":null},{"offset":"0x0A","name":"INTCTRL","fields":[{"size":1},{"name":"CMP2","title":"Compare Channel 2 Interrupt Enable","description":"See CMP0."},{"name":"CMP1","title":"Compare Channel 1 Interrupt Enable","description":"See CMP0."},{"name":"CMP0","title":"Compare Channel 0 Interrupt Enable","description":"Writing CMPn bit to \'1\' enables compare interrupt from channel n."},{"size":3},{"name":"OVF","title":"Timer Overflow/Underflow Interrupt Enable","description":"Writing OVF bit to \'1\' enables overflow interrupt."}],"title":"Interrupt Control Register - Normal Mode","description":null},{"offset":"0x0B","name":"INTFLAGS","fields":[{"size":1},{"name":"CMP2","title":"Compare Channel 2 Interrupt Flag","description":"See CMP0 flag description."},{"name":"CMP1","title":"Compare Channel 1 Interrupt Flag","description":"See CMP0 flag description."},{"name":"CMP0","title":"Compare Channel 0 Interrupt Flag","description":"The compare interrupt flag (CMPn) is set on a compare match on the corresponding compare channel. For all modes of operation, the CMPn flag will be set when a compare match occurs between the count register (CNT) and the corresponding compare register (CMPn). The CMPn flag will not be cleared automatically and has to be cleared by software. This is done by writing a one to its bit location."},{"size":3},{"name":"OVF","title":"Overflow/Underflow Interrupt Flag","description":"This flag is set either on a TOP (overflow) or BOTTOM (underflow) condition, depending on the WGMODE setting. OVF is not automatically cleared and needs to be cleared by software. This is done by writing a one to its bit location."}],"title":"Interrupt Flag Register - Normal Mode","description":"The individual status bit can be cleared by writing a \'1\'e to its bit location. This allows each bit to be set without use of\\na read-modify-write operation on a single register."},{"offset":"0x0E","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Run in Debug","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control Register","description":null},{"offset":"0x0F","name":"TEMP","fields":[{"name":"TEMP","size":8,"title":"Temporary Bits for 16-bit Access"}],"title":"Temporary bits for 16-bit Access","description":"The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\\nTemporary register for all the 16-bit registers of this peripheral."},{"offset":"0x20","name":"CNT","fields":[{"name":"CNT","size":8,"title":"Counter low byte","description":"These bits hold the LSB of the 16-bit counter register."},{"name":"CNT","size":8,"title":"Counter low byte","description":"These bits hold the LSB of the 16-bit counter register."}],"title":"Counter Register - Normal Mode","description":"The TCA.CNTL and TCA.CNTH register pair represents the 16-bit value, TCA.CNT. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nCPU and UPDI write access has priority over internal updates of the register."},{"offset":"0x26","name":"PER","fields":[{"name":"PER","size":8,"title":"Periodic low byte","description":"These bits hold the LSB of the 16-bit period register."},{"name":"PER","size":8,"title":"Periodic low byte","description":"These bits hold the LSB of the 16-bit period register."}],"title":"Period Register - Normal Mode","description":"TCA.PER contains the 16-bit TOP value in the timer/counter.\\nThe TCA.PERL and TCA.PERH register pair represents the 16-bit value, TCA.PER. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x28","name":"CMP0","fields":[{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."},{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."}],"title":"Compare n Register - Normal Mode","description":"This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\\nused for generating waveforms.\\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\\nUPDATE condition occurs.\\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x2A","name":"CMP1","fields":[{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."},{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."}],"title":"Compare n Register - Normal Mode","description":"This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\\nused for generating waveforms.\\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\\nUPDATE condition occurs.\\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x2C","name":"CMP2","fields":[{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."},{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."}],"title":"Compare n Register - Normal Mode","description":"This register is continuously compared to the counter value. Normally, the outputs from the comparators are then\\nused for generating waveforms.\\nTCA.CMPn registers are updated with the buffer value from their corresponding CMPnBUF register when an\\nUPDATE condition occurs.\\nThe TCA.CMPnL and TCA.CMPnH register pair represents the 16-bit value, TCA.CMPn. The low byte [7:0] (suffix L)\\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x36","name":"PERBUF","fields":[{"name":"PERBUF","size":8,"title":"Period Buffer low byte","description":"These bits hold the LSB of the 16-bit period buffer register."},{"name":"PERBUF","size":8,"title":"Period Buffer low byte","description":"These bits hold the LSB of the 16-bit period buffer register."}],"title":"Period Buffer Register","description":"This register serves as the buffer for the period register (TCA.PER). Accessing this register using the CPU or UPDI\\nwill affect the PERBV flag.\\nThe TCA.PERBUFL and TCA.PERBUFH register pair represents the 16-bit value, TCA.PERBUF. The low byte [7:0]\\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more\\ndetails on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x38","name":"CMP0BUF","fields":[{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."},{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."}],"title":"Compare n Buffer Register","description":"This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x3A","name":"CMP1BUF","fields":[{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."},{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."}],"title":"Compare n Buffer Register","description":"This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x3C","name":"CMP2BUF","fields":[{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."},{"name":"CMPBUF","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare buffer register."}],"title":"Compare n Buffer Register","description":"This register serves as the buffer for the associated compare registers (TCA.CMPn). Accessing any of these\\nregisters using the CPU or UPDI will affect the corresponding CMPnBV status bit.\\nThe TCA.CMPnBUFL and TCA.CMPnBUFH register pair represents the 16-bit value, TCA.CMPnBUF. The low byte\\n[7:0] (suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For\\nmore details on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."}]},{"name":"TCA-SPLIT","datasheetPage":208,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":4},{"name":"CLKSEL","size":3,"title":"Clock Select","description":"These bits select the clock frequency for the timer/counter. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DIV1|fTCA = fCLK_PER/1 |\\n | 0x1|DIV2|fTCA = fCLK_PER/2 |\\n | 0x2|DIV4|fTCA = fCLK_PER/4 |\\n | 0x3|DIV8|fTCA = fCLK_PER/8 |\\n | 0x4|DIV16|fTCA = fCLK_PER/16 |\\n | 0x5|DIV64|fTCA = fCLK_PER/64 |\\n | 0x6|DIV256|fTCA = fCLK_PER/256 |\\n | 0x7|DIV1024|fTCA = fCLK_PER/1024 |\\n"},{"name":"ENABLE","title":"Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is disabled |\\n | 1|The peripheral is enabled |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":2},{"name":"HCMP2EN","title":"High-byte Compare 2 Enable","description":"See LCMP0EN."},{"name":"HCMP1EN","title":"High-byte Compare 1 Enable","description":"See LCMP0EN."},{"name":"HCMP0EN","title":"High-byte Compare 0 Enable","description":"See LCMP0EN."},{"name":"LCMP2EN","title":"Low-byte Compare 2 Enable","description":"See LCMP0EN."},{"name":"LCMP1EN","title":"Low-byte Compare 1 Enable","description":"See LCMP0EN."},{"name":"LCMP0EN","title":"Low-byte Compare 0 Enable","description":"Setting the LCMPnEN/HCMPnEN bits in the FRQ or PWM waveform generation mode of operation will override the port output register for the corresponding WOn pin."}],"title":"Control B - Split Mode","description":null},{"offset":"0x02","name":"CTRLC","fields":[{"size":2},{"name":"HCMP2OV","title":"High-byte Compare 2 Output Value","description":"See LCMP0OV."},{"name":"HCMP1OV","title":"High-byte Compare 1 Output Value","description":"See LCMP0OV."},{"name":"HCMP0OV","title":"High-byte Compare 0 Output Value","description":"See LCMP0OV."},{"name":"LCMP2OV","title":"Low-byte Compare 2 Output Value","description":"See LCMP0OV."},{"name":"LCMP1OV","title":"Low-byte Compare 1 Output Value","description":"See LCMP0OV."},{"name":"LCMP0OV","title":"Low-byte Compare 0 Output Value","description":"The LCMPnOV/HCMPn bits allow direct access to the waveform generator\'s output compare value when the timer/ counter is not enabled. This is used to set or clear the WOn output value when the timer/counter is not running."}],"title":"Control C - Split Mode","description":null},{"offset":"0x03","name":"CTRLD","fields":[{"size":7},{"name":"SPLITM","title":"Enable Split Mode","description":"This bit sets the timer/counter in split mode operation. It will then work as two 8-bit timer/counters. The register map will change compared to normal 16-bit mode."}],"title":"Control D","description":null},{"offset":"0x04","name":"CTRLECLR","fields":[{"size":6},{"name":"CMD","size":2,"title":"Command","description":"These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are always read as zero. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No command |\\n | 0x1|UPDATE|Force update |\\n | 0x2|RESTART|Force restart |\\n | 0x3|RESET|Force hard Reset (ignored if TC is enabled) |\\n"}],"title":"Control Register E Clear - Split Mode","description":"The individual status bit can be cleared by writing a \'1\' to its bit location. This allows each bit to be cleared without\\nuse of a read-modify-write operation on a single register.\\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."},{"offset":"0x05","name":"CTRLESET","fields":[{"size":6},{"name":"CMD","size":2,"title":"Command","description":"These bits are used for software control of update, restart, and reset of the timer/counter. The command bits are always read as zero. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No command |\\n | 0x1|UPDATE|Force update |\\n | 0x2|RESTART|Force restart |\\n | 0x3|RESET|Force hard Reset (ignored if TC is enabled) |\\n"}],"title":"Control Register E Set - Split Mode","description":"The individual status bit can be set by writing a \'1\' to its bit location. This allows each bit to be set without use of a\\nread-modify-write operation on a single register.\\nEach Status bit can be read out either by reading TCA.CTRLESET or TCA.CTRLECLR."},{"offset":"0x0A","name":"INTCTRL","fields":[{"size":1},{"name":"LCMP2","title":"Low-byte Compare Channel 0 Interrupt Enable","description":"See LCMP0."},{"name":"LCMP1","title":"Low-byte Compare Channel 1 Interrupt Enable","description":"See LCMP0."},{"name":"LCMP0","title":"Low-byte Compare Channel 0 Interrupt Enable","description":"Writing LCMPn bit to \'1\' enables low-byte compare interrupt from channel n."},{"size":2},{"name":"HUNF","title":"High-byte Underflow Interrupt Enable","description":"Writing HUNF bit to \'1\' enables high-byte underflow interrupt."},{"name":"LUNF","title":"Low-byte Underflow Interrupt Enable","description":"Writing HUNF bit to \'1\' enables low-byte underflow interrupt."}],"title":"Interrupt Control Register - Split Mode","description":null},{"offset":"0x0B","name":"INTFLAGS","fields":[{"size":1},{"name":"LCMP2","title":"Low-byte Compare Channel 0 Interrupt Flag","description":"See LCMP0 flag description."},{"name":"LCMP1","title":"Low-byte Compare Channel 0 Interrupt Flag","description":"See LCMP0 flag description."},{"name":"LCMP0","title":"Low-byte Compare Channel 0 Interrupt Flag","description":"The compare interrupt flag (LCMPn) is set on a compare match on the corresponding compare channel. For all modes of operation, the LCMPn flag will be set when a compare match occurs between the Low-byte count register (LCNT) and the corresponding compare register (LCMPn). The LCMPn flag will not be cleared automatically and has to be cleared by software. This is done by writing a \u20181\u2019 to its bit location."},{"size":2},{"name":"HUNF","title":"High-byte Underflow Interrupt Flag","description":"This flag is set on a high-byte timer BOTTOM (underflow) condition. HUNF is not automatically cleared and needs to be cleared by software. This is done by writing a \u20181\u2019 to its bit location."},{"name":"LUNF","title":"Low-byte Underflow Interrupt Flag","description":"This flag is set on a low-byte timer BOTTOM (underflow) condition. LUNF is not automatically cleared and needs to be cleared by software. This is done by writing a \u20181\u2019 to its bit location."}],"title":"Interrupt Flag Register - Split Mode","description":"The individual status bit can be cleared by writing a \u20181\u2019 to its bit location. This allows each bit to be set without use of\\na read-modify-write operation on a single register."},{"offset":"0x0E","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Run in Debug","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control Register","description":null},{"offset":"0x20","name":"LCNT","fields":[{"name":"LCNT","size":8,"title":"Counter value for low-byte timer","description":"These bits define the counter value of the low-byte timer."}],"title":"Low-byte Timer Counter Register - Split Mode","description":"TCA.LCNT contains the counter value in low-byte timer. CPU and UPDI write access has priority over count, clear, or\\nreload of the counter."},{"offset":"0x21","name":"HCNT","fields":[{"name":"HCNT","size":8,"title":"Counter value for high-byte timer","description":"These bits define the counter value in high-byte timer."}],"title":"High-byte Timer Counter Register - Split Mode","description":"TCA.HCNT contains the counter value in high-byte timer. CPU and UPDI write access has priority over count, clear,\\nor reload of the counter."},{"offset":"0x26","name":"LPER","fields":[{"name":"LPER","size":8,"title":"Period value low-byte timer","description":"These bits hold the TOP value of low-byte timer."}],"title":"Low-byte Timer Period Register - Split Mode","description":"The TCA.LPER register contains the TOP value of low-byte timer."},{"offset":"0x27","name":"HPER","fields":[{"name":"HPER","size":8,"title":"Period value high-byte timer","description":"These bits hold the TOP value of high-byte timer."}],"title":"High-byte Period Register - Split Mode","description":"The TCA.HPER register contains the TOP value of high-byte timer."},{"offset":"0x28","name":"LCMP0","fields":[{"name":"LCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to LCNT."}],"title":"Compare Register n for low-byte Timer - Split Mode","description":"The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\\nthen used for generating waveforms."},{"offset":"0x29","name":"HCMP0","fields":[{"name":"HCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to HCNT."}],"title":"High-byte Compare Register n - Split Mode","description":"The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\\nare then used for generating waveforms."},{"offset":"0x2A","name":"LCMP1","fields":[{"name":"LCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to LCNT."}],"title":"Compare Register n for low-byte Timer - Split Mode","description":"The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\\nthen used for generating waveforms."},{"offset":"0x2B","name":"HCMP1","fields":[{"name":"HCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to HCNT."}],"title":"High-byte Compare Register n - Split Mode","description":"The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\\nare then used for generating waveforms."},{"offset":"0x2C","name":"LCMP2","fields":[{"name":"LCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to LCNT."}],"title":"Compare Register n for low-byte Timer - Split Mode","description":"The TCA.LCMPn register represents the compare value of compare channel n for low-byte Timer. This register is\\ncontinuously compared to the counter value of low-byte timer, LCNT. Normally, the outputs from the comparators are\\nthen used for generating waveforms."},{"offset":"0x2D","name":"HCMP2","fields":[{"name":"HCMP","size":8,"title":"Compare value of channel n","description":"These bits hold the compare value of channel n that is compared to HCNT."}],"title":"High-byte Compare Register n - Split Mode","description":"The TCA.HCMPn register represents the compare value of compare channel n for high-byte Timer. This register is\\ncontinuously compared to the counter value of high-byte timer, HCNT. Normally, the outputs from the comparators\\nare then used for generating waveforms."}]},{"name":"TCB","datasheetPage":234,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"RUNSTDBY","title":"Run Standby","description":"Writing a \'1\' to this bit will enable the peripheral to run in Standby sleep mode. Not applicable when CLKSEL is set to"},{},{"name":"SYNCUPD","title":"Synchronize Update","description":"When this bit is written to \'1\', the TCB will restart whenever the TCA0 is restarted."},{},{"name":"CLKSEL","size":2,"title":"Clock Select","description":"Writing these bits selects the clock source for this peripheral. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|CLK_PER |\\n | 0x1|CLK_PER / 2 |\\n | 0x2|Use CLK_TCA from TCA0 |\\n | 0x3|Reserved |\\n"},{"name":"ENABLE","title":"Enable","description":"Writing this bit to \'1\' enables the Timer/Counter type B peripheral."}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":1},{"name":"ASYNC","title":"Asynchronous Enable","description":"Writing this bit to \'1\' will allow asynchronous updates of the TCB output signal in single shot mode \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The output will go HIGH when the counter actually starts |\\n | 1|The output will go HIGH when an Event arrives |\\n"},{"name":"CCMPINIT","title":"Compare/Capture Pin Initial Value","description":"This bit is used to set the initial output value of the pin when a pin output is used. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Initial pin state is LOW |\\n | 1|Initial pin state is HIGH |\\n"},{"name":"CCMPEN","title":"Compare/Capture Output Enable","description":"This bit is used to set the output value of the Compare/Capture Output. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Compare/Capture Output is zero |\\n | 1|Compare/Capture Output has a valid value |\\n"},{},{"name":"CNTMODE","size":3,"title":"Timer Mode","description":"Writing these bits selects the timer mode. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Periodic interrupt mode |\\n | 0x1|Timeout check mode |\\n | 0x2|Input capture on event mode |\\n | 0x3|Input capture frequency measurement mode |\\n | 0x4|Input capture pulse width measurement mode |\\n | 0x5|Input capture frequency and pulse width measurement mode |\\n | 0x6|Single shot mode |\\n | 0x7|8-bit PWM mode |\\n"}],"title":"Control B","description":null},{"offset":"0x04","name":"EVCTRL","fields":[{"size":1},{"name":"FILTER","title":"Input Capture Noise Cancellation Filter","description":"Writing this bit to \'1\' enables the input capture noise cancellation unit."},{},{"name":"EDGE","title":"Event Edge","description":"This bit is used to select the Event edge. The effect of this bit is dependent on the selected Count Mode (CNTMODE) in TCB.CTRLB. Count Mode EDGE Positive Edge Negative Edge Periodic Interrupt Mode 0 Not Applicable Not Applicable"},{"size":3},{"name":"CAPTEI","title":"Capture Event Input Enable","description":"Writing this bit to \'1\' enables the event input capture."}],"title":"Event Control","description":null},{"offset":"0x05","name":"INTCTRL","fields":[{"size":7},{"name":"CAPT","title":"Capture Interrupt Enable","description":"Writing this bit to \'1\' enables the Capture interrupt."}],"title":"Interrupt Control","description":null},{"offset":"0x06","name":"INTFLAGS","fields":[{"size":7},{"name":"CAPT","title":"Interrupt Flag","description":"This bit is set when an interrupt occurs. The interrupt conditions are dependent on the Counter mode (CNTMODE) in TCB.CTRLB. This bit is cleared by writing a \'1\' to it or when the Capture register is read in capture mode. Counter Mode Interrupt Set Condition Periodic Interrupt Mode Set when the counter reaches TOP Timeout Check Mode Set when the counter reaches TOP Input Capture on Event Mode Set when an event occurs and the capture register is loaded, Flag clears when capture is read Input Capture Frequency Measurement Mode Set on edge when the capture register is loaded and count initialized, Flag clears when capture is read Input Capture Pulse Width Measurement Mode Set on a edge when the capture register is loaded, previous edge initialized the count, Flag clears when capture is read Input Capture Frequency and Pulse Width Measurement Mode Set on second (positive or negative) edge when the counter is stopped, Flag clears when capture is read Single Shot Mode Set when counter reaches TOP"}],"title":"Interrupt Flags","description":null},{"offset":"0x07","name":"STATUS","fields":[{"size":7},{"name":"RUN","title":"Run","description":"When the counter is running, this bit is set to \'1\'. When the counter is stopped, this bit is cleared \'0\'. The bit it is read only and cannot be set by UPDI."}],"title":"Status","description":null},{"offset":"0x08","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control","description":null},{"offset":"0x09","name":"TEMP","fields":[{"name":"TEMP","size":8,"title":"Temporary Value"}],"title":"Temporary Value","description":"The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\\nTemporary register for all the 16-bit registers of this peripheral."},{"offset":"0x0A","name":"CNT","fields":[{"name":"CNT","size":8,"title":"Count Value low","description":"These bits hold the LSB of the 16-bit counter register."},{"name":"CNT","size":8,"title":"Count Value low","description":"These bits hold the LSB of the 16-bit counter register."}],"title":"Count","description":"The TCB.CNTL and TCB.CNTH register pair represents the 16-bit value TCB.CNT. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nCPU and UPDI write access has priority over internal updates of the register."},{"offset":"0x0C","name":"CCMP","fields":[{"name":"CCMP","size":8,"title":"Capture/Compare Value low byte","description":"These bits hold the LSB of the 16-bit compare, capture and top value"},{"name":"CCMP","size":8,"title":"Capture/Compare Value low byte","description":"These bits hold the LSB of the 16-bit compare, capture and top value"}],"title":"Capture/Compare","description":"The TCB.CCMPL and TCB.CCMPH register pair represents the 16-bit value TCB.CCMP. The low byte [7:0] (suffix L)\\nis accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details\\non reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nThis register has different functions depending on the mode of operation:\\n\u2022 For capture operation, these registers contain the captured value of the counter at the time the capture occurs\\n\u2022 In periodic interrupt/timeout and single shot mode this register acts as the TOP value.\\n\u2022 In 8-bit PWM mode, TCB.CCMPL and TCB.CCMPH act as two independent registers."}]},{"name":"TCD","datasheetPage":269,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"CLKSEL","size":2,"title":"Clock Select","description":"The clock select bits select the clock source of the TCD clock. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|OSC20M |\\n | 0x1|Reserved |\\n | 0x2|External clock |\\n | 0x3|System clock |\\n"},{"name":"CNTPRES","size":2,"title":"Counter Prescaler","description":"The Counter Prescaler bits select the division factor of the TCD counter clock. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Division factor 1 |\\n | 0x1|Division factor 4 |\\n | 0x2|Division factor 32 |\\n | 0x3|Reserved |\\n"},{"name":"SYNCPRES","size":2,"title":"Synchronization Prescaler","description":"The synchronization prescaler bits select the division factor of the TCD clock. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Division factor 1 |\\n | 0x1|Division factor 2 |\\n | 0x2|Division factor 4 |\\n | 0x3|Division factor 8 |\\n"},{"name":"ENABLE","title":"Enable","description":"When this bit is written to, it will automatically be synchronized to the TCD clock domain. This bit can be changed as long as synchronization of this bit is not ongoing, see Enable Ready bit (ENRDY) in Status register (STATUS). This bit is not enable-protected. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The TCD is disabled. |\\n | 1|The TCD is enabled and running. |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":6},{"name":"WGMODE","size":2,"title":"Waveform Generation Mode","description":"These bits select the waveform generation \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|ONERAMP|One ramp mode |\\n | 0x1|TWORAMP|Two ramp mode |\\n | 0x2|FOURRAMP|Four ramp mode |\\n | 0x3|DS|Dual-slope mode |\\n"}],"title":"Control B","description":null},{"offset":"0x02","name":"CTRLC","fields":[{"name":"CMPDSEL","title":"Compare D Output Select","description":"\\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|PWMA|Waveform A |\\n | 1|PWMB|Waveform B |\\n"},{"name":"CMPCSEL","title":"Compare C Output Select","description":"\\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|PWMA|Waveform A |\\n | 1|PWMB|Waveform B |\\n"},{"size":2},{"name":"FIFTY","title":"Fifty Percent Waveform","description":"If the two waveforms have identical characteristics, this bit can be written to \'1\'. This will cause any values written to register CMPBSET/CLR also to be written to the register CMPASET/CLR."},{},{"name":"AUPDATE","title":"Automatically Update","description":"If this bit is set a synchronization at the end of the TCD cycle is automatically requested after the Compare B Clear High register (CMPBCLRH) is written. If the Fifty Percent Waveform is enabled by setting the FIFTY bit in this register, writing the Compare A Clear High register will also request a synchronization at the end of the TCD cycle if the AUPDATE bit is set."},{"name":"CMPOVR","title":"Compare Output Value Override","description":"When this bit is written, default values of the Waveform Outputs A and B are overridden by the values written in the Compare x Value in active state bit fields in the Control D register (CTRLD.CMPnxVAL). See the Control D register description for more details."}],"title":"Control C","description":null},{"offset":"0x03","name":"CTRLD","fields":[{"name":"CMPBVAL","size":4},{"name":"CMPAVAL","size":4}],"title":"Control D","description":null},{"offset":"0x04","name":"CTRLE","fields":[{"name":"DISEOC","title":"Disable at End of TCD Cycle Strobe","description":"When this bit is written, the TCD will automatically disable at the end of the TCD cycle. When this bit is written to \'1\', the ENRDY in TCD.STATUS will keep low until the TCD is disabled. Writing to this bit only has effect if there is no ongoing synchronization of Enable. See also ENRDY bit in TCD.STATUS."},{"size":2},{"name":"SCAPTUREB","title":"Software Capture B Strobe","description":"When this bit is written to \'1\', a software capture to Capture register B (TCD.CAPTUREBL/H) is done as soon as the strobe is synchronized to the TCD domain. Writing to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in TCD.STATUS."},{"name":"SCAPTUREA","title":"Software Capture A Strobe","description":"When this bit is written to \'1\', a software capture to Capture register A (TCD.CAPTUREAL/H) is done as soon as the strobe is synchronized to the TCD domain. Writing to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in TCD.STATUS."},{"name":"RESTART","title":"Restart Strobe","description":"When this bit is written a Restart of the TCD counter is executed as soon as this bit is synchronized to the TCD domain. Writing to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in TCD.STATUS."},{"name":"SYNC","title":"Synchronize Strobe","description":"When this bit is written to \'1\' the doubled buffered registers will be loaded to the TCD domain as soon as this bit is synchronized to the TCD domain. Writing to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in TCD.STATUS."},{"name":"SYNCEOC","title":"Synchronize End of TCD Cycle Strobe","description":"When this bit is written to \'1\' the doubled buffered registers will be loaded to the TCD domain at the end of the next TCD cycle. Writing to this bit only has effect if there is no ongoing synchronization of a command. See also CMDRDY bit in TCD.STATUS."}],"title":"Control E","description":null},{"offset":"0x08","name":"EVCTRLA","fields":[{"name":"CFG","size":2,"title":"Event Configuration","description":"When the Input Capture Noise canceler is activated (FILTERON), the Event input is filtered. The filter function requires four successive equal valued samples of the Retrigger pin for changing its output. The Input Capture is therefore delayed by four clock cycles when the noise canceler is enabled. When the Asynchronous Event is enabled (ASYNCON), the Event input will qualify the output directly. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NEITHER|Neither Filter nor Asynchronous Event is enabled. |\\n | 0x1|FILTERON|Input Capture Noise Cancellation Filter enabled. |\\n | 0x2|ASYNCON|Asynchronous Event output qualification enabled.\\nother - Reserved. |\\n"},{},{"name":"EDGE","title":"Edge Selection","description":"This bit is used to select the active edge or level for the event input. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|FALL_LOW|The falling edge or low level of the Event input generates Retrigger or Fault action. |\\n | 1|RISE_HIGH|The rising edge or high level of the Event input generates Retrigger or Fault action. |\\n"},{},{"name":"ACTION","title":"Event Action","description":"This bit enables Capture on Event input. By default, the input will trigger a Fault, depending on the Input x register input mode (TCD.INPUTx). It is also possible to trigger a Capture on the Event input. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|FAULT|Event triggers a Fault. |\\n | 1|CAPTURE|Event triggers a Fault and Capture. |\\n"},{},{"name":"TRIGEI","title":"Trigger Event Input Enable","description":"Writing this bit to \'1\' enables Event as trigger for input A."}],"title":"Event Control x","description":null},{"offset":"0x09","name":"EVCTRLB","fields":[{"name":"CFG","size":2,"title":"Event Configuration","description":"When the Input Capture Noise canceler is activated (FILTERON), the Event input is filtered. The filter function requires four successive equal valued samples of the Retrigger pin for changing its output. The Input Capture is therefore delayed by four clock cycles when the noise canceler is enabled. When the Asynchronous Event is enabled (ASYNCON), the Event input will qualify the output directly. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NEITHER|Neither Filter nor Asynchronous Event is enabled. |\\n | 0x1|FILTERON|Input Capture Noise Cancellation Filter enabled. |\\n | 0x2|ASYNCON|Asynchronous Event output qualification enabled.\\nother - Reserved. |\\n"},{},{"name":"EDGE","title":"Edge Selection","description":"This bit is used to select the active edge or level for the event input. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|FALL_LOW|The falling edge or low level of the Event input generates Retrigger or Fault action. |\\n | 1|RISE_HIGH|The rising edge or high level of the Event input generates Retrigger or Fault action. |\\n"},{},{"name":"ACTION","title":"Event Action","description":"This bit enables Capture on Event input. By default, the input will trigger a Fault, depending on the Input x register input mode (TCD.INPUTx). It is also possible to trigger a Capture on the Event input. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|FAULT|Event triggers a Fault. |\\n | 1|CAPTURE|Event triggers a Fault and Capture. |\\n"},{},{"name":"TRIGEI","title":"Trigger Event Input Enable","description":"Writing this bit to \'1\' enables Event as trigger for input A."}],"title":"Event Control x","description":null},{"offset":"0x0C","name":"INTCTRL","fields":[{"size":4},{"name":"TRIGB"},{"name":"TRIGA"},{},{"name":"OVF","title":"Counter Overflow","description":"Writing this bit to \'1\' enables executing an interrupt at Restart of the sequence or Overflow of the counter."}],"title":"Interrupt Control","description":null},{"offset":"0x0D","name":"INTFLAGS","fields":[{"size":4},{"name":"TRIGB"},{"name":"TRIGA"},{},{"name":"OVF","title":"Overflow Interrupt Flag","description":"When a capture is overflow, this flag is raised. This bit is cleared by writing a \'1\' to it."}],"title":"Interrupt Flags","description":null},{"offset":"0x0E","name":"STATUS","fields":[{"name":"PWMACTB"},{"name":"PWMACTA"},{"size":4},{"name":"CMDRDY","title":"Command Ready","description":"This status bit tells when a command is synced to the TCD domain and the system is ready to receive new commands. The following clears the CMDRDY bit:"},{"name":"ENRDY","title":"Enable Ready","description":"This status bit tells when the ENABLE value in TCD.CTRLA is synced to the TCD domain, and is ready to be written to again. The following clears the ENRDY bit:"}],"title":"Status","description":null},{"offset":"0x10","name":"INPUTCTRLA","fields":[{"size":4},{"name":"INPUTMODE","size":4,"title":"Input Mode","description":"\\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|Input has no action |\\n | 0x1|JMPWAIT|Stop output, jump to opposite compare cycle and wait |\\n | 0x2|EXECWAIT|Stop output, execute opposite compare cycle and wait |\\n | 0x3|EXECFAULT|Stop output, execute opposite compare cycle while fault active |\\n | 0x4|FREQ|Stop all outputs, maintain frequency |\\n | 0x5|EXECDT|Stop all outputs, execute dead time while fault active |\\n | 0x6|WAIT|Stop all outputs, jump to next compare cycle and wait |\\n | 0x7|WAITSW|Stop all outputs, wait for software action |\\n | 0x8|EDGETRIG|Stop output on edge, jump to next compare cycle |\\n | 0x9|EDGETRIGFREQ|Stop output on edge, maintain frequency |\\n | 0xA|LVLTRIGFREQ|Stop output at level, maintain frequency |\\n"}],"title":"Input Control x","description":null},{"offset":"0x11","name":"INPUTCTRLB","fields":[{"size":4},{"name":"INPUTMODE","size":4,"title":"Input Mode","description":"\\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|Input has no action |\\n | 0x1|JMPWAIT|Stop output, jump to opposite compare cycle and wait |\\n | 0x2|EXECWAIT|Stop output, execute opposite compare cycle and wait |\\n | 0x3|EXECFAULT|Stop output, execute opposite compare cycle while fault active |\\n | 0x4|FREQ|Stop all outputs, maintain frequency |\\n | 0x5|EXECDT|Stop all outputs, execute dead time while fault active |\\n | 0x6|WAIT|Stop all outputs, jump to next compare cycle and wait |\\n | 0x7|WAITSW|Stop all outputs, wait for software action |\\n | 0x8|EDGETRIG|Stop output on edge, jump to next compare cycle |\\n | 0x9|EDGETRIGFREQ|Stop output on edge, maintain frequency |\\n | 0xA|LVLTRIGFREQ|Stop output at level, maintain frequency |\\n"}],"title":"Input Control x","description":null},{"offset":"0x12","name":"FAULTCTRL","fields":[{"name":"CMPDEN"},{"name":"CMPCEN"},{"name":"CMPBEN"},{"name":"CMPAEN"},{"name":"CMPD"},{"name":"CMPC"},{"name":"CMPB"},{"name":"CMPA"}],"title":"Fault Control","description":null},{"offset":"0x14","name":"DLYCTRL","fields":[{"size":2},{"name":"DLYPRESC","size":2,"title":"Delay Prescaler","description":"These bits control the prescaler settings for the blanking or output event delay. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Prescaler division factor 1 |\\n | 0x1|Prescaler division factor 2 |\\n | 0x2|Prescaler division factor 4 |\\n | 0x3|Prescaler division factor 8 |\\n"},{"name":"DLYTRIG","size":2,"title":"Delay Trigger","description":"These bits control what should trigger the blanking or output event delay. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|CMPASET|CMPASET triggers delay |\\n | 0x1|CMPACLR|CMPACLR triggers delay |\\n | 0x2|CMPBSET|CMPBSET triggers delay |\\n | 0x3|CMPBCLR|CMPASET triggers delay (end of cycle) |\\n"},{"name":"DLYSEL","size":2,"title":"Delay Select","description":"These bits control what function should be used by the delay trigger the blanking or output event delay. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Delay functionality not used |\\n | 0x1|Input blanking enabled |\\n | 0x2|Event delay enabled |\\n | 0x3|Reserved |\\n"}],"title":"Delay Control","description":null},{"offset":"0x15","name":"DLYVAL","fields":[{"name":"DLYVAL","size":8,"title":"Delay Value","description":"These bits configure the blanking/ output event delay time or event output synchronization delay in number of prescaled TCD cycles."}],"title":"Delay Value","description":null},{"offset":"0x18","name":"DITCTRL","fields":[{"size":6},{"name":"DITHERSEL","size":2,"title":"Dither Select","description":"These bits select which Compare register is using the dither function. See also 22.3.2.5 Dithering. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|ONTIMEB|On-time ramp B |\\n | 0x1|ONTIMEAB|On-time ramp A and B |\\n | 0x2|DEADTIMEB|Dead-time ramp B |\\n | 0x3|DEADTIMEAB|Dead-time ramp A and B |\\n"}],"title":"Dither Control","description":null},{"offset":"0x19","name":"DITVAL","fields":[{"size":4},{"name":"DITHER","size":4,"title":"Dither Value","description":"These bits configure the fractional adjustment of the on-time or off-time according to Dither Selection bits (DITHERSEL) in the Dither Control register (TCD.DITCTRL). The DITHER value is added to a 4-bit accumulator at the end of each TCD cycle. When the accumulator overflows the frequency adjustment will occur. The DITHER bits are doubled buffered so the new value is copied in at an update condition."}],"title":"Dither Value","description":null},{"offset":"0x1E","name":"DBGCTRL","fields":[{"size":5},{"name":"FAULTDET","title":"Fault Detection","description":"This bit defines how the peripheral behaves when stopped in Debug mode. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|NONE|No fault is generated if TCD is stopped in Debug mode. |\\n | 1|FAULT|A fault is generated and both trigger flags are set if TCD is halted in Debug mode. |\\n"},{},{"name":"DBGRUN","title":"Debug Run","description":"When written to \'1\', the peripheral will continue operating in debug mode when the CPU is halted. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control","description":null},{"offset":"0x22","name":"CAPTUREA","fields":[{"name":"CAPTURE","size":8},{"size":4},{"name":"CAPTURE","size":4}],"title":"Capture x","description":"For capture operation, these registers constitute the second buffer level and access point for the CPU. The\\nTCD.CAPTUREx registers are updated with the buffer value when an UPDATE condition occurs. CAPTURE A\\nregister contains the value from the TCD counter when a Trigger A or a software capture A occurs. CAPTURE B\\nregister contain the value from the TCD counter when Trigger B or software capture B occurs.\\nThe TCD counter value is synchronized to CAPTUREx by either software or an event.\\nThe capture register is blocked for update of new capture data until TCDn.CAPTURExH is read."},{"offset":"0x24","name":"CAPTUREB","fields":[{"name":"CAPTURE","size":8},{"size":4},{"name":"CAPTURE","size":4}],"title":"Capture x","description":"For capture operation, these registers constitute the second buffer level and access point for the CPU. The\\nTCD.CAPTUREx registers are updated with the buffer value when an UPDATE condition occurs. CAPTURE A\\nregister contains the value from the TCD counter when a Trigger A or a software capture A occurs. CAPTURE B\\nregister contain the value from the TCD counter when Trigger B or software capture B occurs.\\nThe TCD counter value is synchronized to CAPTUREx by either software or an event.\\nThe capture register is blocked for update of new capture data until TCDn.CAPTURExH is read."},{"offset":"0x28","name":"CMPASET","fields":[{"name":"CMPSET","size":8},{"size":4},{"name":"CMPSET","size":4}],"title":"Compare Set x","description":"For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\\nthe comparators are then used for generating waveforms."},{"offset":"0x2A","name":"CMPACLR","fields":[{"name":"CMPCLR","size":8},{"size":4},{"name":"CMPCLR","size":4}],"title":"Compare Clear x","description":"For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\\nthe comparators are then used for generating waveforms."},{"offset":"0x2C","name":"CMPBSET","fields":[{"name":"CMPSET","size":8},{"size":4},{"name":"CMPSET","size":4}],"title":"Compare Set x","description":"For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\\nthe comparators are then used for generating waveforms."},{"offset":"0x2E","name":"CMPBCLR","fields":[{"name":"CMPCLR","size":8},{"size":4},{"name":"CMPCLR","size":4}],"title":"Compare Clear x","description":"For compare operation, these registers are continuously compared to the counter value. Normally, the outputs form\\nthe comparators are then used for generating waveforms."}]},{"name":"RTC","datasheetPage":295,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"RUNSTDBY","title":"Run in Standby","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|RTC disabled in Standby sleep mode |\\n | 1|RTC enabled in Standby sleep mode |\\n"},{"name":"PRESCALER","size":4,"title":"Prescaler","description":"These bits define the prescaling of the CLK_RTC clock signal. Due to synchronization between the RTC clock and system clock domains, there is a latency of two RTC clock cycles from updating the register until this has an effect. Application software needs to check that the STATUS.CTRLABUSY flag is cleared before writing to this register. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DIV1|RTC clock / 1 (no prescaling) |\\n | 0x1|DIV2|RTC clock / 2 |\\n | 0x2|DIV4|RTC clock / 4 |\\n | 0x3|DIV8|RTC clock / 8 |\\n | 0x4|DIV16|RTC clock / 16 |\\n | 0x5|DIV32|RTC clock / 32 |\\n | 0x6|DIV64|RTC clock / 64 |\\n | 0x7|DIV128|RTC clock / 128 |\\n | 0x8|DIV256|RTC clock / 256 |\\n | 0x9|DIV512|RTC clock / 512 |\\n | 0xA|DIV1024|RTC clock / 1024 |\\n | 0xB|DIV2048|RTC clock / 2048 |\\n | 0xC|DIV4096|RTC clock / 4096 |\\n | 0xD|DIV8192|RTC clock / 8192 |\\n | 0xE|DIV16384|RTC clock / 16384 |\\n | 0xF|DIV32768|RTC clock / 32768 |\\n"},{"size":2},{"name":"RTCEN","title":"RTC Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|RTC disabled |\\n | 1|RTC enabled |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"STATUS","fields":[{"size":4},{"name":"CMPBUSY","title":"Compare Synchronization Busy","description":"This bit is indicating whether the RTC is busy synchronizing the Compare register (RTC.CMP) in RTC clock domain."},{"name":"PERBUSY","title":"Period Synchronization Busy","description":"This bit is indicating whether the RTC is busy synchronizing the Period register (RTC.PER) in RTC clock domain."},{"name":"CNTBUSY","title":"Counter Synchronization Busy","description":"This bit is indicating whether the RTC is busy synchronizing the Count register (RTC.CNT) in RTC clock domain."},{"name":"CTRLABUSY","title":"Control A Synchronization Busy","description":"This bit is indicating whether the RTC is busy synchronizing the Control A register (RTC.CTRLA) in RTC clock domain."}],"title":"Status","description":null},{"offset":"0x02","name":"INTCTRL","fields":[{"size":6},{"name":"CMP","title":"Compare Match Interrupt Enable","description":"Enable interrupt on compare match, i.e. when the Counter value (RTC.CNT) matches the Compare value (RTC.CMP)."},{"name":"OVF","title":"Overflow Interrupt Enable","description":"Enable interrupt on counter overflow, i.e. when the Counter value (RTC.CNT) matched the Period value (RTC.PER) and wraps around to zero."}],"title":"Interrupt Control","description":null},{"offset":"0x03","name":"INTFLAGS","fields":[{"size":6},{"name":"CMP","title":"Compare Match Interrupt Flag","description":"This flag is set when the Counter value (RTC.CNT) matches the Compare value (RTC.CMP). Writing a \'1\' to this bit clears the flag."},{"name":"OVF","title":"Overflow Interrupt Flag","description":"This flag is set when the Counter value (RTC.CNT) has reached the Period value (RTC.PER) and wrapped to zero. Writing a \'1\' to this bit clears the flag."}],"title":"Interrupt Flag","description":null},{"offset":"0x04","name":"TEMP","fields":[{"name":"TEMP","size":8,"title":"Temporary"}],"title":"Temporary","description":"The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\\nTemporary register for all the 16-bit registers of this peripheral."},{"offset":"0x05","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control","description":null},{"offset":"0x07","name":"CLKSEL","fields":[{"size":6},{"name":"CLKSEL","size":2,"title":"Clock Select","description":"Writing these bits selects the source for the RTC clock (CLK_RTC). When configuring the RTC to use either XOSC32K or the external clock on TOSC1, XOSC32K needs to be enabled and the Source Select bit (SEL) and Run Standby bit (RUNSTDBY) in the XOSC32K Control A register of the Clock Controller (CLKCTRL.XOSC32KCTRLA) must be configured accordingly. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|32KHz from OSCULP32K |\\n | 0x1|1KHz from OSCULP32K |\\n | 0x2|32.768kHz from XOSC32K |\\n | 0x3|External clock from TOSC1 pin |\\n"}],"title":"Clock Selection","description":null},{"offset":"0x08","name":"CNT","fields":[{"name":"CNT","size":8,"title":"Counter low byte","description":"These bits hold the LSB of the 16-bit counter register."},{"name":"CNT","size":8,"title":"Counter low byte","description":"These bits hold the LSB of the 16-bit counter register."}],"title":"Count","description":"The RTC.CNTL and RTC.CNTH register pair represents the 16-bit value, RTC.CNT. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC clock cycles\\nfrom updating the register until this has an effect. Application software needs to check that the STATUS.CNTBUSY\\nflag is cleared before writing to this register."},{"offset":"0x0A","name":"PER","fields":[{"name":"PER","size":8,"title":"Period low byte","description":"These bits hold the LSB of the 16-bit period register."},{"name":"PER","size":8,"title":"Period low byte","description":"These bits hold the LSB of the 16-bit period register."}],"title":"Period","description":"The RTC.PERL and RTC.PERH register pair represents the 16-bit value, RTC.PER. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nDue to synchronization between the RTC clock and system clock domains, there is a latency of two RTC clock cycles\\nfrom updating the register until this has an effect. Application software needs to check that the STATUS.PERBUSY\\nflag is cleared before writing to this register."},{"offset":"0x0C","name":"CMP","fields":[{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."},{"name":"CMP","size":8,"title":"Compare low byte","description":"These bits hold the LSB of the 16-bit compare register."}],"title":"Compare","description":"The RTC.CMPL and RTC.CMPH register pair represents the 16-bit value, RTC.CMP. The low byte [7:0] (suffix L) is\\naccessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on\\nreading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x10","name":"PITCTRLA","fields":[{"size":1},{"name":"PERIOD","size":4,"title":"Period","description":"Writing this bit field selects the number of RTC clock cycles between each interrupt. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OFF|No interrupt |\\n | 0x1|CYC4|4 cycles |\\n | 0x2|CYC8|8 cycles |\\n | 0x3|CYC16|16 cycles |\\n | 0x4|CYC32|32 cycles |\\n | 0x5|CYC64|64 cycles |\\n | 0x6|CYC128|128 cycles |\\n | 0x7|CYC256|256 cycles |\\n | 0x8|CYC512|512 cycles |\\n | 0x9|CYC1024|1024 cycles |\\n | 0xA|CYC2048|2048 cycles |\\n | 0xB|CYC4096|4096 cycles |\\n | 0xC|CYC8192|8192 cycles |\\n | 0xD|CYC16384|16384 cycles |\\n | 0xE|CYC32768|32768 cycles |\\n | 0xF|-|Reserved |\\n"},{"size":2},{"name":"PITEN","title":"Periodic Interrupt Timer Enable","description":"Writing a \'1\' to this bit enables the Periodic Interrupt Timer."}],"title":"Periodic Interrupt Timer Control A","description":null},{"offset":"0x11","name":"PITSTATUS","fields":[{"size":7},{"name":"CTRLBUSY","title":"PITCTRLA Synchronization Busy","description":"This bit indicates whether the RTC is busy synchronizing the Periodic Interrupt Timer Control A register (RTC.PITCTRLA) in the RTC clock domain."}],"title":"Periodic Interrupt Timer Status","description":null},{"offset":"0x12","name":"PITINTCTRL","fields":[{"size":7},{"name":"PI","title":"Periodic interrupt","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The periodic interrupt is disabled |\\n | 1|The periodic interrupt is enabled |\\n"}],"title":"PIT Interrupt Control","description":null},{"offset":"0x13","name":"PITINTFLAGS","fields":[{"size":7},{"name":"PI","title":"Periodic interrupt Flag","description":"This flag is set when a periodic interrupt is issued. Writing a \'1\' clears the flag."}],"title":"PIT Interrupt Flag","description":null},{"offset":"0x15","name":"PITDBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"Writing this bit to \'1\' will enable the PIT to run in Debug mode while the CPU is halted. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Periodic Interrupt Timer Debug Control","description":null}]},{"name":"USART","datasheetPage":327,"offsets":[{"offset":"0x00","name":"RXDATAL","fields":[{"name":"DATA","size":8,"title":"Receiver Data Register"}],"title":"Receiver Data Register Low Byte","description":"Reading the RXDATAL Register location will return the contents of the Receive Data Buffer Register (RXB).\\nThe receive buffer consists of a two level FIFO. The FIFO and the corresponding flags in the high byte of RXDATA\\nwill change state whenever the receive buffer is accessed (read). If CHSIZE in USART.CTRLC is set to 9BIT Low\\nbyte first, read USART.RXDATAL before USART.RXDATAH, otherwise always read USART.RXDATAH before\\nUSART.RXDATAL in order to get the correct flags."},{"offset":"0x01","name":"RXDATAH","fields":[{"name":"RXCIF","title":"USART Receive Complete Interrupt Flag","description":"This flag is set when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). When the Receiver is disabled, the receive buffer will be flushed and consequently the RXCIF will become zero."},{"name":"BUFOVF","title":"Buffer Overflow","description":"The BUFOVF flag indicates data loss due to a receiver buffer full condition. This flag is set if a Buffer Overflow condition is detected. A Buffer Overflow occurs when the receive buffer is full (two characters), it is a new character waiting in the Receive Shift Register, and a new start bit is detected. This flag is valid until the receive buffer (USART.RXDATAL) is read. This flag is not used in Master SPI mode of operation."},{"size":3},{"name":"FERR","title":"Frame Error","description":"The FERR flag indicates the state of the first stop bit of the next readable frame stored in the receive buffer. The bit is set if the received character had a Frame Error, i.e. when the first stop bit was zero, and cleared when the stop bit of the received data is \'1\'. This bit is valid until the receive buffer (USART.RXDATAL) is read. The FERR is not affected by the SBMODE bit in USART.CTRLC since the Receiver ignores all, except for the first stop bit. This flag is not used in Master SPI mode of operation."},{"name":"PERR","title":"Parity Error","description":"If parity checking is enabled and the next character in the receive buffer has a Parity Error this flag is set. If Parity Check is not enabled the PERR will always be read as zero. This bit is valid until the receive buffer (USART.RXDATAL) is read. For details on parity calculation refer to 24.3.2.2.1 Parity . If USART is set to LINAUTO mode, this bit will be a Parity Check of the Protected identifier field and will be valid when DATA[8] in USART.RXDATAH reads low. This flag is not used in Master SPI mode of operation."},{"name":"DATA[8]"}],"title":"Receiver Data Register High Byte","description":"Reading the RXDATAH Register location will return the contents of the ninth DATA bit plus status bits.\\nThe receive buffer consists of a two level FIFO. The FIFO and the corresponding flags in the high byte of\\nUSART.RXDATAH will change state whenever the receive buffer is accessed (read). If CHSIZE in USART.CTRLC is\\nset to 9BIT Low byte first, read USART.RXDATAL before USART.RXDATAH, otherwise always read\\nUSART.RXDATAH before USART.RXDATAL in order to get the correct flags."},{"offset":"0x02","name":"TXDATAL","fields":[{"name":"DATA","size":8,"title":"Transmit Data Register"}],"title":"Transmit Data Register Low Byte","description":"The Transmit Data Buffer Register (TXB) will be the destination for data written to the USART.TXDATAL Register\\nlocation.\\nFor 5-, 6-, or 7-bit characters the upper unused bits will be ignored by the Transmitter and set to zero by the Receiver.\\nThe transmit buffer can only be written when the DREIF Flag in the USART.STATUS Register is set. Data written to\\nDATA when the DREIF Flag is not set, will be ignored by the USART Transmitter. When data is written to the transmit\\nbuffer, and the Transmitter is enabled, the Transmitter will load the data into the Transmit Shift Register when the\\nShift Register is empty. The data is then transmitted on the TxD pin."},{"offset":"0x03","name":"TXDATAH","fields":[{"size":7},{"name":"DATA[8]"}],"title":"Transmit Data Register High Byte","description":"USART.TXDATAH holds the ninth data bit in the character to be transmitted when operating with serial frames with\\nnine data bits. When used this bit must be written before writing to USART.TXDATAL except if CHSIZE in\\nUSART.CTRLC is set to 9BIT Low byte first where USART.TXDATAL should be written first.\\nThis bit is unused in Master SPI mode of operation."},{"offset":"0x04","name":"STATUS","fields":[{"name":"RXCIF","title":"USART Receive Complete Interrupt Flag","description":"This flag is set to \'1\' when there are unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). When the Receiver is disabled, the receive buffer will be flushed and consequently the RXCIF will become zero. When interrupt-driven data reception is used, the receive complete interrupt routine must read the received data from RXDATA in order to clear the RXCIF. If not, a new interrupt will occur directly after the return from the current interrupt."},{"name":"TXCIF","title":"USART Transmit Complete Interrupt Flag","description":"This flag is set when the entire frame in the Transmit Shift Register has been shifted out and there are no new data in the transmit buffer (TXDATA). This flag is automatically cleared when the transmit complete interrupt vector is executed. The flag can also be cleared by writing a \'1\' to its bit location."},{"name":"DREIF","title":"USART Data Register Empty Flag","description":"The DREIF indicates if the transmit buffer (TXDATA) is ready to receive new data. The flag is set to \'1\' when the transmit buffer is empty, and is \'0\' when the transmit buffer contains data to be transmitted that has not yet been moved into the Shift Register. DREIF is set after a reset to indicate that the Transmitter is ready. Always write this bit to \'0\' when writing the STATUS register. DREIF is cleared to \'0\' by writing TXDATAL. When interrupt-driven data transmission is used, the Data Register Empty interrupt routine must either write new data to TXDATA in order to clear DREIF or disable the Data Register Empty interrupt. If not, a new interrupt will occur directly after the return from the current interrupt."},{"name":"RXSIF","title":"USART Receive Start Interrupt Flag","description":"The RXSIF flag indicates a valid start condition on RxD line. The flag is set when the system is in standby modes and a high (IDLE) to low (START) valid transition is detected on the RxD line. If the start detection is not enabled, the RXSIF will always be read as zero. This flag can only be cleared by writing a \'1\' to its bit location. This flag is not used in master SPI mode operation."},{"name":"ISFIF","title":"Inconsistent Sync Field Interrupt Flag","description":"This bit is set when the auto-baud is enabled and the sync field bit time are too fast or too slow to give a valid baud setting. It will also be set when USART is set to LINAUTO mode and the SYNC character differ from data value 0x55. Writing a \'1\' to this bit will clear the flag and bring the USART back to idle state."},{},{"name":"BDF","title":"Break Detected Flag","description":"This bit is intended for USART configured to LINAUTO receive mode, see 24.5.7 CTRLB. The break detector has a fixed threshold of 11 bits low for a BREAK to be detected. The BDF bit is set after a valid BREAK and SYNC character is detected. The bit is automatically cleared when next data is received. The bit will behave identically when USART is set to GENAUTO mode. In NORMAL or CLK2X receive mode, the BDF bit is unused. This bit is cleared by writing a \'1\' to it."},{"name":"WFB","title":"Wait For Break","description":"Writing this bit to \'1\' will register the next low and high transition on RxD line as a break character. This can be used to wait for a BREAK character of arbitrary width. Combined with USART set to GENAUTO mode, this allow the user"}],"title":"USART Status Register","description":null},{"offset":"0x05","name":"CTRLA","fields":[{"name":"RXCIE","title":"Receive Complete Interrupt Enable","description":"The bit enables the Receive Complete Interrupt (interrupt vector RXC). The enabled interrupt will be triggered when RXCIF in the USART.STATUS register is set."},{"name":"TXCIE","title":"Transmit Complete Interrupt Enable","description":"This bit enables the Transmit Complete Interrupt (interrupt vector TXC). The enabled interrupt will be triggered when the TXCIF in the USART.STATUS register is set."},{"name":"DREIE","title":"Data Register Empty Interrupt Enable","description":"This bit enables the Data Register Empty Interrupt (interrupt vector DRE). The enabled interrupt will be triggered when the DREIF in the USART.STATUS register is set."},{"name":"RXSIE","title":"Receiver Start Frame Interrupt Enable","description":"Writing a \'1\' to this bit enables the Start Frame Detector to generate an interrupt on interrupt vector RXC when a start of frame condition is detected."},{"name":"LBME","title":"Loop-back Mode Enable","description":"Writing this bit to \'1\' enables an internal connection between TxD and RxD pin."},{"name":"ABEIE","title":"Auto-baud Error Interrupt Enable","description":"Writing this bit to \'1\' enables the auto-baud error interrupt on interrupt vector RXC. The enabled interrupt will trigger for conditions where ISFIF flag is set."},{"name":"RS485","size":2,"title":"RS485 Mode","description":"These bits enable the RS485 and select the operation mode. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OFF|Disabled. |\\n | 0x1|EXT|Enables RS485 mode with control of an external line driver through a dedicated Transmit\\nEnable (TE) pin. |\\n | 0x2|INT|Enables RS485 mode with control of the internal USART transmitter. |\\n | 0x3|-|Reserved. |\\n"}],"title":"Control A","description":null},{"offset":"0x06","name":"CTRLB","fields":[{"name":"RXEN","title":"Receiver Enable","description":"Writing this bit to \u20181\u2019 enables the USART receiver. The receiver will override normal port operation for the RxD pin when enabled. Disabling the receiver will flush the receive buffer invalidating the FERR, BUFOVF, and PERR flags. In GENAUTO and LINAUTO mode, disabling the receiver will reset the auto-baud detection logic."},{"name":"TXEN","title":"Transmitter Enable","description":"Writing this bit to \u20181\u2019 enables the USART transmitter. The transmitter will override normal port operation for the TxD pin when enabled. Disabling the transmitter (writing TXEN to \'0\') will not become effective until ongoing and pending transmissions are completed (i.e. when the Transmit Shift register and Transmit Buffer register does not contain data to be transmitted). When the transmitter is disabled, it will no longer override the TxDn pin, and the pin direction is set as input automatically by hardware, even if it was configured as output by the user."},{},{"name":"SFDEN","title":"Start Frame Detection Enable","description":"Writing this bit to \u20181\u2019 enables the USART Start Frame Detection mode. The Start Frame detector is able to wake up the system from Idle or Standby Sleep modes when a high (IDLE) to low (START) transition is detected on the RxD line."},{"name":"ODME","title":"Open Drain Mode Enable","description":"Writing this bit to \u20181\u2019 makes the TxD pin to have open-drain functionality. A pull-up resistor is needed to prevent the line from floating when a logic \'1\' is output to the TxD pin."},{"name":"RXMODE","size":2,"title":"Receiver Mode","description":"In CLK2X mode, the divisor of the baud rate divider will be reduced from 16 to 8 effectively doubling the transfer rate for asynchronous communication modes. For synchronous operation, the CLK2X mode has no effect and RXMODE should always be written to \'0\'. RXMODE must be \'0\' when the USART Communication mode is configured to IRCOM. Setting RXMODE to GENAUTO enables generic auto-baud where the SYNC character is valid when eight low and high bits have been registered. In this mode, any SYNC character that gives a valid BAUD rate will be accepted. In LINAUTO mode the SYNC character is constrained and found valid if every two bits falls within 16 \xb13 baud samples of the internal baud rate and match data value 0x55. The GENAUTO and LINAUTO mode is only supported for USART operated in Asynchronous Slave mode. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NORMAL|Normal USART mode, Standard Transmission Speed |\\n | 0x1|CLK2X|Normal USART mode, Double Transmission Speed |\\n | 0x2|GENAUTO|Generic Auto-baud mode |\\n | 0x3|LINAUTO|LIN Constrained Auto-baud mode |\\n"},{"name":"MPCM","title":"Multi-Processor Communication Mode","description":"Writing a \u20181\u2019 to this bit enables the Multi-Processor Communication mode: the USART receiver ignores all the incoming frames that do not contain address information. The transmitter is unaffected by the MPCM setting. For more detailed information see 24.3.2.10 Multiprocessor Communication Mode."}],"title":"Control B","description":null},{"offset":"0x07","name":"CTRLC","fields":[{"name":"CMODE","size":2,"title":"USART Communication Mode","description":"Writing these bits selects the communication mode of the USART. Writing a value different than 0x3 to these bits alters the available bit fields in this register, see Control C - Async Mode. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|ASYNCHRONOUS|Asynchronous USART |\\n | 0x1|SYNCHRONOUS|Synchronous USART |\\n | 0x2|IRCOM|Infrared Communication |\\n | 0x3|MSPI|Master SPI |\\n"},{"name":"PMODE","size":2,"title":"Parity Mode","description":"Writing these bits enables and selects the type of parity generation. When enabled, the Transmitter will automatically generate and send the parity of the transmitted data bits within each frame. The Receiver will generate a parity value for the incoming data, compare it to the PMODE setting, and set the Parity Error flag (PERR) in the Status register (USART.STATUS) if a mismatch is detected. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DISABLED|Disabled |\\n | 0x1|-|Reserved |\\n | 0x2|EVEN|Enabled, Even Parity |\\n | 0x3|ODD|Enabled, Odd Parity |\\n"},{"name":"SBMODE","title":"Stop Bit Mode","description":"Writing this bit selects the number of stop bits to be inserted by the Transmitter. The Receiver ignores this setting. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|1 stop bit |\\n | 1|2 stop bits |\\n"},{"name":"CHSIZE","size":3,"title":"Character Size","description":"Writing these bits select the number of data bits in a frame. The Receiver and Transmitter use the same setting. For"}],"title":"Control C - Master SPI Mode","description":"This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\\nCMODE values, see Control C - Async Mode the correct description.\\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."},{"offset":"0x07","name":"CTRLC","fields":[{"size":1},{"name":"CMODE","size":2,"title":"USART Communication Mode","description":"Writing these bits selects the communication mode of the USART. Writing a value different than 0x3 to these bits alters the available bit fields in this register, see Control C - Async Mode. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|ASYNCHRONOUS|Asynchronous USART |\\n | 0x1|SYNCHRONOUS|Synchronous USART |\\n | 0x2|IRCOM|Infrared Communication |\\n | 0x3|MSPI|Master SPI |\\n"},{"size":3},{"name":"UDORD","title":"Data Order","description":"Writing this bit selects the frame format. The Receiver and Transmitter use the same setting. Changing the setting of UDORD will corrupt all ongoing communication for both receiver and transmitter. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|MSB of the data word is transmitted first |\\n | 1|LSB of the data word is transmitted first |\\n"},{"name":"UCPHA","title":"Clock Phase","description":"The UCPHA bit setting determine if data is sampled on the leading (first) edge or tailing (last) edge of XCKn. Refer to the 24.3.2.1.5 Master SPI Mode Clock Generation for details."}],"title":"Control C - Master SPI Mode","description":"This register description is only valid when the USART is in Master SPI mode (CMODE written to MSPI). For other\\nCMODE values, see Control C - Async Mode the correct description.\\nSee 24.3.2.5 USART in Master SPI mode for full description of the Master SPI Mode operation."},{"offset":"0x08","name":"BAUD","fields":[{"name":"BAUD","size":8,"title":"USART Baud Rate low byte","description":"These bits hold the LSB of the 16-bit Baud register."},{"name":"BAUD","size":8,"title":"USART Baud Rate low byte","description":"These bits hold the LSB of the 16-bit Baud register."}],"title":"Baud Register","description":"The USART.BAUDL and USART.BAUDH register pair represents the 16-bit value, USART.BAUD. The low byte [7:0]\\n(suffix L) is accessible at the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more\\ndetails on reading and writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nOngoing transmissions of the Transmitter and Receiver will be corrupted if the baud rate is changed. Writing this\\nregister will trigger an immediate update of the baud rate prescaler. For more information of how to set the baud rate,\\nsee Table 24-2"},{"offset":"0x0B","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control Register","description":null},{"offset":"0x0C","name":"EVCTRL","fields":[{"size":7},{"name":"IREI","title":"IrDA Event Input Enable","description":"This bit enables the event source for the IRCOM Receiver. If event input is selected for the IRCOM Receiver, the input from the USART\u2019s RX pin is automatically disabled."}],"title":"IrDA Control Register","description":null},{"offset":"0x0D","name":"TXPLCTRL","fields":[{"name":"TXPL","size":8,"title":"Transmitter Pulse Length","description":"The 8-bit value sets the pulse modulation scheme for the transmitter. Setting this register will only have effect if IRCOM mode is selected by a USART. By leaving this register value to zero, 3/16 of baud rate period pulse modulation is used. Setting this value from 1 to 254 will give a fixed pulse length coding. The 8-bit value sets the number of system clock periods for the pulse. The start of the pulse will be synchronized with the rising edge of the baud rate clock. Setting the value to 255 (0xFF) will disable pulse coding, letting the RX and TX signals pass through the IRCOM Module unaltered. This enables other features through the IRCOM Module, such as half-duplex USART, Loop-back testing and USART RX input from an Event Channel. TXPL must be configured before USART transmitter is enabled (TXEN)."}],"title":"IRCOM Transmitter Pulse Length Control Register","description":null},{"offset":"0x0E","name":"RXPLCTRL","fields":[{"size":1},{"name":"RXPL","size":7,"title":"Receiver Pulse Length","description":"The 8-bit value sets the filter coefficient for the IRCOM transceiver. Setting this register will only have effect if IRCOM mode is selected by a USART. By leaving this register value to zero, filtering is disabled. Setting this value between 0x01 and 0xFF will enable filtering, where x+1 equal samples are required for the pulse to be accepted. RXPL must be configured before USART receiver is enabled (RXEN)."}],"title":"IRCOM Receiver Pulse Length Control Register","description":null}]},{"name":"SPI","datasheetPage":353,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"DORD","title":"Data Order","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The MSB of the data word is transmitted first. |\\n | 1|The LSB of the data word is transmitted first. |\\n"},{"name":"MASTER","title":"Master/Slave Select","description":"Write this bit to configure SPI in desired mode. If SS is configured as input and driven low while this bit is \'1\', this bit is cleared, and the IF flag in SPI.INTFLAGS is set. The user has to write MASTER=1 again to re-enable SPI Master mode. This behavior is controlled by the Slave Select Disable bit (SSD) in SPI.CTRLB. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|SPI Slave mode selected |\\n | 1|SPI Master mode selected |\\n"},{"name":"CLK2X","title":"Clock Double","description":"When this bit is written to \'1\' the SPI speed (SCK frequency, after internal prescaler) is doubled in Master mode. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|SPI speed (SCK frequency) is not doubled. |\\n | 1|SPI speed (SCK frequency) is doubled in Master mode |\\n"},{},{"name":"PRESC","size":2,"title":"Prescaler","description":"This bit field controls the SPI clock rate configured in master mode. These bits have no effect in slave mode. The relationship between SCK and the peripheral clock frequency (fCLK_PER) is shown below. The output of the SPI prescaler can be doubled by writing the CLK2X bit to \'1\'. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DIV4|CLK_PER/4 |\\n | 0x1|DIV16|CLK_PER/16 |\\n | 0x2|DIV64|CLK_PER/64 |\\n | 0x3|DIV128|CLK_PER/128 |\\n"},{"name":"ENABLE","title":"SPI Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|SPI is disabled. |\\n | 1|SPI is enabled. |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"name":"BUFEN","title":"Buffer Mode Enable","description":"Writing this bit to \'1\' enables Buffer Mode, meaning two buffers in receive direction, one buffer in transmit direction, and separate interrupt flags for both transmit complete and receive complete."},{"name":"BUFWR","title":"Buffer Mode Wait for Receive","description":"When writing this bit to \'0\' the first data transferred will be a dummy sample. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|One SPI transfer must be completed before the data is copied into the shift register. |\\n | 1|When writing to the data register when the SPI is enabled and SS is high, the first write will go directly\\nto the shift register. |\\n"},{"size":3},{"name":"SSD","title":"Slave Select Disable","description":"When this bit is set and when operating as SPI Master (MASTER=1 in SPI.CTRLA), SS does not disable Master Mode. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Enable the Slave Select line when operating as SPI Master. |\\n | 1|Disable the Slave Select line when operating as SPI Master. |\\n"},{"name":"MODE","size":2,"title":"Mode","description":"These bits select the transfer mode. The four combinations of SCK phase and polarity with respect to the serial data are shown in the table below. These bits decide whether the first edge of a clock cycle (leading edge) is rising or falling, and whether data setup and sample occur on the leading or trailing edge. When the leading edge is rising, the SCK signal is low when idle, and when the leading edge is falling, the SCK signal is high when idle. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|0|Leading edge: Rising, sample\\nTrailing edge: Falling, setup |\\n | 0x1|1|Leading edge: Rising, setup\\nTrailing edge: Falling, sample |\\n | 0x2|2|Leading edge: Falling, sample\\nTrailing edge: Rising, setup |\\n | 0x3|3|Leading edge: Falling, setup\\nTrailing edge: Rising, sample |\\n"}],"title":"Control B","description":null},{"offset":"0x02","name":"INTCTRL","fields":[{"name":"RXCIE","title":"Receive Complete Interrupt Enable","description":"In buffer mode this bit enables the receive complete interrupt. The enabled interrupt will be triggered when the RXCIF flag in the INTFLAG register is set. In non-buffer mode this bit is zero."},{"name":"TXCIE","title":"Transfer Complete Interrupt Enable","description":"In buffer mode this bit enables the transfer complete interrupt. The enabled interrupt will be triggered when the TXCIF flag in the INTFLAG register is set. In non-buffer mode this bit is zero."},{"name":"DREIE","title":"Data Register Empty Interrupt Enable","description":"In buffer mode this bit enables the data register empty interrupt. The enabled interrupt will be triggered when the DREIF flag in the INTFLAG register is set. In non-buffer mode this bit is zero."},{"name":"SSIE","title":"Slave Select Trigger Interrupt Enable","description":"In buffer mode this bit enables the Slave Select interrupt. The enabled interrupt will be triggered when the SSIF flag in the INTFLAG register is set. In non-buffer mode this bit is zero."},{"size":3},{"name":"IE","title":"Interrupt Enable","description":"This bit enables the SPI interrupt when the SPI is not in buffer mode. The enabled interrupt will be triggered when RXCIF/IF is set in the INTFLAG register."}],"title":"Interrupt Control","description":null},{"offset":"0x03","name":"INTFLAGS","fields":[{"name":"RXCIF/IF","title":"Receive Complete Interrupt Flag/Interrupt Flag","description":"RXCIF: In buffer mode this flag is set when there is unread data in the receive buffer and cleared when the receive buffer is empty (i.e., does not contain any unread data). In non-buffer mode this bit does not have any effect. When interrupt-driven data reception is used, the receive complete interrupt routine must read the received data from DATA in order to clear RXCIF. If not, a new interrupt will occur directly after the return from the current interrupt. This flag can also be cleared by writing a one to its bit location. IF: This flag is set when a serial transfer is complete and one byte is completely shifted in/out of the DATA register. If SS is configured as input and is driven low when the SPI is in master mode, this will also set this flag. IF is cleared by hardware when executing the corresponding interrupt vector. Alternatively, the IF flag can be cleared by first reading the SPI.INTFLAGS register when IF is set, and then accessing the DATA register."},{"name":"TXCIF/WRCOL","title":"Transfer Complete Interrupt Flag/Write Collision Flag","description":"TXCIF: In buffer mode this flag is set when all the data in the transmit shift register has been shifted out and there are no new data in the transmit buffer (DATA). The flag is cleared by writing a one to its bit location. In non-buffer mode this bit does not have any effect. WRCOL: The WRCOL flag is set if the DATA register is written to before a complete byte has been shifted out. This flag is cleared by first reading the SPI.INTFLAGS register when WRCOL is set, and then accessing the DATA register."},{"name":"DREIF","title":"Data Register Empty Interrupt Flag","description":"In buffer mode this flag indicates whether the transmit buffer (DATA) is ready to receive new data. The flag is one when the transmit buffer is empty and zero when the transmit buffer contains data to be transmitted that has not yet been moved into the shift register. DREIF is set to \'0\' after a reset to indicate that the transmitter is ready. In nonbuffer mode this bit is always zero. DREIF is cleared by writing DATA. When interrupt-driven data transmission is used, the data register empty interrupt routine must either write new data to DATA in order to clear DREIF or disable the data register empty interrupt. If not, a new interrupt will occur directly after the return from the current interrupt."},{"name":"SSIF","title":"Slave Select Trigger Interrupt Flag","description":"In buffer mode this flag indicates that the SPI has been in master mode and the SS line has been pulled low externally so the SPI is now working in slave mode. The flag will only be set if the Slave Select Disable bit (SSD) is not \'1\'. The flag is cleared by writing a one to its bit location. In non-buffer mode this bit is always zero."},{"size":3},{"name":"BUFOVF","title":"Buffer Overflow","description":"This flash is only used in buffer mode. This flag indicates data loss due to a receiver buffer full condition. This flag is set if a buffer overflow condition is detected. A buffer overflow occurs when the receive buffer is full (two characters) and a third byte has been received in the shift register. If there is no transmit data the buffer overflow will not be set before the start of a new serial transfer. This flag is valid until the receive buffer (DATA) is read. Always write this bit location to zero when writing the SPI.INTFLAGS register. In non-buffer mode this bit is always zero"}],"title":"Interrupt Flags","description":null},{"offset":"0x04","name":"DATA","fields":[{"name":"DATA","size":8,"title":"SPI Data","description":"The DATA register is used for sending and receiving data. Writing to the register initiates the data transmission, and the byte written to the register will be shifted out on the SPI output line. Reading this register in buffer mode will read the second receive buffer and the contents of the first receive buffer will be moved to the second receive buffer."}],"title":"Data","description":null}]},{"name":"TWI","datasheetPage":373,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":4},{"name":"SDASETUP","title":"SDA Setup Time","description":"By default, there are 4 clock cycles of setup time on SDA out signal while reading from slave part of the TWI module. Writing this bit to \'1\' will change the setup time to 8 clocks. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|4CYC|SDA setup time is 4 clock cycles |\\n | 1|8CYC|SDA setup time is 8 clock cycle |\\n"},{"name":"SDAHOLD","size":2,"title":"SDA Hold Time","description":"Writing these bits selects the SDA hold time. Table 26-3.\u2000SDA Hold Time SDAHOLD[1:0] Nominal Hold Time Hold Time Range across All Corners (ns) Description"},{"name":"FMPEN","title":"FM Plus Enable","description":"Writing these bits selects the 1MHz bus speed (Fast mode plus, Fm+) for the TWI in default configuration. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Fm+ disabled |\\n | 1|Fm+ enabled |\\n"}],"title":"Control A","description":null},{"offset":"0x02","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Control","description":null},{"offset":"0x03","name":"MCTRLA","fields":[{"name":"RIEN","title":"Read Interrupt Enable","description":"Writing this bit to \'1\' enables interrupt on the Master Read Interrupt Flag (RIF) in the Master Status register (TWI.MSTATUS). A TWI Master read interrupt would be generated only if this bit, the RIF, and the Global Interrupt Flag (I) in CPU.SREG are all \'1\'."},{"name":"WIEN","title":"Write Interrupt Enable","description":"Writing this bit to \'1\' enables interrupt on the Master Write Interrupt Flag (WIF) in the Master Status register (TWI.MSTATUS). A TWI Master write interrupt will be generated only if this bit, the WIF, and the Global Interrupt Flag (I) in CPU.SREG are all \'1\'."},{},{"name":"QCEN","title":"Quick Command Enable","description":"Writing this bit to \'1\' enables Quick Command. When Quick Command is enabled, the corresponding interrupt flag is set immediately after the slave acknowledges the address. At this point the software can either issue a Stop command or a repeated Start by writing either the Command bits (CMD) in the Master Control B register (TWI.MCTRLB) or the Master Address register (TWI.MADDR)."},{"name":"TIMEOUT","size":2,"title":"Inactive Bus Timeout","description":"\\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DISABLED|Bus timeout disabled. I2C. |\\n | 0x1|50US|50\xb5s - SMBus (assume baud is set to 100kHz) |\\n | 0x2|100US|100\xb5s (assume baud is set to 100kHz) |\\n | 0x3|200US|200\xb5s (assume baud is set to 100kHz) |\\n"},{"name":"SMEN","title":"Smart Mode Enable","description":"Writing this bit to \'1\' enables the Master smart mode. When smart mode is enabled, the acknowledge action is sent immediately after reading the Master Data (TWI.MDATA) register."},{"name":"ENABLE","title":"Enable TWI Master","description":"Writing this bit to \'1\' enables the TWI as Master."}],"title":"Master Control A","description":null},{"offset":"0x04","name":"MCTRLB","fields":[{"size":4},{"name":"FLUSH","title":"Flush","description":"Writing a \'1\' to this bit generates a strobe for one clock cycle disabling and then enabling the master. Writing \'0\' has no effect. The purpose is to clear the internal state of master: For TWI master to transmit successfully, it is recommended to write the Master Address register (TWI.MADDR) first and then the Master Data register (TWI.MDATA). The peripheral will transmit invalid data if TWI.MDATA is written before TWI.MADDR. To avoid this invalid transmission, write \'1\' to this bit to clear both registers."},{"name":"ACKACT","title":"Acknowledge Action","description":"This bit defines the master\u2019s behavior under certain conditions defined by the bus protocol state and software interaction. The acknowledge action is performed when DATA is read, or when an execute command is written to the CMD bits. The ACKACT bit is not a flag or strobe, but an ordinary read/write accessible register bit. The default ACKACT for master read interrupt is \u201cSend ACK\u201d (0). For master write, the code will know that no acknowledge should be sent since it is itself sending data. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Send ACK |\\n | 1|Send NACK |\\n"},{"name":"CMD","size":2,"title":"Command","description":"The master command bits are strobes. These bits are always read as zero. Writing to these bits triggers a master operation as defined by the table below. Table 26-4.\u2000Command Settings CMD[1:0] DIR Description"}],"title":"Master Control B","description":null},{"offset":"0x05","name":"MSTATUS","fields":[{"name":"RIF","title":"Read Interrupt Flag","description":"This bit is set to \'1\' when the master byte read operation is successfully completed, i.e. no arbitration lost or bus error occurred during the operation. The read operation is triggered by software reading DATA or writing to ADDR registers with bit ADDR[0] written to \'1\'. A slave device must have responded with an ACK to the address and direction byte transmitted by the master for this flag to be set. Writing a \'1\' to this bit will clear the RIF. However, normal use of the TWI does not require the flag to be cleared by this method. Clearing the RIF bit will follow the same software interaction as the CLKHOLD flag. The RIF flag can generate a master read interrupt (see description of the RIEN control bit in the TWI.MCTRLA register)."},{"name":"WIF","title":"Write Interrupt Flag","description":"This bit is set when a master transmit address or byte write is completed, regardless of the occurrence of a bus error or an arbitration lost condition. Writing a \'1\' to this bit will clear the WIF. However, normal use of the TWI does not require the flag to be cleared by this method. Clearing the WIF bit will follow the same software interaction as the CLKHOLD flag. The WIF flag can generate a master write interrupt (see description of the WIEN control bit in the TWI.MCTRLA register)."},{"name":"CLKHOLD","title":"Clock Hold","description":"If read as \'1\', this bit indicates that the master is currently holding the TWI clock (SCL) low, stretching the TWI clock period. Writing a \'1\' to this bit will clear the CLKHOLD flag. However, normal use of the TWI does not require the CLKHOLD flag to be cleared by this method, since the flag is automatically cleared when accessing several other TWI registers. The CLKHOLD flag can be cleared by:"},{"name":"RXACK","title":"Received Acknowledge","description":"This bit is read-only and contains to the most recently received acknowledge bit from slave."},{"name":"ARBLOST","title":"Arbitration Lost","description":"If read as \'1\' this bit indicates that the master has lost arbitration while transmitting a high data or NACK bit, or while issuing a start or repeated start condition (S/Sr) on the bus."},{"name":"BUSERR","title":"Bus Error","description":"The BUSERR flag indicates that an illegal bus condition has occurred. An illegal bus condition is detected if a protocol violating start (S), repeated start (Sr), or stop (P) is detected on the TWI bus lines. A start condition directly followed by a stop condition is one example of protocol violation. Writing a \'1\' to this bit will clear the BUSERR. However, normal use of the TWI does not require the BUSERR to be cleared by this method. A robust TWI driver software design will treat the bus error flag similarly to the ARBLOST flag, assuming the bus ownership is lost when the bus error flag is set. As for the ARBLOST flag, the next software operation of writing the TWI.MADDR register will consequently clear the BUSERR flag. For bus error to be detected, the bus state logic must be enabled and the system frequency must be 4x the SCL frequency."},{"name":"BUSSTATE","size":2,"title":"Bus State","description":"These bits indicate the current TWI bus state as defined in the table below. After a System Reset or re-enabling, the TWI master bus state will be unknown. The change of bus state is dependent on bus activity. Writing 0x1 to the BUSSTATE bits forces the bus state logic into its \'idle\' state. However, the bus state logic cannot be forced into any other state. When the master is disabled, the bus-state is \'unknown\'. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|UNKNOWN|Unknown bus state |\\n | 0x1|IDLE|Bus is idle |\\n | 0x2|OWNER|This TWI controls the bus |\\n | 0x3|BUSY|The bus is busy |\\n"}],"title":"Master Status","description":"Normal TWI operation dictates that this register is regarded purely as a read-only register. Clearing any of the status\\nflags is done indirectly by accessing the Master transmits address (TWI.MADDR), Master Data register\\n(TWI.MDATA), or the Command bits (CMD) in the Master Control B register (TWI.MCTRLB)."},{"offset":"0x06","name":"MBAUD","fields":[{"name":"BAUD","size":8,"title":"Baud Rate","description":"This bit field is used to derive the SCL high and low time and should be written while the master is disabled (ENABLE bit in TWI.MCTRLA is \'0\'). For more information on how to calculate the frequency, see 26.3.4.2.1 Clock Generation."}],"title":"Master Baud Rate","description":null},{"offset":"0x07","name":"MADDR","fields":[{"name":"ADDR","size":8,"title":"Address","description":"When this bit field is written, a START condition and slave address protocol sequence is initiated dependent on the bus state. If the bus state is unknown the Master Write Interrupt Flag (WIF) and bus error flag (BUSERR) in the Master Status register (TWI.MSTATUS) are set and the operation is terminated. If the bus is busy the master awaits further operation until the bus becomes idle. When the bus is or becomes idle, the master generates a START condition on the bus, copies the ADDR value into the data shift register (TWI.MDATA) and performs a byte transmit operation by sending the contents of the data register onto the bus. The master then receives the response i.e. the acknowledge bit from the slave. After completing the operation the bus clock (SCL) is forced and held low only if arbitration was not lost. The CLKHOLD bit in the Master Setup register (TWI.MSETUP) is set accordingly. Completing the operation sets the WIF in the Master Status register (TWI.MSTATUS). If the bus is already owned, a repeated start (Sr) sequence is performed. In two ways the repeated start (Sr) sequence deviates from the start sequence. Firstly, since the bus is already owned by the master, no wait for idle bus state is necessary. Secondly, if the previous transaction was a read, the acknowledge action is sent before the repeated start bus condition is issued on the bus. The master receives one data byte from the slave before the master sets the Master Read Interrupt Flag (RIF) in the Master Status register (TWI.MSTATUS). All TWI Master flags are cleared automatically when this bit field is written. This includes bus error, arbitration lost, and both master interrupt flags. This register can be read at any time without interfering with ongoing bus activity, since a read access does not trigger the master logic to perform any bus protocol related operations. The master control logic uses bit 0 of the TWI.MADDR register as the bus protocol\u2019s read/write flag (R/W)."}],"title":"Master Address","description":null},{"offset":"0x08","name":"MDATA","fields":[{"name":"DATA","size":8,"title":"Data","description":"The bit field gives direct access to the masters physical shift register which is used both to shift data out onto the bus (write) and to shift in data received from the bus (read). The direct access implies that the data register cannot be accessed during byte transmissions. Build-in logic prevents any write access to this register during the shift operations. Reading valid data or writing data to be transmitted can only be successfully done when the bus clock (SCL) is held low by the master, i.e. when the CLKHOLD bit in the Master Status register (TWI.MSTATUS) is set. However, it is not necessary to check the CLKHOLD bit in software before accessing this register if the software keeps track of the present protocol state by using interrupts or observing the interrupt flags. Accessing this register assumes that the master clock hold is active, auto-triggers bus operations dependent of the state of the acknowledge action command bit (ACKACT) in TWI.MSTATUS and type of register access (read or write). A write access to this register will, independent of ACKACT in TWI.MSTATUS, command the master to perform a byte transmit operation on the bus directly followed by receiving the acknowledge bit from the slave. When the acknowledge bit is received, the Master Write Interrupt Flag (WIF) in TWI.MSTATUS is set regardless of any bus errors or arbitration. If operating in a multi-master environment, the interrupt handler or application software must check the Arbitration Lost Status Flag (ARBLOST) in TWI.MSTATUS before continuing from this point. If the arbitration was lost, the application software must decide to either abort or to resend the packet by rewriting this register. The entire operation is performed (i.e. all bits are clocked), regardless of winning or losing arbitration before the write interrupt flag is set. When arbitration is lost, only \'1\'s are transmitted for the remainder of the operation, followed by a write interrupt with ARBLOST flag set. Both TWI master interrupt flags are cleared automatically when this register is written. However, the Master Arbitration Lost and Bus Error flags are left unchanged. Reading this register triggers a bus operation, dependent on the setting of the acknowledge action command bit (ACKACT) in TWI.MSTATUS. Normally the ACKACT bit is preset to either ACK or NACK before the register read operation. If ACK or NACK action is selected, the transmission of the acknowledge bit precedes the release of the clock hold. The clock is released for one byte, allowing the slave to put one byte of data on the bus. The Master Read Interrupt flag RIF in TWI.MSTATUS is then set if the procedure was successfully executed. However, if arbitration was lost when sending NACK, or a bus error occurred during the time of operation, the Master Write Interrupt flag (WIF) is set instead. Observe that the two master interrupt flags are mutual exclusive, i.e. both flags will not be set simultaneously. Both TWI master interrupt flags are cleared automatically if this register is read while ACKACT is set to either ACK or NACK. However, arbitration lost and bus error flags are left unchanged."}],"title":"Master DATA","description":null},{"offset":"0x09","name":"SCTRLA","fields":[{"name":"DIEN","title":"Data Interrupt Enable","description":"Writing this bit to \'1\' enables interrupt on the Slave Data Interrupt Flag (DIF) in the Slave Status register (TWI.SSTATUS). A TWI slave data interrupt will be generated only if this bit, the DIF, and the Global Interrupt Flag (I) in CPU.SREG are all \'1\'."},{"name":"APIEN","title":"Address or Stop Interrupt Enable","description":"Writing this bit to \'1\' enables interrupt on the Slave Address or Stop Interrupt Flag (APIF) in the Slave Status register (TWI.SSTATUS). A TWI slave address or stop interrupt will be generated only if the this bit, APIF, PIEN in this register, and the Global Interrupt Flag (I) in CPU.SREG are all \'1\'. The slave stop interrupt shares the interrupt vector with slave address interrupt. The AP bit determines which caused the interrupt."},{"name":"PIEN","title":"Stop Interrupt Enable","description":"Writing this bit to \'1\' enables APIF to be set when a STOP condition occurs. To use this feature the system frequency must be 4x the SCL frequency."},{"size":2},{"name":"PMEN","title":"Address Recognition Mode","description":"If this bit is written to \'1\', the slave address match logic responds to all received addresses. If this bit is written to \'0\', the address match logic uses the slave address register (TWI.SADDR) to determine which address to recognize as the slaves own address."},{"name":"SMEN","title":"Smart Mode Enable","description":"Writing this bit to \'1\' enables the slave smart mode. When smart mode is enabled, issuing a command with CMD or reading/writing DATA resets the interrupt and operation continues. If smart mode is disabled, the slave always waits for a CMD command before continuing."},{"name":"ENABLE","title":"Enable TWI Slave","description":"Writing this bit to \'1\' enables the TWI slave."}],"title":"Slave Control A","description":null},{"offset":"0x0A","name":"SCTRLB","fields":[{"size":5},{"name":"ACKACT","title":"Acknowledge Action","description":"This bit defines the slave\u2019s behavior under certain conditions defined by the bus protocol state and software interaction. The table below lists the acknowledge procedure performed by the slave if action is initiated by software. The acknowledge action is performed when TWI.SDATA is read or written, or when an execute command is written to the CMD bits in this register. The ACKACT bit is not a flag or strobe, but an ordinary read/write accessible register bit. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|ACK|Send ACK |\\n | 1|NACK|Send NACK |\\n"},{"name":"CMD","size":2,"title":"Command","description":"Unlike the acknowledge action bits, the slave command bits are strobes. These bits always read as zero. Writing to these bits trigger a slave operation as defined in the table below. Table 26-5.\u2000Command Settings CMD[1:0] DIR Description"}],"title":"Slave Control B","description":null},{"offset":"0x0B","name":"SSTATUS","fields":[{"name":"DIF","title":"Data Interrupt Flag","description":"This flag is set when a slave byte transmit or byte receive operation is successfully completed without any bus error. The flag can be set with an unsuccessful transaction in case of collision detection (see description of the COLL status bit). Writing a \'1\' to its bit location will clear the DIF. However, normal use of the TWI does not require the DIF flag to be cleared by using this method, since the flag is automatically cleared when:"},{"name":"APIF","title":"Address or Stop Interrupt Flag","description":"This flag is set when the slave address match logic detects that a valid address has been received or by a stop condition. Writing a \'1\' to its bit location will clear the APIF. However, normal use of the TWI does not require the flag to be cleared by this method since the flag is cleared using same software interactions as described for the DIF flag. The APIF flag can be used to generate a slave address or stop interrupt (see description of the AIEN control bit in TWI.CTRLA). Take special note of that the slave stop interrupt shares the interrupt vector with slave address interrupt."},{"name":"CLKHOLD","title":"Clock Hold","description":"If read as \'1\', the slave clock hold flag indicates that the slave is currently holding the TWI clock (SCL) low, stretching the TWI clock period. This is a read only bit that is set when an address or data interrupt is set. Resetting the corresponding interrupt will indirectly reset this flag."},{"name":"RXACK","title":"Received Acknowledge","description":"This bit is read only and contains to the most recently received acknowledge bit from the master."},{"name":"COLL","title":"Collision","description":"If read as \'1\', the transmit collision flag indicates that the slave has not been able to transmit a high data or NACK bit. If a slave transmit collision is detected, the slave will commence its operation as normal, except no low values will be shifted out onto the SDA line (i.e., when the COLL flag is set to \'1\' it disables the data and acknowledge output from the slave logic). DIF flag will be set to \'1\' at the end as a result of internal completion of unsuccessful transaction. Similarly when collision occurs because slave is not been able to transmit NACK bit, it means address match already happened and APIF flag is set as a result. APIF/DIF flags can only generate interrupt whose handlers can be used to check for the collision. Writing a \'1\' to its bit location will clear the COLL flag. However, the flag is automatically cleared if any START condition (S/Sr) is detected. This flag is intended for systems where address resolution protocol (ARP) is employed. However, a detected collision in non-ARP situations indicates that there has been a protocol violation and should be treated as a bus error."},{"name":"BUSERR","title":"Bus Error","description":"The BUSERR flag indicates that an illegal bus condition has occurred. An illegal bus condition is detected if a protocol violating start (S), repeated start (Sr), or stop (P) is detected on the TWI bus lines. A start condition directly followed by a stop condition is one example of protocol violation. Writing a \'1\' to its bit location will clear the BUSERR flag. However, normal use of the TWI does not require the BUSERR to be cleared by this method. A robust TWI driver software design will assume that the entire packet of data has been corrupted and restart by waiting for a new START condition (S). The TWI bus error detector is part of the TWI Master circuitry. For bus errors to be detected, the TWI Master must be enabled (ENABLE bit in TWI.MCTRLA is \'1\'), and the system clock frequency must be at least four times the SCL frequency."},{"name":"DIR","title":"Read/Write Direction","description":"This bit is read only and indicates the current bus direction state. The DIR bit reflects the direction bit value from the last address packet received from a master TWI device. If this bit is read as \'1\', a master read operation is in progress. Consequently a \'0\' indicates that a master write operation is in progress."},{"name":"AP","title":"Address or Stop","description":"When the TWI slave address or stop interrupt flag (APIF) is set, this bit determines whether the interrupt is due to address detection or a stop condition. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|STOP|A stop condition generated the interrupt on APIF. |\\n | 1|ADR|Address detection generated the interrupt on APIF. |\\n"}],"title":"Slave Status","description":"Normal TWI operation dictates that the slave status register should be regarded purely as a read-only register.\\nClearing any of the status flags will indirectly be done when accessing the slave data (TWI.SDATA) register or the\\nCMD bits in the Slave Control B register (TWI.SCTRLB)."},{"offset":"0x0C","name":"SADDR","fields":[{"name":"ADDR","size":8,"title":"Address","description":"The slave address register in combination with the slave address mask register (TWI.SADDRMASK) is used by the slave address match logic to determine if a master TWI device has addressed the TWI slave. The slave address interrupt flag (APIF) is set to one if the received address is recognized. The slave address match logic supports recognition of 7- and 10-bits addresses, and general call address. When using 7-bit or 10-bit address recognition mode, the upper 7-bits of the address register (ADDR[7:1]) represents the slave address and the least significant bit (ADDR[0]) is used for general call address recognition. Setting the ADDR[0] bit in this case enables the general call address recognition logic. The TWI slave address match logic only support recognition of the first byte of a 10-bit address i.e. by setting ADDRA[7:1] = \u201c0b11110aa\u201d where \u201caa\u201d represents bit 9 and 8 or the slave address. The second 10-bit address byte must be handled by software."}],"title":"Slave Address","description":null},{"offset":"0x0D","name":"SDATA","fields":[{"name":"DATA","size":8,"title":"Data","description":"The slave data register I/O location (DATA) provides direct access to the slave\'s physical shift register, which is used both to shift data out onto the bus (transmit) and to shift in data received from the bus (receive). The direct access implies that the data register cannot be accessed during byte transmissions. Built-in logic prevents any write accesses to the data register during the shift operations. Reading valid data or writing data to be transmitted can only be successfully done when the bus clock (SCL) is held low by the slave, i.e. when the slave CLKHOLD bit is set. However, it is not necessary to check the CLKHOLD bit in software before accessing the slave DATA register if the software keeps track of the present protocol state by using interrupts or observing the interrupt flags. Accessing the slave DATA register, assumed that clock hold is active, auto-trigger bus operations dependent of the state of the slave acknowledge action command bits (ACKACT) and type of register access (read or write)."}],"title":"Slave Data","description":null},{"offset":"0x0E","name":"SADDRMASK","fields":[{"name":"ADDRMASK","size":7,"title":"Address Mask","description":"The ADDRMASK register acts as a second address match register, or an address mask register depending on the ADDREN setting. If ADDREN is written to \'0\', ADDRMASK can be loaded with a 7-bit Slave Address mask. Each of the bits in ADDRMASK register can mask (disable) the corresponding address bits in the TWI slave Address Register (ADDR). If the mask bit is written to \'1\' then the address match logic ignores the compare between the incoming address bit and the corresponding bit in slave ADDR register. In other words, masked bits will always match. If ADDREN is written to \'1\', the slave ADDRMASK can be loaded with a second slave address in addition to the ADDR register. In this mode, the slave will match on 2 unique addresses, one in ADDR and the other in ADDRMASK."},{"name":"ADDREN","title":"Address Mask Enable","description":"If this bit is written to \'1\', the slave address match logic responds to the 2 unique addresses in slave ADDR and ADDRMASK. If this bit is \'0\', the ADDRMASK register acts as a mask to the slave ADDR register."}],"title":"Slave Address Mask","description":null}]},{"name":"CRCSCAN","datasheetPage":395,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"RESET","title":"Reset CRCSCAN","description":"Writing this bit to \'1\' resets the CRCSCAN peripheral: The CRCSCAN Control registers and STATUS register (CTRLA, CTRLB, STATUS) will be cleared one clock cycle after the RESET bit was written to \'1\'. If NMIEN is \'0\', this bit is writable both when the CRCSCAN is busy (the BUSY bit in CRCSCAN.STATUS is \'1\') and not busy (the BUSY bit is \'0\'), and will take effect immediately. If NMIEN is \'1\', this bit is only writable when the CRCSCAN is not busy (the BUSY bit in CRCSCAN.STATUS is \'0\'). The RESET bit is a strobe bit."},{"size":5},{"name":"NMIEN","title":"Enable NMI Trigger","description":"When this bit is written to \'1\', any CRC failure will trigger an NMI. This can only be cleared by a system Reset - it is not cleared by a write to the RESET bit. This bit can only be written to \'1\' when the CRCSCAN is not busy (the BUSY bit in CRCSCAN.STATUS is \'0\')."},{"name":"ENABLE","title":"Enable CRCSCAN","description":"Writing this bit to \'1\' enables the CRCSCAN peripheral with the current settings. It will stay \'1\' even after a CRC check has completed, but writing it to \u20181\u2019 again will start a new check. Writing the bit to \'0\' will disable the CRCSCAN after the ongoing check is completed (after reaching the end of the section it is set up to check). A failure in the ongoing check will still be detected and can cause an NMI if the NMIEN bit is \'1\'. The CRCSCAN can be enabled during the internal Reset initialization to verify Flash sections before letting the CPU start normal code execution (see the device data sheet fuse description). If the CRCSCAN is enabled during the internal Reset initialization, the ENABLE bit will read as \'1\' when normal code execution starts. To see whether the CRCSCAN peripheral is busy with an ongoing check, poll the Busy bit (BUSY) in the STATUS register (CRCSCAN.STATUS)."}],"title":"Control A","description":"If an NMI has been triggered, this register is not writable."},{"offset":"0x01","name":"CTRLB","fields":[{"size":2},{"name":"MODE","size":2,"title":"CRC Flash Access Mode","description":"The CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see the device data sheet fuse description). If the CRC is enabled during internal Reset initialization, the MODE bit field will read out non-zero when normal code execution starts. To ensure proper operation of the CRC under code execution, write the MODE bit to 0x0 again. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|PRIORITY|The CRC module runs a single check with priority to Flash. The CPU is halted until the\\nCRC completes.\\nother - Reserved |\\n"},{"size":2},{"name":"SRC","size":2,"title":"CRC Source","description":"The SRC bit field selects which section of the Flash the CRC module should check. To set up section sizes, refer to the fuse description. The CRC can be enabled during internal Reset initialization to verify Flash sections before letting the CPU start (see fuse description). If the CRC is enabled during internal Reset initialization, the SRC bit field will read out as FLASH, BOOTAPP, or BOOT when normal code execution starts (depending on the configuration). \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|FLASH|The CRC is performed on the entire Flash (boot, application code, and application data\\nsections). |\\n | 0x1|BOOTAPP|The CRC is performed on the boot and application code sections of Flash. |\\n | 0x2|BOOT|The CRC is performed on the boot section of Flash. |\\n | 0x3|-|Reserved. |\\n"}],"title":"Control B","description":"The CTRLB register contains the mode and source settings for the CRC. It is not writable when the CRC is busy or\\nwhen an NMI has been triggered."},{"offset":"0x02","name":"STATUS","fields":[{"size":6},{"name":"OK","title":"CRC OK","description":"When this bit is read as \'1\', the previous CRC completed successfully. The bit is set to \'1\' from Reset but is cleared to \'0\' when enabling. As long as the CRC module is busy, it will be read \'0\'. When running continuously, the CRC status must be assumed OK until it fails or is stopped by the user."},{"name":"BUSY","title":"CRC Busy","description":"When this bit is read as \'1\', the CRC module is busy. As long as the module is busy, the access to the control registers is limited."}],"title":"Status","description":"The STATUS register contains the busy and OK information. It is not writable, only readable."}]},{"name":"CCL","datasheetPage":410,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"size":1},{"name":"RUNSTDBY","title":"Run in Standby","description":"This bit indicates if the peripheral clock (CLK_PER) is kept running in Standby sleep mode. The setting is ignored for configurations where the CLK_PER is not required. For details refer to 28.3.4 Sleep Mode Operation. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|System clock is not required in standby sleep mode. |\\n | 1|System clock is required in standby sleep mode. |\\n"},{"size":5},{"name":"ENABLE","title":"Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is disabled. |\\n | 1|The peripheral is enabled. |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"SEQCTRL0","fields":[{"size":4},{"name":"SEQSEL","size":4,"title":"Sequential Selection","description":"These bits select the sequential configuration. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DISABLE|Sequential logic is disabled |\\n | 0x1|DFF|D flip flop |\\n | 0x2|JK|JK flip flop |\\n | 0x3|LATCH|D latch |\\n | 0x4|RS|RS latch\\nOther - Reserved |\\n"}],"title":"Sequential Control 0","description":null},{"offset":"0x05","name":"LUT0CTRLA","fields":[{"name":"EDGEDET","title":"Edge Detection","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Edge detector is disabled. |\\n | 1|Edge detector is enabled. |\\n"},{"name":"CLKSRC","title":"Clock Source Selection","description":"This bit selects whether the peripheral clock (CLK_PER) or any input present on input line 2 (IN[2]) is used as clock (CLK_MUX_OUT) for a LUT. The CLK_MUX_OUT of the even LUT is used for clocking the Sequential block of a LUT pair. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|CLK_PER is clocking the LUT. |\\n | 1|IN[2] is clocking the LUT. |\\n"},{"name":"FILTSEL","size":2,"title":"Filter Selection","description":"These bits select the LUT output filter options: Filter Selection \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DISABLE|Filter disabled |\\n | 0x1|SYNCH|Synchronizer enabled |\\n | 0x2|FILTER|Filter enabled |\\n | 0x3|-|Reserved |\\n"},{"name":"OUTEN","title":"Output Enable","description":"This bit enables the LUT output to the LUTnOUT pin. When written to \'1\', the pin configuration of the PORT I/OController is overridden. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Output to pin disabled. |\\n | 1|Output to pin enabled. |\\n"},{"size":2},{"name":"ENABLE","title":"LUT Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The LUT is disabled. |\\n | 1|The LUT is enabled. |\\n"}],"title":"LUT n Control A","description":null},{"offset":"0x06","name":"LUT0CTRLB","fields":[{"name":"INSEL1","size":4,"title":"LUT n Input 1 Source Selection","description":"These bits select the source for input 1 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN1 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO1 input source |\\n | 0x9|TCD0|TCD WOB input source |\\n | 0xA|USART0|USART TXD input source |\\n | 0xB|SPI0|SPI MOSI input source |\\n"},{"name":"INSEL0","size":4,"title":"LUT n Input 0 Source Selection","description":"These bits select the source for input 0 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN0 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO0 input source |\\n | 0x9|TCD0|TCD WOAn input source |\\n | 0xA|USART0|USART XCK input source |\\n | 0xB|SPI0|SPI SCK input source\\nOther - Reserved |\\n"}],"title":"LUT n Control B","description":"SPI connections to the CCL work only in master SPI mode.\\nUSART connections to the CCL work only in asynchronous/synchronous USART Master mode."},{"offset":"0x07","name":"LUT0CTRLC","fields":[{"size":4},{"name":"INSEL2","size":4,"title":"LUT n Input 2 Source Selection","description":"These bits select the source for input 2 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN2 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO2 input source |\\n | 0x9|TCD0|TCD WOA input source |\\n | 0xA|-|Reserved |\\n | 0xB|SPI0|SPI MISO input source\\nother - Reserved |\\n"}],"title":"LUT n Control C","description":null},{"offset":"0x08","name":"TRUTH0","fields":[{"name":"TRUTH","size":8,"title":"Truth Table","description":"These bits define the value of truth logic as a function of inputs IN[2:0]."}],"title":"TRUTHn","description":null},{"offset":"0x09","name":"LUT1CTRLA","fields":[{"name":"EDGEDET","title":"Edge Detection","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Edge detector is disabled. |\\n | 1|Edge detector is enabled. |\\n"},{"name":"CLKSRC","title":"Clock Source Selection","description":"This bit selects whether the peripheral clock (CLK_PER) or any input present on input line 2 (IN[2]) is used as clock (CLK_MUX_OUT) for a LUT. The CLK_MUX_OUT of the even LUT is used for clocking the Sequential block of a LUT pair. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|CLK_PER is clocking the LUT. |\\n | 1|IN[2] is clocking the LUT. |\\n"},{"name":"FILTSEL","size":2,"title":"Filter Selection","description":"These bits select the LUT output filter options: Filter Selection \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DISABLE|Filter disabled |\\n | 0x1|SYNCH|Synchronizer enabled |\\n | 0x2|FILTER|Filter enabled |\\n | 0x3|-|Reserved |\\n"},{"name":"OUTEN","title":"Output Enable","description":"This bit enables the LUT output to the LUTnOUT pin. When written to \'1\', the pin configuration of the PORT I/OController is overridden. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Output to pin disabled. |\\n | 1|Output to pin enabled. |\\n"},{"size":2},{"name":"ENABLE","title":"LUT Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The LUT is disabled. |\\n | 1|The LUT is enabled. |\\n"}],"title":"LUT n Control A","description":null},{"offset":"0x0A","name":"LUT1CTRLB","fields":[{"name":"INSEL1","size":4,"title":"LUT n Input 1 Source Selection","description":"These bits select the source for input 1 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN1 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO1 input source |\\n | 0x9|TCD0|TCD WOB input source |\\n | 0xA|USART0|USART TXD input source |\\n | 0xB|SPI0|SPI MOSI input source |\\n"},{"name":"INSEL0","size":4,"title":"LUT n Input 0 Source Selection","description":"These bits select the source for input 0 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN0 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO0 input source |\\n | 0x9|TCD0|TCD WOAn input source |\\n | 0xA|USART0|USART XCK input source |\\n | 0xB|SPI0|SPI SCK input source\\nOther - Reserved |\\n"}],"title":"LUT n Control B","description":"SPI connections to the CCL work only in master SPI mode.\\nUSART connections to the CCL work only in asynchronous/synchronous USART Master mode."},{"offset":"0x0B","name":"LUT1CTRLC","fields":[{"size":4},{"name":"INSEL2","size":4,"title":"LUT n Input 2 Source Selection","description":"These bits select the source for input 2 of LUT n: \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|MASK|Masked input |\\n | 0x1|FEEDBACK|Feedback input |\\n | 0x2|LINK|Linked other LUT as input source |\\n | 0x3|EVENT0|Event input source 0 |\\n | 0x4|EVENT1|Event input source 1 |\\n | 0x5|IO|I/O pin LUTn-IN2 input source |\\n | 0x6|AC0|AC0 OUT input source |\\n | 0x7|TCB0|TCB WO input source |\\n | 0x8|TCA0|TCA WO2 input source |\\n | 0x9|TCD0|TCD WOA input source |\\n | 0xA|-|Reserved |\\n | 0xB|SPI0|SPI MISO input source\\nother - Reserved |\\n"}],"title":"LUT n Control C","description":null},{"offset":"0x0C","name":"TRUTH1","fields":[{"name":"TRUTH","size":8,"title":"Truth Table","description":"These bits define the value of truth logic as a function of inputs IN[2:0]."}],"title":"TRUTHn","description":null}]},{"name":"AC","datasheetPage":421,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"RUNSTDBY","title":"Run in Standby Mode","description":"Writing a \'1\' to this bit allows the AC to continue operation in Standby sleep mode. Since the clock is stopped, interrupts and status flags are not updated. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|In Standby sleep mode, the peripheral is halted |\\n | 1|In Standby sleep mode, the peripheral continues operation |\\n"},{"name":"OUTEN","title":"Analog Comparator Output Pad Enable","description":"Writing this bit to \'1\' makes the OUT signal available on the pin."},{"name":"INTMODE","size":2,"title":"Interrupt Modes","description":"Writing to these bits selects what edge(s) of the AC output an interrupt request is triggered. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|BOTHEDGE|Both negative and positive edge |\\n | 0x1|-|Reserved |\\n | 0x2|NEGEDGE|Negative edge |\\n | 0x3|POSEDGE|Positive edge |\\n"},{"name":"LPMODE","title":"Low Power Mode","description":"Writing a \'1\' to this bit reduces the current through the comparator. This reduces power consumption, but increases the reaction time of the AC. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Low Power Mode disabled |\\n | 1|Low Power Mode enabled |\\n"},{"name":"HYSMODE","size":2,"title":"Hysteresis Mode Select","description":"Writing these bits selects the hysteresis mode for the AC input. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|OFF|OFF |\\n | 0x1|10|\xb110mV |\\n | 0x2|25|\xb125mV |\\n | 0x3|50|\xb150mV |\\n"},{"name":"ENABLE","title":"Enable AC","description":"Writing this bit to \'1\' enables the AC."}],"title":"Control A","description":null},{"offset":"0x02","name":"MUXCTRLA","fields":[{"name":"INVERT","title":"Invert AC Output","description":"Writing a \'1\' to this bit enables inversion of the output of the AC. This effectively inverts the input to all the peripherals connected to the signal, and also affects the internal status signals. Writing to this bit field selects the input signal to the positive input of the AC. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0|AINP0|Positive Pin 0 |\\n | 1|Reserved|Reserved |\\n"},{"size":5},{"name":"MUXNEG","size":2,"title":"Negative Input MUX Selection","description":"Writing to this bit field selects the input signal to the negative input of the AC. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|AINN0|Negative Pin 0 |\\n | 0x1|Reserved|Reserved |\\n | 0x2|VREF|Voltage Reference |\\n | 0x3|DAC|DAC output. |\\n"}],"title":"Mux Control A","description":"AC.MUXCTRLA controls Analog Comparator Muxes"},{"offset":"0x06","name":"INTCTRL","fields":[{"size":7},{"name":"CMP","title":"Analog Comparator Interrupt Enable","description":"Writing this bit to \'1\' enables Analog Comparator Interrupt."}],"title":"Interrupt Control","description":null},{"offset":"0x07","name":"STATUS","fields":[{"size":3},{"name":"STATE","title":"Analog Comparator State","description":"This shows current status of the OUT signal from the AC. This will have a synchronizer delay to get updated in the I/O register (3 cycles)."},{"size":3},{"name":"CMP","title":"Analog Comparator Interrupt Flag","description":"This is the interrupt flag for AC. Writing a \'1\' to this bit will clear the Interrupt flag."}],"title":"Status","description":null}]},{"name":"ADC","datasheetPage":437,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"RUNSTBY","title":"Run in Standby","description":"This bit determines whether the ADC needs to run when the chip is in standby sleep mode."},{"size":4},{"name":"RESSEL","title":"Resolution Selection","description":"This bit selects the ADC resolution. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Full 10-bit resolution. The 10-bit ADC results are accumulated or stored to the ADC Result register\\n(ADC.RES). |\\n | 1|8-bit resolution. The conversion results are truncated to 8 bits (MSBs) before they are accumulated or\\nstored to the ADC Result register (ADC.RES). The two least significant bits are discarded. |\\n"},{"name":"FREERUN","title":"Free Running","description":"Writing a \'1\' to this bit will enable Free Running mode for the data acquisition. The first conversion is started by writing COMMAND.STCONV bit high. In Free running mode, a new conversion cycle is started immediately after or as soon as the previous conversion cycle has completed. This is signaled by INTFLAGS.RESRDY."},{"name":"ENABLE","title":"ADC Enable","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|ADC is disabled. |\\n | 1|ADC is enabled. |\\n"}],"title":"Control A","description":null},{"offset":"0x01","name":"CTRLB","fields":[{"size":5},{"name":"SAMPNUM","size":3,"title":"Sample Accumulation Number Select","description":"These bits select how many consecutive ADC sampling results are accumulated automatically. When this bit is written to a value greater than 0x0, the according number of consecutive ADC sampling results are accumulated into the ADC Result register (RES) in one complete conversion. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No accumulation. |\\n | 0x1|ACC2|2 results accumulated. |\\n | 0x2|ACC4|4 results accumulated. |\\n | 0x3|ACC8|8 results accumulated. |\\n | 0x4|ACC16|16 results accumulated. |\\n | 0x5|ACC32|32 results accumulated. |\\n | 0x6|ACC64|64 results accumulated. |\\n | 0x7|-|Reserved. |\\n"}],"title":"Control B","description":null},{"offset":"0x02","name":"CTRLC","fields":[{"size":1},{"name":"SAMPCAP","title":"Sample Capacitance Selection","description":"This bit selects the sample capacitance, and hence, the input impedance. The best value is dependent on the reference voltage and the application\'s electrical properties. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|Recommended for reference voltage values below 1V. |\\n | 1|Reduced size of sampling capacitance. Recommended for higher reference voltages. |\\n"},{"name":"REFSEL","size":2,"title":"Reference Selection","description":"These bits selects the voltage reference for the ADC. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|INTERNAL|Internal reference |\\n | 0x1|VDD|VDD\\nOther - Reserved. |\\n"},{},{"name":"PRESC","size":3,"title":"Prescaler","description":"These bits defines the division factor from peripheral clock (CLK_PER) to the ADC clock (CLK_ADC). \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DIV2|CLK_PER divided by 2 |\\n | 0x1|DIV4|CLK_PER divided by 4 |\\n | 0x2|DIV8|CLK_PER divided by 8 |\\n | 0x3|DIV16|CLK_PER divided by 16 |\\n | 0x4|DIV32|CLK_PER divided by 32 |\\n | 0x5|DIV64|CLK_PER divided by 64 |\\n | 0x6|DIV128|CLK_PER divided by 128 |\\n | 0x7|DIV256|CLK_PER divided by 256 |\\n"}],"title":"Control C","description":null},{"offset":"0x03","name":"CTRLD","fields":[{"name":"INITDLY","size":3,"title":"Initialization Delay","description":"These bits defines the initialization/startup delay before the first sample when enabling the ADC or changing to internal reference voltage. Setting this delay will ensure that the reference, muxes, etc are ready before starting the first conversion. The initialization delay will also take place when waking up from deep sleep to do a measurement. The delay is expressed as a number of CLK_ADC cycles. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|DLY0|Delay 0 CLK_ADC cycles. |\\n | 0x1|DLY16|Delay 16 CLK_ADC cycles. |\\n | 0x2|DLY32|Delay 32 CLK_ADC cycles. |\\n | 0x3|DLY64|Delay 64 CLK_ADC cycles. |\\n | 0x4|DLY128|Delay 128 CLK_ADC cycles. |\\n | 0x5|DLY256|Delay 256 CLK_ADC cycles.\\nOther - Reserved |\\n"},{"name":"ASDV","title":"Automatic Sampling Delay Variation","description":"Writing this bit to \'1\' enables automatic sampling delay variation between ADC conversions. The purpose of varying sampling instant is to randomize the sampling instant and thus avoid standing frequency components in frequency spectrum. The value of the SAMPDLY bits is automatically incremented by one after each sample. When the Automatic Sampling Delay Variation is enabled and the SAMPDLY value reaches 0xF, it wraps around to"},{"name":"SAMPDLY","size":4,"title":"Sampling Delay Selection","description":"These bits define the delay between consecutive ADC samples. The programmable Sampling Delay allows modifying the sampling frequency during hardware accumulation, to suppress periodic noise sources that may otherwise disturb the sampling. The SAMPDLY field can be also modified automatically from sampling cycle to another, by setting the ASDV bit. The delay is expressed as CLK_ADC cycles and is given directly by the bitfield setting. The sampling cap is kept open during the delay."}],"title":"Control D","description":null},{"offset":"0x04","name":"CTRLE","fields":[{"size":5},{"name":"WINCM","size":3,"title":"Window Comparator Mode","description":"This field enable and define when the interrupt flag is set in Window Comparator mode. RESULT is the 16-bit accumulator result. WINLT and WINHT are 16-bit lower threshold value and 16-bit higher threshold value, respectively. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x0|NONE|No Window Comparison (default) |\\n | 0x1|BELOW|RESULT < WINLT |\\n | 0x2|ABOVE|RESULT > WINHT |\\n | 0x3|INSIDE|WINLT < RESULT < WINHT |\\n | 0x4|OUTSIDE|RESULT < WINLT or RESULT >WINHT)\\nOther - Reserved |\\n"}],"title":"Control E","description":null},{"offset":"0x05","name":"SAMPCTRL","fields":[{"size":3},{"name":"SAMPLEN","size":5,"title":"Sample Length","description":"These bits extend the ADC sampling length in number of CLK_ADC cycles. By default the sampling time is two CLK_ADC cycles. Increasing the sampling length allows sampling sources with higher impedance. The total conversion time increased with the selected sampling length."}],"title":"Sample Control","description":null},{"offset":"0x06","name":"MUXPOS","fields":[{"size":3},{"name":"MUXPOS","size":5,"title":"MUXPOS","description":"This bit field selects which single-ended analog input is connected to the ADC. If these bits are changed during a conversion, the change will not take effect until this conversion is complete. \\n | Value | Name | Description |\\n | ----- | ---- | ----------- |\\n | 0x00|AIN0|ADC input pin 0 |\\n | 0x01|AIN1|ADC input pin 1 |\\n | 0x02|AIN2|ADC input pin 2 |\\n | 0x03|AIN3|ADC input pin 3 |\\n | 0x04|AIN4|ADC input pin 4 |\\n | 0x05|AIN5|ADC input pin 5 |\\n | 0x06|AIN6|ADC input pin 6 |\\n | 0x07|AIN7|ADC input pin 7 |\\n | 0x08|-|Reserved |\\n | 0x09|-|Reserved |\\n | 0x0A|AIN10|ADC input pin 10 |\\n | 0x0B|AIN11|ADC input pin 11 |\\n | 0x1C|DAC0|DAC0 |\\n | 0x1D|INTREF|Internal reference (from VREF peripheral) |\\n | 0x1F|GND|0V (GND)\\nOther - Reserved |\\n"}],"title":"MUXPOS","description":null},{"offset":"0x08","name":"COMMAND","fields":[{"size":7},{"name":"STCONV","title":"Start Conversion","description":"Writing a \'1\' to this bit will start a single measurement. If in free running mode this will start the first conversion. STCONV will read as \'1\' as long as a conversion is in progress. When the conversion is complete, this bit is automatically cleared. Writing the bit to \'0\' during an ongoing conversion will stop the conversion."}],"title":"Command","description":null},{"offset":"0x09","name":"EVCTRL","fields":[{"size":7},{"name":"STARTEI","title":"Start Event Input","description":"This bit enables event input as source for conversion start."}],"title":"Event Control","description":null},{"offset":"0x0A","name":"INTCTRL","fields":[{"size":6},{"name":"WCOMP","title":"Window Comparator Interrupt Enable","description":"Writing a \'1\' to this bit enables window comparator interrupt."},{"name":"RESRDY","title":"Result Ready Interrupt Enable","description":"Writing a \'1\' to this bit enables result ready interrupt."}],"title":"Interrupt Control","description":null},{"offset":"0x0B","name":"INTFLAGS","fields":[{"size":6},{"name":"WCOMP","title":"Window Comparator Interrupt Flag","description":"This window comparator flag is set when the measurement is complete and if the result match the selected window comparator mode defined by WINCM (ADCn.CTRLE). The comparison is done at end of conversion. The flag is cleared by either writing a \'1\' to the bit position or by reading the result register (ADCn.RES). Writing a \'0\' to this bit has no effect."},{"name":"RESRDY","title":"Result Ready Interrupt Flag","description":"The result ready interrupt flag is set when a measurement is complete and a new result is ready. The flag is cleared by either writing a \'1\' to the bit location or by reading the result register (ADCn.RES). Writing a \'0\' to this bit has no effect."}],"title":"Interrupt Flags","description":null},{"offset":"0x0C","name":"DBGCTRL","fields":[{"size":7},{"name":"DBGRUN","title":"Debug Run","description":"\\n | Value | Description |\\n | ----- | ----------- |\\n | 0|The peripheral is halted in break debug mode and ignores events. |\\n | 1|The peripheral will continue to run in break debug mode when the CPU is halted. |\\n"}],"title":"Debug Run","description":null},{"offset":"0x0D","name":"TEMP","fields":[{"name":"TEMP","size":8,"title":"Temporary","description":"Temporary register for read/write operations in 16-bit registers."}],"title":"Temporary","description":"The Temporary register is used by the CPU for single-cycle, 16-bit access to the 16-bit registers of this peripheral. It\\ncan also be read and written by software. See also 8.5.6 Accessing 16-bit Registers. There is one common\\nTemporary register for all the 16-bit registers of this peripheral."},{"offset":"0x10","name":"RES","fields":[{"name":"RES","size":8,"title":"Result low byte","description":"These bits constitute the LSB of ADC/Accumulator Result, (RES) register. The data format in ADC and Digital Accumulation is 1\u2019s complement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale)."},{"name":"RES","size":8,"title":"Result low byte","description":"These bits constitute the LSB of ADC/Accumulator Result, (RES) register. The data format in ADC and Digital Accumulation is 1\u2019s complement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale)."}],"title":"Result","description":"The RESL and RESH register pair represents the 16-bit value, RES. The low byte [7:0] (suffix L) is accessible at the\\noriginal offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading and\\nwriting 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nIf the analog input is higher than the reference level of the ADC, the 10 bit ADC result will be equal the max value of\\n0x3FF. Likewise, if the input is below 0V, the ADC result will be 0x000. As the ADC cannot produce a result above\\n0x3FF values, the accumulated value will never exceed 0xFFC0 even after maximum allowed 64 accumulations."},{"offset":"0x12","name":"WINLT","fields":[{"name":"WINLT","size":8,"title":"Window Comparator Low Threshold low byte","description":"These bits hold the LSB of the 16-bit register."},{"name":"WINLT","size":8,"title":"Window Comparator Low Threshold low byte","description":"These bits hold the LSB of the 16-bit register."}],"title":"Window Comparator Low Threshold","description":"This register is the 16-bit Low Threshold for the digital comparator monitoring the RES register. The ADC itself has\\n10-bit output, RES[9:0], where the msb is RES[9]. The data format in ADC and Digital Accumulation is one\u2019s\\ncomplement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale).\\nThe WINLTH and WINLTL register pair represent the 16-bit value, WINLT. The low byte [7:0] (suffix L) is accessible at\\nthe original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading and\\nwriting 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers.\\nWhen accumulating samples, the window comparator thresholds are applied on the accumulated value and not on\\neach sample."},{"offset":"0x14","name":"WINHT","fields":[{"name":"WINHT","size":8,"title":"Window Comparator High Threshold low byte","description":"These bits hold the LSB of the 16-bit register."},{"name":"WINHT","size":8,"title":"Window Comparator High Threshold low byte","description":"These bits hold the LSB of the 16-bit register."}],"title":"Window Comparator High Threshold","description":"This register is the 16-bit High Threshold for the digital comparator monitoring the RES register. The ADC itself has\\n10-bit output, RES[9:0], where the msb is RES[9]. The data format in ADC and Digital Accumulation is one\u2019s\\ncomplement, where 0x0000 represents the zero and 0xFFFF represent the largest number (full scale).\\nThe WINHTH and WINHTL register pair represent the 16-bit value, WINHT. The low byte [7:0] (suffix L) is accessible\\nat the original offset. The high byte [15:8] (suffix H) can be accessed at offset + 0x01. For more details on reading\\nand writing 16-bit registers, refer to 8.5.6 Accessing 16-bit Registers."},{"offset":"0x16","name":"CALIB","fields":[{"size":7},{"name":"DUTYCYC","title":"Duty Cycle","description":"This bit determines the duty cycle of the ADC clock. ADCclk > 1.5 MHz requires a minimum operating voltage of 2.7V \\n | Value | Description |\\n | ----- | ----------- |\\n | 0|50% Duty Cycle must be used if ADCclk > 1.5 MHz |\\n | 1|25% Duty Cycle (high 25% and low 75%) must be used for ADCclk \u2264 1.5 MHz |\\n"}],"title":"Calibration","description":null}]},{"name":"DAC","datasheetPage":458,"offsets":[{"offset":"0x00","name":"CTRLA","fields":[{"name":"RUNSTDBY","title":"Run in Standby Mode","description":"If this bit is written to \'1\', the DAC or Output Buffer will not automatically be disabled when the device is entering Standby sleep mode."},{"name":"OUTEN","title":"Output Buffer Enable","description":"Writing a \'1\' to this bit enables the Output Buffer and sends the OUT signal to a pin."},{"size":5},{"name":"ENABLE","title":"DAC Enable","description":"Writing a \'1\' to this bit enables the DAC."}],"title":"Control A","description":null},{"offset":"0x01","name":"DATA","fields":[{"name":"DATA","size":8,"title":"Data","description":"These bits contains the digital data which will be converted to an analog voltage."}],"title":"DATA","description":null}]},{"name":"UPDI","datasheetPage":485,"offsets":[{"offset":"0x00","name":"STATUSA","fields":[{"size":4},{"name":"UPDIREV","size":4,"title":"UPDI Revision","description":"These bits are read-only and contain the revision of the current UPDI implementation."}],"title":"Status A","description":null},{"offset":"0x01","name":"STATUSB","fields":[{"size":5},{"name":"PESIG","size":3,"title":"UPDI Error Signature","description":"These bits describe the UPDI Error Signature, and is set when an internal UPDI error condition occurs. The PESIG field is cleared on a read from the debugger. Table 33-7.\u2000Valid Error Signatures PESIG[2:0] Error Type Error Description"}],"title":"Status B","description":null},{"offset":"0x02","name":"CTRLA","fields":[{"name":"IBDLY","title":"Inter-Byte Delay Enable","description":"Writing a \'1\' to this bit enables a fixed inter-byte delay between each data byte transmitted from the UPDI when doing multi-byte LD(S). The fixed length is two IDLE characters. Before the first transmitted byte will use the regular GT delay used for direction change."},{},{"name":"PARD","title":"Parity Disable","description":"Writing this bit to \'1\' will disable parity detection in the UPDI by just ignoring the Parity bit. This feature is recommended only during testing."},{"name":"DTD","title":"Disable Timeout Detection","description":"Setting this bit disables the timeout detection on the PHY layer, which requests a response from the ACC layer within a specified time (65536 UPDI clock cycles)."},{"name":"RSD","title":"Response Signature Disable","description":"Writing a \'1\' to this bit will disable any response signatures generated by the UPDI. This is to reduce the protocol overhead to a minimum when writing large blocks of data to the NVM space. Disabling the Response Signature should be used with caution, and only when the delay experienced by the UPDI when accessing the system bus is predictable, otherwise loss of data may occur."},{"name":"GTVAL","size":3,"title":"Guard Time Value","description":"This bit field selects the Guard Time Value that will be used by the UPDI when the transmission mode switches from RX to TX. The Guard time is equal to the Baud Rate used in 1-Wire mode. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|UPDI Guard Time: 128 cycles (default) |\\n | 0x1|UPDI Guard Time: 64 cycles |\\n | 0x2|UPDI Guard Time: 32 cycles |\\n | 0x3|UPDI Guard Time: 16 cycles |\\n | 0x4|UPDI Guard Time: 8 cycles |\\n | 0x5|UPDI Guard Time: 4 cycles |\\n | 0x6|UPDI Guard Time: 2 cycles |\\n | 0x7|GT off (no extra Idle bits inserted) |\\n"}],"title":"Control A","description":null},{"offset":"0x03","name":"CTRLB","fields":[{"size":5},{"name":"NACKDIS","title":"Disable NACK Response","description":"Writing this bit to \'1\' disables the NACK signature sent by the UPDI if a System Reset is issued during an ongoing LD(S) and ST(S) operation."},{"name":"CCDETDIS","title":"Collision and Contention Detection Disable","description":"If this bit is written to \'0\', contention detection is enabled for 1W mode. This means that the UPDI can detect a collision in an ongoing 1-Wire transmission."},{"name":"UPDIDIS","title":"UPDI Disable","description":"Writing a \'1\' to this bit disables the UPDI PHY interface. The clock request from the UPDI is lowered, and the UPDI is reset. All UPDI PHY configurations and KEYs will be reset when the UPDI is disabled."}],"title":"Control B","description":null},{"offset":"0x07","name":"ASI_KEY_STATUS","fields":[{"size":5},{"name":"UROWWRITE","title":"User Row Write Key Status","description":"This bit is set to \'1\' if the UROWWRITE KEY is active. Otherwise this bit reads as zero."},{"name":"NVMPROG","title":"NVM Programming","description":"This bit is set to \'1\' if the NVMPROG KEY is active. This bit is automatically reset after the programming sequence is done. Otherwise this bit reads as zero."},{"name":"CHIPERASE","title":"Chip Erase","description":"This bit is set to \'1\' if the CHIPERASE KEY is active. This bit will automatically be reset when the chip erase sequence is completed. Otherwise this bit reads as zero."}],"title":"ASI Key Status","description":null},{"offset":"0x08","name":"ASI_RESET_REQ","fields":[{"name":"RSTREQ","size":8,"title":"Reset Request","description":"A Reset is signalized to the System when writing the Reset signature 0x59h to this address. Writing any other signature to this register will clear the Reset. When reading this register, reading bit RSTREQ[0] will tell if the UPDI is holding an active Reset on the system. If this bit is \'1\', the UPDI has an active Reset request to the system. All other bits will read as \'0\'. The UPDI will not be reset when issuing a System Reset from this register."}],"title":"ASI Reset Request","description":null},{"offset":"0x09","name":"ASI_CTRLA","fields":[{"size":6},{"name":"UPDICLKSEL","size":2,"title":"UPDI Clock Select","description":"Writing these bits selects the UPDI clock output frequency. Default setting after reset and enable is 4MHz. Any other clock output selection is only recommended when the BOD is at the highest level. For all other BOD settings, the default 4MHz selection is recommended. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Reserved |\\n | 0x1|16MHz UPDI clock |\\n | 0x2|8MHz UPDI clock |\\n | 0x3|4MHz UPDI clock (Default Setting) |\\n"}],"title":"ASI Control A","description":null},{"offset":"0x0A","name":"ASI_SYS_CTRLA","fields":[{"size":6},{"name":"UROWWRITE_FINAL","title":"User Row Programming Done","description":"This bit should be written through the UPDI when the user row data has been written to the RAM. Writing this bit will start the process of programming the user row data to the FLASH. If this bit is written before the User Row code is written to RAM by the UPDI, the CPU will progress without the written data. This bit is only writable if the Userrow-write KEY is successfully decoded."},{"name":"CLKREQ","title":"Request System Clock","description":"If this bit is written to \'1\', the ASI is requesting the system clock, independent of system sleep modes. This makes it possible for the UPDI to access the ACC layer, also if the system is in sleep mode. Writing a zero to this bit will lower the clock request. This bit will be reset when the UPDI is disabled. This bit is set by default when the UPDI is enabled in any mode (Fuse, 12V)."}],"title":"ASI System Control A","description":null},{"offset":"0x0B","name":"ASI_SYS_STATUS","fields":[{"size":2},{"name":"RSTSYS","title":"System Reset Active","description":"If this bit is set, there is an active Reset on the system domain. If this bit is cleared, the system is not in Reset. This bit is cleared on read. A reset held from the ASI_RESET_REQ register will also affect this bit."},{"name":"INSLEEP","title":"System Domain in Sleep","description":"If this bit is set, the system domain is in IDLE or deeper sleep mode. If this bit is cleared, the system is not in sleep."},{"name":"NVMPROG","title":"Start NVM Programming","description":"If this bit is set, NVM Programming can start from the UPDI. When the UPDI is done, it must reset the system through the UPDI Reset Register."},{"name":"UROWPROG","title":"Start User Row Programming","description":"If this bit is set, User Row Programming can start from the UPDI. When the UPDI is done, it must write the UROWWRITE_FINAL bit in ASI_SYS_CTRLA."},{},{"name":"LOCKSTATUS","title":"NVM Lock Status","description":"If this bit is set, the device is locked. If a Chiperase is done, and the Lockbits are cleared, this bit will read as zero."}],"title":"ASI System Status","description":null},{"offset":"0x0C","name":"ASI_CRC_STATUS","fields":[{"size":5},{"name":"CRC_STATUS","size":3,"title":"CRC Execution Status","description":"These bits signalize the status of the CRC conversion. The bits are one-hot encoded. \\n | Value | Description |\\n | ----- | ----------- |\\n | 0x0|Not enabled |\\n | 0x1|CRC enabled, busy |\\n | 0x2|CRC enabled, done with OK signature |\\n | 0x4|CRC enabled, done with FAILED signature\\nOther Reserved |\\n"}],"title":"ASI CRC Status","description":null}]}]}')},63:function(e,t,i){e.exports=i(365)},68:function(e,t,i){},69:function(e,t,i){},72:function(e,t,i){},79:function(e,t,i){},80:function(e,t,i){}},[[63,1,2]]]);
//# sourceMappingURL=main.b09ba760.chunk.js.map